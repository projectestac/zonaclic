/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "default": () => (/* binding */ JClic)
});

// UNUSED EXPORTS: JClicObject, loadProject

;// CONCATENATED MODULE: external "jquery"
const external_jquery_namespaceObject = require("jquery");
var external_jquery_default = /*#__PURE__*/__webpack_require__.n(external_jquery_namespaceObject);
;// CONCATENATED MODULE: external "jszip"
const external_jszip_namespaceObject = require("jszip");
var external_jszip_default = /*#__PURE__*/__webpack_require__.n(external_jszip_namespaceObject);
;// CONCATENATED MODULE: external "jszip-utils"
const external_jszip_utils_namespaceObject = require("jszip-utils");
var external_jszip_utils_default = /*#__PURE__*/__webpack_require__.n(external_jszip_utils_namespaceObject);
;// CONCATENATED MODULE: external "scriptjs"
const external_scriptjs_namespaceObject = require("scriptjs");
var external_scriptjs_default = /*#__PURE__*/__webpack_require__.n(external_scriptjs_namespaceObject);
;// CONCATENATED MODULE: external "clipboard-polyfill"
const external_clipboard_polyfill_namespaceObject = require("clipboard-polyfill");
;// CONCATENATED MODULE: external "webfontloader"
const external_webfontloader_namespaceObject = require("webfontloader");
var external_webfontloader_default = /*#__PURE__*/__webpack_require__.n(external_webfontloader_namespaceObject);
;// CONCATENATED MODULE: ./src/GlobalData.js

// WARNING: Auto-generated file, based on "language.po" files stored in "/locales". Do not edit!
// Launch "npm run build-locales" to update this file

/* harmony default export */ const GlobalData = ({"version":"2.1.11 (2022-08-04)","languages":["en","ar","ast","bs","ca","ca_ES@valencia","cs","da","de","el","es","eu","fr","gl","he","it","ja","nl","pl","pt","pt_BR","ro","ru","tr","vec","zh_TW"],"messages":{"ar":{"Version":"الإصدار","time":"الوقت","actions":"المحاولات","score":"النتيجة","Next activity":"النشاط التالي","Previous activity":"النشاط السابق","Restart activity":"استئنف النشاط","Information":"المعلومة","Current results":"تقارير المستخدم","User:":"المستخدم:","Projects:":"المشاريع:","Project":"المشروع:","sequence":"التسلسل","activity":"النشاط","OK":"موافق","Total:":"المجموع:"},"ast":{"Version":"Versión","time":"tiempu","actions":"intentos","score":"marcador","Next activity":"Xera siguiente","Previous activity":"Xera anterior","Restart activity":"Reaniciar xera","Information":"Información","Results are not currently being saved":"L'informe nun ta rexistráu en nenguna base de datos","Current results":"Informes d'usuariu","Session started:":"Entamu de sesión:","Reports system:":"Sistema d'informes:","User:":"Usuariu:","Projects:":"Proyeutos:","Sequences:":"Secuencies:","Activities done:":"Xeres feches:","Activities solved:":"Xeres correctes:","Global score:":"Puntuación global:","Total time in activities:":"Tiempu total en xeres:","Actions done:":"Aiciones feches:","No activities done!":"¡Nenguna información sobre xeres!","Project":"Proyeutu:","sequence":"Secuencia","activity":"Xera","OK":"OK","YES":"SI","NO":"NON","Total:":"Total:"},"bs":{"Version":"Verzija","time":"vrijeme","actions":"pokušaji","score":"rezultat","Next activity":"Sljedeća aktivnost","Previous activity":"Prethodna aktivnost","Restart activity":"Ponovno pokreni aktivnost","Information":"Informacije","Current results":"Izvješća korisnika","Session started:":"Sesija započeta:","User:":"Korisnik:","Projects:":"Projekti:","Activities done:":"Urađene aktivnosti:","Activities solved:":"Aktivnosti ok:","Global score:":"Ukupan rezultat:","Total time in activities:":"Ukupno vrijeme aktivnosti:","Actions done:":"Urađene aktivnosti:","Project":"Projekt:","sequence":"Sekvenca","activity":"Aktivnost","OK":"Uredu","YES":"DA","NO":"NE","Total:":"Ukupno:"},"ca":{"Version":"Versió","time":"temps","actions":"accions","score":"encerts","Next activity":"Activitat següent","Previous activity":"Activitat anterior","Restart activity":"Reinicia l'activitat","Information":"Informació","Results are not currently being saved":"Els resultats no s'estan desant","Current results":"Resultats actuals","Session started:":"Inici de sessió:","Reports system:":"Sistema d'informes:","User:":"Usuari/ària:","Projects:":"Projectes:","Sequences:":"Seqüències:","Activities done:":"Activitats fetes:","Activities solved:":"Activitats resoltes:","Global score:":"Puntuació global:","(out of all project activities)":"(sobre totes les activitats del projecte)","Total time in activities:":"Temps total en les activitats:","Actions done:":"Accions fetes:","No activities done!":"No heu fet cap activitat!","Project":"Projecte","sequence":"seqüència","activity":"activitat","OK":"OK","YES":"SÍ","NO":"NO","Total:":"Totals:","Select group:":"Seleccioneu el grup:","Select user:":"Seleccioneu l'usuari:","Cancel":"Cancel·la","Close":"Tanca","Copy data to clipboard":"Copia les dades al porta-retalls","The data has been copied in HTML format. Please paste them into a spreadsheet or in a rich text editor":"Les dades s'han copiat en format HTML. Enganxeu-les a un full de càlcul o a un editor de text enriquit.","The data has been copied to clipboard":"Les dades s'han copiat al porta-retalls","not connected":"no connectat","Please wait until the results of your activities are sent to the reports system":"Si us plau, espereu a que els resultats de les vostres activitats s'enviïn al servidor d'informes","Password:":"Contrasenya:","Incorrect password":"Contrasenya incorrecta","Invalid user":"Usuari/ària incorrecte","Partial score:":"Puntuació parcial:","(out of played activities)":"(sobre les activitats fetes)","Activities played at least once:":"Activitats fetes almenys una vegada:","Reports":"Informes","Toggle full screen":"Commuta pantalla completa","JClic logo":"Logotip del JClic","message":"missatge","Activity panel":"Tauler d'activitats","cell":"cel·la","image":"imatge","source":"origen","target":"destí","image fragment":"fragment d'imatge"},"ca_ES@valencia":{"Version":"Versió","time":"temps","actions":"accions","score":"encerts","Next activity":"Activitat següent","Previous activity":"Activitat anterior","Restart activity":"Reinicia l'activitat","Information":"Informació","Results are not currently being saved":"Els resultats no s'estan alçant","Current results":"Resultats actuals","Session started:":"Inici de sessió:","Reports system:":"Sistema d'informes:","User:":"Usuari/ària:","Projects:":"Projectes:","Sequences:":"Seqüències:","Activities done:":"Activitats fetes:","Activities solved:":"Activitats resoltes:","Global score:":"Puntuació global:","Total time in activities:":"Temps total en les activitats:","Actions done:":"Accions fetes:","No activities done!":"No heu fet cap activitat!","Project":"Projecte","sequence":"seqüència","activity":"activitat","OK":"OK","YES":"SÍ","NO":"NO","Total:":"Totals:"},"cs":{"Version":"Verze","time":"čas","actions":"pokusů","score":"skóre","Next activity":"Další aktivita","Previous activity":"Předchozí aktivita","Restart activity":"Restartovat aktivitu","Information":"Informace","Results are not currently being saved":"Zpráva není zaregistrována v žádné DB","Current results":"Uživatelská sestava","Session started:":"Sezení spuštěno:","Reports system:":"Systém zprávy:","User:":"Uživatel:","Projects:":"Projekty:","Sequences:":"Sekvence:","Activities done:":"Dokončené aktivity:","Activities solved:":"Aktivity ok:","Global score:":"Celkové skóre:","Total time in activities:":"Celkový čas aktivit:","Actions done:":"Provedené akce:","No activities done!":"Nebyly nahlášeny žádné aktivity!","Project":"Projekt","sequence":"Sekvence","activity":"Aktivita","OK":"Ok","YES":"ANO","NO":"NE","Total:":"Celkem:"},"da":{"Version":"Version","time":"tid","actions":"forsøg","score":"score","Next activity":"Næste aktivitet","Previous activity":"Forrige aktivitet","Restart activity":"Genstart aktivitet","Information":"Information","Current results":"Bruger rapport","User:":"Bruger:","Projects:":"Projekter:","Sequences:":"Sekvenser:","Activities done:":"Aktiviteter udført:","Activities solved:":"Aktiviteter OK:","Global score:":"Global score:","No activities done!":"Ingen aktiviteter rapporteret!","Project":"Projekt","sequence":"Sequence","activity":"Aktivitet","OK":"Ok","YES":"JA","NO":"IKKE","Total:":"Total:"},"de":{"Version":"Version","time":"Zeit","actions":"Versuche","score":"Ergebnis","Next activity":"Nächste Übung","Previous activity":"Vorherige Übung","Restart activity":"Übung neu starten","Information":"Information","Results are not currently being saved":"Bericht in keiner Datenbank eingetragen","Current results":"Benutzerberichte","Session started:":"Sitzung gestartet:","Reports system:":"Report system:","User:":"User:","Projects:":"Projekte:","Sequences:":"Sequenzen:","Activities done:":"Beendete Übungen:","Activities solved:":"Korrekte Übungen:","Global score:":"Gesamtpunktezahl:","Total time in activities:":"Übungs-Gesamtzeit:","Actions done:":"Durchgeführte Aktionen:","No activities done!":"Keine Übungsberichte vorhanden!","Project":"Projekt","sequence":"Sequenz","activity":"Übung","OK":"OK","YES":"JA","NO":"NEIN","Total:":"Gesamt:"},"el":{"Version":"Έκδοση","time":"χρόνος","actions":"προσπάθειες","score":"βαθμολογία","Next activity":"Επόμενη δραστηριότητα","Previous activity":"Προηγούμενη δραστηριότητα","Restart activity":"Επανεκκίνηση δραστηριότητας","Information":"Πληροφορίες","Results are not currently being saved":"Η αναφορά δεν εγγράφηκε στις βάσεις δεδομένων","Current results":"Αναφορές χρήστη","Session started:":"Έναρξη συνεδρίας:","Reports system:":"Σύστημα αναφορών:","User:":"Χρήστης:","Projects:":"Έργα:","Sequences:":"Αλληλουχίες:","Activities done:":"Ολοκληρωμένες δραστηριότητες:","Activities solved:":"Δραστηριότητες, εντάξει:","Global score:":"Συνολική βαθμολογία:","Total time in activities:":"Συνολικός χρόνος δραστηριοτήτων:","Actions done:":"Οι ενέργειες ολοκληρώθηκαν:","No activities done!":"Για καμμία δραστηριότητα δεν έχει υποβληθεί αναφορά!","Project":"Έργο","sequence":"Αλληλουχία","activity":"Δραστηριότητα","OK":"Εντάξει","YES":"Ναί","NO":"όχι","Total:":"Σύνολο:"},"es":{"Version":"Versión","time":"tiempo","actions":"acciones","score":"aciertos","Next activity":"Actividad siguiente","Previous activity":"Actividad anterior","Restart activity":"Reiniciar actividad","Information":"Información","Results are not currently being saved":"Los resultados no se están guardando","Current results":"Resultados actuales","Session started:":"Inicio de sesión:","Reports system:":"Sistema de informes:","User:":"Usuario/aria:","Projects:":"Proyectos:","Sequences:":"Secuencias:","Activities done:":"Actividades realizadas:","Activities solved:":"Actividades resueltas:","Global score:":"Puntuación global:","(out of all project activities)":"(sobre todas las actividades del proyecto)","Total time in activities:":"Tiempo total en las actividades:","Actions done:":"Acciones realizadas:","No activities done!":"¡No se ha realizado ninguna actividad!","Project":"Proyecto","sequence":"secuencia","activity":"actividad","OK":"OK","YES":"SI","NO":"NO","Total:":"Totales:","Select group:":"Seleccionar grupo:","Select user:":"Seleccionar usuario:","Cancel":"Cancelar","Close":"Cerrar","Copy data to clipboard":"Copiar datos al portapapeles","The data has been copied in HTML format. Please paste them into a spreadsheet or in a rich text editor":"Los datos se han copiado en formato HTML. Puedes pegarlos en una hoja de cálculo o en un editor de texto rico.","The data has been copied to clipboard":"Los datos se han copiado al portapapeles","not connected":"no conectado","Please wait until the results of your activities are sent to the reports system":"Por favor, espera mientras los resultados de las actividades se envian al servidor de informes","Password:":"Contraseña:","Incorrect password":"Contraseña incorrecta","Invalid user":"Usuario incorrecto","Partial score:":"Puntuación parcial:","(out of played activities)":"(sobre las actividades realizadas)","Activities played at least once:":"Actividades realizadas al menos una vez:","Reports":"Informes","Toggle full screen":"Conmutar pantalla completa","JClic logo":"Logotipo de JClic","message":"mensaje","Activity panel":"Panel de actividad","cell":"celda","image":"imagen","source":"origen","target":"destino","image fragment":"fragmento de imagen"},"eu":{"Version":"Bertsioa","time":"denbora","actions":"saiakerak","score":"puntuazioa","Next activity":"Hurrengo jarduera","Previous activity":"Aurreko jarduera","Restart activity":"Jarduera berriro hasi","Information":"Informazioa","Results are not currently being saved":"Txostena ez dago ezein datu-basetan","Current results":"Erabiltzailearen txostenak","Session started:":"Saio-hasiera:","Reports system:":"Txosten-sistema:","User:":"Erabiltzailea:","Projects:":"Proiektuak:","Sequences:":"Sekuentziak:","Activities done:":"Burututako ekinzak:","Activities solved:":"Jarduera zuzenak:","Global score:":"Jarduera zuzenak:","Total time in activities:":"Jardueretan emandako denbora guztira:","Actions done:":"Burututako ekintzak:","No activities done!":"Ez da jardueren txostenik!","Project":"Proiektua","sequence":"Sekuentzia","activity":"Jarduera","OK":"Ados","YES":"BAI","NO":"EZ","Total:":"Guztira:"},"fr":{"Version":"Version","time":"temps","actions":"essais","score":"résultat","Next activity":"Activité suivante","Previous activity":"Activité précédente","Restart activity":"Recommencer l'activité","Information":"Information","Results are not currently being saved":"Le rapport n'est enregistré dans aucune base de données","Current results":"Rapports utilisateur","Session started:":"Session démarrée:","Reports system:":"Report système:","User:":"Utilisateur:","Projects:":"Projets:","Sequences:":"Séquences:","Activities done:":"Activités faites:","Activities solved:":"Activités ok:","Global score:":"Score global:","(out of all project activities)":"(Hors de toutes les activités du projet)","Total time in activities:":"Temps total sur les activités:","Actions done:":"Actions faites:","No activities done!":"Pas d'activités rapportées!","Project":"Projet","sequence":"séquence","activity":"activité","OK":"Ok","YES":"OUI","NO":"NON","Total:":"Total:","Select group:":"Sélectionner un groupe:","Select user:":"Sélectionner l'utilisateur:","Cancel":"Annuler","Close":"Fermer","Copy data to clipboard":"Copier les données dans le presse-papier","The data has been copied in HTML format. Please paste them into a spreadsheet or in a rich text editor":"Les données ont été copiées au format HTML. Veuillez les coller dans une feuille de calcul ou dans un éditeur de texte","The data has been copied to clipboard":"Les données sont copier dans le presse-papier","not connected":"Non connecté ","Please wait until the results of your activities are sent to the reports system":"Veuillez patienter durant l'envoi de votre activité au rapport système","Password:":"Mot de passe: ","Incorrect password":"Mot de passe incorrect","Invalid user":"Utilisateur invalide","Partial score:":"Score partiel:","(out of played activities)":"(Hors activités jouées)","Activities played at least once:":"Les activités joué au moins une fois:","Reports":"Rapport","Toggle full screen":"Basculer en plein écran","JClic logo":"JClic logo","message":"message","Activity panel":"Groupe d'activités","cell":"cellule","image":"image","source":"source","target":"cible","image fragment":"fragment d'image"},"gl":{"Version":"Versión","time":"tempo","actions":"intentos","score":"acertos","Next activity":"Seguinte actividade","Previous activity":"Anterior actividade","Restart activity":"Reiniciar a actividade","Information":"Información","Results are not currently being saved":"O informe non está rexistrado en ningunha base de datos","Current results":"Informes de usuario","Session started:":"Inicio de sesión:","Reports system:":"Sistema de informes:","User:":"Usuario:","Projects:":"Proxectos:","Sequences:":"Secuencias:","Activities done:":"Actividades realizadas:","Activities solved:":"Actividades correctas:","Global score:":"Puntuación global:","Total time in activities:":"Tempo total nas actividades:","Actions done:":"Accións efectuadas:","No activities done!":"Non hai informada ningunha actividade!","Project":"Proxecto","sequence":"secuencia","activity":"actividade","OK":"Correcta","YES":"SI","NO":"NON","Total:":"Total:"},"he":{"Version":"גירסה","time":"זמן","actions":"נסיונות","score":"ניקוד","Next activity":"הפעילות הבאה","Previous activity":"הפעילות הקודמת","Restart activity":"התחל פעילות מחדש","Information":"מידע","Results are not currently being saved":"הדיווח אינו רשום במסד נתונים כלשהו","Current results":"דוחות משתמש","Session started:":"הפעלה החלה:","Reports system:":"מערכת דוחות:","User:":"משתמש:","Projects:":"פרוייקטים:","Sequences:":"רצפים:","Activities done:":"פעילויות שהושלמו:","Activities solved:":"פעילויות מאושרות:","Global score:":"ניקוד כללי:","Total time in activities:":"משך הפעילויות המצטבר:","Actions done:":"פעולות שבוצעו:","No activities done!":"לא דווחו פעילויות!","Project":"פרוייקט","sequence":"רצף","activity":"פעילות","OK":"אישור","YES":"כן","NO":"לא","Total:":"סך הכל:"},"it":{"Version":"Versione","time":"tempo","actions":"tentativi","score":"punteggio","Next activity":"Attività successiva","Previous activity":"Attività precedente","Restart activity":"Riavvia l'attività","Information":"Informazioni","Results are not currently being saved":"Rapporto non registrato in alcun database","Current results":"Rapporti utente","Session started:":"Sessione avviata:","Reports system:":"Sistema dei rapporti:","User:":"Utente:","Projects:":"Progetti:","Sequences:":"Sequenze:","Activities done:":"Attività eseguite:","Activities solved:":"Attività ok:","Global score:":"Punteggio globale:","Total time in activities:":"Tempo totale nelle attività:","Actions done:":"Azioni compiute:","No activities done!":"Nessuna attività a rapporto!","Project":"Progetto","sequence":"sequenza","activity":"attività","OK":"Ok","YES":"SI","NO":"NO","Total:":"Totale:"},"ja":{"Version":"バージョン","time":"時間","actions":"アクション","score":"スコア","Next activity":"次のアクティビティ","Previous activity":"前のアクティビティ","Restart activity":"アクティビティを再起動","Information":"情報","Results are not currently being saved":"結果は、現在保存されていません","Current results":"現在の結果","Session started:":"セッションが開始しました:","Reports system:":"レポート システム:","User:":"ユーザー:","Projects:":"プロジェクト:","Sequences:":"シーケンス:","Activities done:":"完了したアクティビティ:","Activities solved:":"解決したアクティビティ:","Global score:":"グローバル スコア:","(out of all project activities)":"(すべてのプロジェクト アクティビティの結果)","Total time in activities:":"アクティビティ時間の合計:","Actions done:":"完了したアクション:","No activities done!":"アクティビティは行われていません!","Project":"プロジェクト","sequence":"シーケンス","activity":"アクティビティ","OK":"OK","YES":"はい","NO":"いいえ","Total:":"合計:","Select group:":"グループを選択:","Select user:":"ユーザーを選択:","Cancel":"キャンセル","Close":"閉じる","Copy data to clipboard":"データをクリップボードにコピー","The data has been copied in HTML format. Please paste them into a spreadsheet or in a rich text editor":"データは HTML 形式でコピーされます。リッチ テキスト エディターやスプレッドシートに貼り付けてください","The data has been copied to clipboard":"クリップボードにデータがコピーされました","not connected":"接続されていません","Please wait until the results of your activities are sent to the reports system":"アクティビティの結果がレポート システムに送信されるまでお待ちください","Password:":"パスワード:","Incorrect password":"パスワードが正しくありません","Invalid user":"無効なユーザー","Partial score:":"部分スコア:","(out of played activities)":"(プレイしたアクティビティの結果)","Activities played at least once:":"少なくとも一度プレイしたアクティビティ:","Reports":"レポート","Toggle full screen":"全画面の切り替え","JClic logo":"JClic ロゴ","message":"メッセージ","Activity panel":"アクティビティ パネル","cell":"セル","image":"画像","source":"ソース","target":"ターゲット","image fragment":"画像フラグメント"},"nl":{"Version":"Versie","time":"tijd","actions":"pogingen","score":"punten","Next activity":"Volgende activiteit","Previous activity":"Vorige activiteit","Restart activity":"Herstart activiteit","Information":"Informatie","Results are not currently being saved":"Rapport niet geregistreerd in een DB","Current results":"Gebruikers rapport","Session started:":"Reeks gestart:","Reports system:":"Rapporteer systeem:","User:":"Gebruiker:","Projects:":"Projecten:","Sequences:":"Reeksen:","Activities done:":"Activiteiten klaar:","Activities solved:":"Activiteiten ok:","Global score:":"Puntentotaal:","Total time in activities:":"Totale tijd activiteiten:","Actions done:":"Einde activiteiten:","No activities done!":"Geen activiteiten gerapporteerd!","Project":"Project","sequence":"Volgorde","activity":"Activiteit","OK":"Ok","YES":"JA","NO":"NEE","Total:":"Totaal:"},"pl":{"Version":"Wersja","time":"czas","actions":"działania","score":"wynik","Next activity":"Następne działanie","Previous activity":"Poprzednia aktywność","Restart activity":"Restartuj aktywność","Information":"Informacje","Results are not currently being saved":"Wyniki nie są obecnie zapisywane","Current results":"Aktualne wyniki","Session started:":"Sesja rozpoczęła się:","Reports system:":"System raportów:","User:":"Użytkownik:","Projects:":"Projekty:","Sequences:":"Sekwencje:","Activities done:":"Działania wykonane:","Activities solved:":"Działania rozwiązane:","Global score:":"Globalny wynik:","(out of all project activities)":"(poza wszystkimi działaniami projektu)","Total time in activities:":"Całkowity czas aktywności:","Actions done:":"Wykonane czynności:","No activities done!":"Nie wykonano żadnych czynności!","Project":"Projekt","sequence":"kolejność","activity":"aktywność","OK":"OK","YES":"Tak","NO":"Nie","Total:":"Całkowity:","Select group:":"Wybierz grupę:","Select user:":"Wybierz użytkownika:","Cancel":"Anuluj","Close":"Zamknij","Copy data to clipboard":"Skopiuj dane do schowka","The data has been copied in HTML format. Please paste them into a spreadsheet or in a rich text editor":"Dane zostały skopiowane w formacie HTML. Wklej je do arkusza kalkulacyjnego lub edytora tekstu","The data has been copied to clipboard":"Dane zostały skopiowane do schowka","not connected":"nie połączony","Please wait until the results of your activities are sent to the reports system":"Poczekaj, aż wyniki Twoich działań zostaną przesłane do systemu raportów","Password:":"Hasło:","Incorrect password":"Niepoprawne hasło","Invalid user":"Nieprawidłowy użytkownik","Partial score:":"Wynik częściowy:","(out of played activities)":"(z granych działań)","Activities played at least once:":"Działania grane co najmniej raz:","Reports":"Raporty","Toggle full screen":"Przełącz tryb pełnoekranowy","JClic logo":"Logo JClic","message":"komunikat","Activity panel":"Panel aktywności","cell":"komórka","image":"obraz","source":"źródło","target":"miejsce docelowe","image fragment":"fragment obrazu"},"pt":{"Version":"Versão","time":"tempo","actions":"tentativas","score":"acertos","Next activity":"Actividade seguinte","Previous activity":"Actividade anterior","Restart activity":"Reiniciar a actividade","Information":"Informação","Results are not currently being saved":"O relatório não está registado em nenhuma base de dados","Current results":"Relatórios do utilizador","Session started:":"Início da sessão:","Reports system:":"Sistema de relatórios:","User:":"Utilizador:","Projects:":"Projectos:","Sequences:":"Sequências:","Activities done:":"Actividades realizadas:","Activities solved:":"Actividades correctas:","Global score:":"Pontuação global:","Total time in activities:":"Tempo total das actividades:","Actions done:":"Acções efectuadas:","No activities done!":"Nenhuma actividade registada!","Project":"Projecto","sequence":"sequência","activity":"Actividade","OK":"Correcta","YES":"sim","NO":"não","Total:":"Total:"},"pt_BR":{"Version":"Versão","time":"tempo","actions":"tentativas","score":"acertos","Next activity":"atividade seguinte","Previous activity":"atividade anterior","Restart activity":"Reiniciar a atividade","Information":"Informação","Results are not currently being saved":"O relatório não está registrando em nenhuma base de dados","Current results":"relatórios de usuário","Session started:":"Início da sessão:","Reports system:":"Sistema de relatórios:","User:":"Usuário:","Projects:":"Projetos:","Sequences:":"Sequências:","Activities done:":"Atividades realizadas:","Activities solved:":"Atividades corretas:","Global score:":"Pontuação geral:","Total time in activities:":"Tempo total das atividades:","Actions done:":"Ações efetuadas:","No activities done!":"Nenhuma atividade registrada!","Project":"Projeto","sequence":"sequência","activity":"atividade","OK":"Correta","YES":"sim","NO":"não","Total:":"Total:"},"ro":{"Version":"Versiune","time":"timp","actions":"acțiuni","score":"rezultat","Next activity":"Activitatea următoare","Previous activity":"Activitatea anterioară","Restart activity":"Restartează activitatea","Information":"Informații","Results are not currently being saved":"Rezultatul nu pare a fi salvat","Current results":"Rezultatul curent","Session started:":"Sesiune pornită la:","Reports system:":"Sistem raportare:","User:":"Utilizator","Projects:":"Proiecte:","Sequences:":"Secvențe:","Activities done:":"Activități realizate: ","Activities solved:":"Activități rezolvate: ","Global score:":"Rezultat global:","(out of all project activities)":"(în afara activităților din proiect)","Total time in activities:":"Timp total în activitate:","Actions done:":"Activități realizate: ","No activities done!":"Activități nerealizate: ","Project":"Proiect","sequence":"secvență","activity":"activitate","OK":"OK","YES":"DA","NO":"NU","Total:":"Total:","Select group:":"Alege grup:","Select user:":"Alege utilizator:","Cancel":"Anuleaza","Close":"Închide","Copy data to clipboard":"Copiază datele in clipboard","The data has been copied in HTML format. Please paste them into a spreadsheet or in a rich text editor":"Datele au fost copiate în format HTML. Vă rog lipiți-le într-o foaie de calcul sau într-un editor compatibil rich text","The data has been copied to clipboard":"Datele au fost copiate în clipboard","not connected":"neconectat","Please wait until the results of your activities are sent to the reports system":"Vă rugăm să așteptați până ce rezultatele activităților sunt trimise către sistemul de raportare","Password:":"Parolă:","Incorrect password":"Parolă incorectă","Invalid user":"Utilizator incorect","Partial score:":"Rezultat parțial:","(out of played activities)":"(în afara activități jucate) ","Activities played at least once:":"Activități jucate cel puțin o dată: ","Reports":"Rapoarte","Toggle full screen":"Comută în ecran plin","JClic logo":"Jclic logo","message":"mesaj","Activity panel":"Panou activități","cell":"celulă","image":"imagine","source":"sursă","target":"țintă","image fragment":"fragment de imagine "},"ru":{"Version":"Версия","time":"время","actions":"попытки","score":"счёт","Next activity":"Следующее действие","Previous activity":"Предыдущее действие","Restart activity":"Перезапуск действия","Information":"Информация","Results are not currently being saved":"Отчёт не зарегистрирован в БД","Current results":"Отчёты пользователя","Session started:":"Сессия начата:","Reports system:":"Система отчётов:","User:":"Пользователь:","Projects:":"Проекты:","Sequences:":"Последовательности:","Activities done:":"Совершенные действия:","Activities solved:":"Действия в порядке:","Global score:":"Общий счёт:","Total time in activities:":"Общее время активности:","Actions done:":"Завершено действий:","No activities done!":"Нет сообщенных действий!","Project":"Проект","sequence":"Последовательность","activity":"Активность","OK":"ОК","YES":"да","NO":"нет","Total:":"Итого:"},"tr":{"Version":"Sürüm","time":"zaman","actions":"Denemeler","score":"sonuç","Next activity":"Bir sonraki etkinlik","Previous activity":"Bir önceki etkinlik","Restart activity":"Etkinliği tekrar başlat","Information":"Bilgi","Results are not currently being saved":"Rapor herhangi bir veritabanında kaydedilmedi","Current results":"Kullanıcı raporları","Session started:":"Oturum başlatıldı","Reports system:":"Sistem raporu:","User:":"Kullanıcı:","Projects:":"Projeler:","Sequences:":"Etkinlik dizisi","Activities done:":"Etkinlikler başlatılıyor:","Activities solved:":"Etkinlikler tamam:","Global score:":"Genel sonuç:","Total time in activities:":"Etkinlikde geçirilen toplam zaman:","Actions done:":"Eylem gerçekleştiriliyor:","No activities done!":"Etkinlik raporu yok!","Project":"Proje","sequence":"Etkinlik dizisi","activity":"Etkinlik","OK":"Tamam","YES":"Evet","NO":"hiçbir","Total:":"Toplam:"},"vec":{"Version":"Version","time":"tenpo","actions":"tentadivi","score":"pontexio","Next activity":"Pròsima atività","Previous activity":"Atività presedente","Restart activity":"Invìa atività da novo","Information":"Informasion","Results are not currently being saved":"Report no registrà inte nisun database","Current results":"Reports utenti","Session started:":"Sesion inviada:","Reports system:":"Sistèma de report","User:":"Utente:","Projects:":"Proxèti:","Sequences:":"Secuense:","Activities done:":"Atività fate:","Activities solved:":"Atività ok:","Global score:":"Pontexio global","Total time in activities:":"Tenpo total so ƚe atività","Actions done:":"Asion exeguìe","No activities done!":"No xé stà reportà atività!","Project":"Proxèto:","sequence":"secuensa","activity":"Atività","OK":"Ok","YES":"SI","NO":"NO","Total:":"Total:"},"zh_TW":{"Version":"版本","time":"時間","actions":"嘗試次數","score":"分數","Next activity":"下一個活動","Previous activity":"上一個活動","Restart activity":"重設活動","Information":"相關資訊","Results are not currently being saved":"回報在DB中無註冊","Current results":"使用者報告","Session started:":"工作開始：","Reports system:":"報告系統:","User:":"使用者:","Projects:":"專案：","Sequences:":"順序：","Activities done:":"活動結束:","Activities solved:":"活動完成:","Global score:":"總成績:","Total time in activities:":"活動總時間:","Actions done:":"活動完成：","No activities done!":"沒有活動報告","Project":"專案：","sequence":"順序","activity":"活動","OK":"確定","YES":"是","NO":"否","Total:":"總計："}}});
;// CONCATENATED MODULE: ./src/Utils.js
/**
 *  File    : Utils.js
 *  Created : 01/04/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */

/* global Promise, window, document, console, HTMLElement */









/**
 * Exports third-party NPM packages used by JClic, so they become available to other scripts through
 * the global variable `JClicObject` (defined in {@link module:JClic.JClic})
 * @example <caption>Example usage of JSZip through JClicObject</caption>
 * var WebFont = window.JClicObject.Utils.pkg.WebFont;
 * WebFont.load({google: {families: ['Roboto']}});
 * @type: {object}
 */
const pkg = {
  clipboard: external_clipboard_polyfill_namespaceObject,
  $: (external_jquery_default()),
  JSZip: (external_jszip_default()),
  JSZipUtils: (external_jszip_utils_default()),
  ScriptJS: (external_scriptjs_default()),
  WebFont: (external_webfontloader_default()),
};

/**
 * List of valid verbosity levels
 * @const {string[]}
 */
const LOG_LEVELS = ['none', 'error', 'warn', 'info', 'debug', 'trace', 'all'];

/**
 * Labels printed on logs for each message type
 * @const {string[]}
 */
const LOG_PRINT_LABELS = ['     ', 'ERROR', 'WARN ', 'INFO ', 'DEBUG', 'TRACE', 'ALL  '];

/**
 * Options of the logging system
 * @type {object} */
const LOG_OPTIONS = {
  level: 2, // warn
  prefix: 'JClic',
  timestamp: true,
  popupOnErrors: false,
  chainTo: null,
  pipeTo: null,
};

/**
 * Current dictionary of string translations
 */
let _messages = {};

/**
 * Initializes the global settings
 * @param {object} options - An object with global settings
 * @param {boolean} [setLog=true] - When `true`, the log level will be set
 * @param {boolean} [setLang=true] - When `true`, the current language will be set
 * @returns {object} The normalized `options` object
 */
function init(options, setLog = true, setLang = true) {
  options = normalizeObject(options);
  if (setLog) {
    if (typeof options.logLevel !== 'undefined')
      setLogLevel(options.logLevel);
    if (typeof options.chainLogTo === 'function')
      LOG_OPTIONS.chainTo = options.chainLogTo;
    if (typeof options.pipeLogTo === 'function')
      LOG_OPTIONS.pipeTo = options.pipeLogTo;
  }

  if (setLang) {
    const lngRequested = options.lang;
    const lng = checkPreferredLanguage(GlobalData.languages, 'en', lngRequested);
    log('debug', `Language ${lngRequested ? `requested: "${lngRequested}" ` : ''} used: "${lng}"`);
    _messages = lng === 'en' ? {} : GlobalData.messages[lng];
  }

  return options;
};

/**
 * Function that will return the translation of the provided key
 * into the current language.
 * @param {string} key - ID of the expression to be translated
 * @returns {string} - The translated text
 */
function getMsg(key) {
  return _messages[key] || key;
}

/**
 * Converts expressions of type 'pt-br', 'FR', 'ca_es@valencia'... to the format expected by the i18n system:
 * lc[_CC][@variant] where 'lc' is a two or three lowercase letter language code, CC is an optional two uppercase
 * letter country code, followed by an optional 'variant' consisting in letters and/or digits.
 * @param {string} locale - The locale expression to be normalized
 * @returns string - The normalized locale
 */
function normalizeLocale(locale = '') {
  const [, language = null, country = null, variant = null] = /^([a-zA-Z]{2,3})[_-]?([a-zA-Z]{2})?@?([a-zA-Z0-9]*)?$/.exec(locale.trim()) || [];
  return language
    ? `${language.toLowerCase()}${country ? `_${country.toUpperCase()}` : ''}${variant ? `@${variant.toLowerCase()}` : ''}`
    : '';
};

/**
 * Checks if the language preferred by the user (based on browser and/or specific settings)
 * is in a list of available languages.
 * @param {string[]} availableLangs - Array of available languages. It should contain at least one item.
 * @param {string} [defaultLang=en] - Language to be used by default when not found the selected one
 * @param {string} [requestedLang=''] - Request this specific language
 * @returns {string} - The most suitable language for this request
 */
function checkPreferredLanguage(availableLangs, defaultLang = 'en', requestedLang = '') {
  let result = -1;

  // Create an array to store possible values
  let tries = [];

  // If "setLang" is specified, check it
  if (requestedLang) {
    // Normalize requested locale
    const lang = normalizeLocale(requestedLang);
    if (lang)
      tries.push(lang);
  }

  // Add user's preferred languages, if any
  if (window.navigator.languages)
    tries = tries.concat(window.navigator.languages);

  // Add the navigator main language, if defined
  if (window.navigator.language)
    tries.push(window.navigator.language);

  // Add English as final option
  tries.push(defaultLang);

  for (let i = 0; i < tries.length; i++) {
    let match = -1;
    for (let n in availableLangs) {
      if (tries[i].indexOf(availableLangs[n]) === 0) {
        match = n;
        if (tries[i] === availableLangs[n]) {
          result = n;
          break;
        }
      }
    }
    if (result >= 0 || (result = match) >= 0)
      break;
  }
  return availableLangs[result >= 0 ? result : 0];
};

/**
 * Establishes the current verbosity level of the logging system
 * @param {string} level - One of the valid strings in {@link module:Utils.LOG_LEVELS}
 */
function setLogLevel(level) {
  const log = LOG_LEVELS.indexOf(level);
  if (log >= 0)
    LOG_OPTIONS.level = log;
};

/**
 * Reports a new message to the logging system
 * @param {string} type - The type of message. Mus be `error`, `warn`, `info`, `debug` or `trace`.
 * @param {string} msg - The main message to be logged. Additional parameters can be added, like
 * in `console.log` (see: {@link https://developer.mozilla.org/en-US/docs/Web/API/Console/log})
 */
function log(type, msg) {
  const level = LOG_LEVELS.indexOf(type);
  const args = Array.prototype.slice.call(arguments);

  // Check if message should currently be logged
  if (level < 0 || level <= LOG_OPTIONS.level) {
    if (LOG_OPTIONS.pipeTo)
      LOG_OPTIONS.pipeTo.apply(null, args);
    else {
      const mainMsg = `${LOG_OPTIONS.prefix || ''} ${LOG_PRINT_LABELS[level]} ${LOG_OPTIONS.timestamp ? getDateTime() : ''} ${msg}`;
      console[level === 1 ? 'error' : level === 2 ? 'warn' : 'log'].apply(console, [mainMsg].concat(args.slice(2)));
      // Call chained logger, if anny
      if (LOG_OPTIONS.chainTo)
        LOG_OPTIONS.chainTo.apply(null, args);
    }
  }
};

/**
 * Gets a boolean value from a textual expression
 * @param {string} val - The value to be parsed (`true` for true, null or otherwise for `false`)
 * @param {boolean} [defaultValue=false] - The default value to return when `val` is false
 * @returns {number}
 */
function getBoolean(val, defaultValue = false) {
  return val === 'true' ? true : val === 'false' ? false : defaultValue;
};

/**
 * Gets a value from an given expression that can be `null`, `undefined` or empty string ('')
 * @param {any} val - The expression to parse
 * @param {any} [defaultValue=null] - The value to return when `val` is `null`, `''` or `undefined`
 * @returns {any}
 */
function getVal(val, defaultValue = null) {
  return (val === '' || val === null || typeof val === 'undefined') ? defaultValue : val;
};

/**
 * Gets a number from a string or another number
 * @param {any} val - The expression to parse
 * @param {number} [defaultValue=0] - The default value
 * @returns {number}
 */
function getNumber(val, defaultValue) {
  return Number(getVal(val, defaultValue));
};

/**
 * Gets the plain percent expression (without decimals) of the given value
 * @param {number} val - The value to be expressed as a percentile
 * @returns {string}
 */
function getPercent(val) {
  return `${Math.round(val * 100)}%`;
}

/**
 * Returns the two-digits text expression representing the given number (lesser than 100) zero-padded at left
 * Useful for representing hours, minutes and seconds
 * @param {number} val - The number to be processed
 * @returns {string}
 */
function zp(val) {
  return `0${val}`.slice(-2);
};

/**
 * Returns a given time in [00h 00'00"] format
 * @param {number} millis - Amount of milliseconds to be processed
 * @returns {string}
 */
function getHMStime(millis) {
  const d = new Date(millis);
  const h = d.getUTCHours(), m = d.getUTCMinutes(), s = d.getUTCSeconds();
  return `${h ? h + 'h ' : ''}${h || m ? zp(m) + '\'' : ''}${zp(s)}"`;
};

/**
 * Returns a formatted string with the provided date and time
 * @param {external:Date} date - The date to be formatted. When `null` or `undefined`, the current date will be used.
 * @returns {string}
 */
function getDateTime(date = new Date()) {
  return `${date.getFullYear()}/${zp(date.getMonth() + 1)}/${zp(date.getDate())} ${zp(date.getHours())}:${zp(date.getMinutes())}:${zp(date.getSeconds())}`;
};

/**
 * Parse 'date' fields generated by "JClic Author" in format d/m/y, with
 * variable number of digits.
 * @param {string} text - The old 'date' field
 * @returns {external:Date} - Always return a Date object (now, if text was invalid)
 */
function parseOldDate(text) {
  let result = null;
  if (text) {
    const elements = text.trim().split('/');
    if (elements.length === 3) {
      let m = parseInt(elements[0]) || 0;
      let d = parseInt(elements[1]) || 0;
      let y = parseInt(elements[2]) || 0;
      if (m > 12 && d <= 12) {
        const t = m;
        m = d;
        d = t;
      }
      if (y < 1980)
        y += (y < 90 ? 2000 : 1900);
      if (d && m && y) {
        result = new Date(Date.parse(`${m}/${d}/${y}`));
      }
    }
  }
  return result || new Date();
};

/**
 * Extracts just the ISO-639 language code from complex
 * expressions like "English (en)", buid by JClic Author.
 * @param {string} text - The expression to parse
 * @returns {string} - The ISO-639 language code, or '--' if none found
 */
function cleanOldLanguageTag(text) {
  if (!text)
    text = '--';
  // Allow only ISO-639-1 and ISO-639-2 language codes
  else if (!text.match(/^[a-z][a-z][a-z]?$/)) {
    const matches = text.match(/\(([a-z][a-z][a-z]?)\)/);
    if (matches && matches.length === 2)
      text = matches[1];
    else
      text = '--';
  }
  return text;
};

/** @const {number} */
const FALSE = 0;

/** @const {number} */
const TRUE = 1;

/** @const {number} */
const DEFAULT = 2;

/**
 * Gets a numeric value (0, 1 or 2) from a set of possible values: `false`, `true` and `default`.
 * @param {string} val - The text to be parsed
 * @param {any} def - An optional default value
 * @returns {number}
 */
function getTriState(val, def = DEFAULT) {
  return val === 'true' ? TRUE : val === 'false' ? FALSE : def;
};

/**
 * Returns a string with the given `tag` repeated n times
 * @param {string} tag - The tag to be repeated
 * @param {number} repeats - The number of times to repeat the tag
 * @returns {string}
 */
function fillString(tag, repeats = 0) {
  return Array(repeats).fill(tag).join('');
};

/**
 * Checks if the provided value is 'null' or 'undefined'.
 * @param {any} val - The value to be parsed
 * @returns {boolean}
 */
function isNullOrUndef(val) {
  return typeof val === 'undefined' || val === null;
};

/**
 * Checks if two expressions are equivalent.
 * Returns `true` when both parameters are `null` or `undefined`, and also when both have
 * equivalent values.
 * @param {any} a
 * @param {any} b
 * @returns {boolean}
 */
function isEquivalent(a, b) {
  return (typeof a === 'undefined' || a === null) && (typeof b === 'undefined' || b === null) || a === b;
};

/**
 * Reads paragraphs, identified by `<p></p>` elements, inside XML data
 * @param {object} xml - The DOM-XML element to be parsed
 * @returns {string}
 */
function getXmlText(xml) {
  let text = '';
  external_jquery_default()(xml).children('p').each((_n, child) => { text += `<p>${child.textContent}</p>`; });
  return text;
};

/**
 * Parse the provided XML element node, returning a complex object
 * @param {object} xml - The root XML element to parse
 * @param {boolean} [withText=false] - When `true`, any text found inside the XML element is also included in the resulting object.
 * @returns {object}
 */
function parseXmlNode(xml, withText = false) {
  // Initialize the resulting object
  const result = {};
  // Direct copy of root element attributes as object properties
  if (xml.attributes)
    attrForEach(xml.attributes, (name, value) => result[name] = /^-?\d*$/.test(value) ? Number(value) : value);

  const keys = [];
  const children = Array.from(xml.children || xml.childNodes || []);

  // If all children is of type 'p', just compile it in a single string
  const paragraphs = children.filter(child => child.nodeName === 'p');
  if (paragraphs.length > 0 && paragraphs.length === children.filter(ch => ch.nodeName !== '#text').length) {
    const text = paragraphs.map(ch => ch.textContent).join('\n');
    if (xml.attributes) {
      result.text = text;
      return result;
    }
    return text;
  }

  // Process children elements
  children.forEach(child => {
    // Avoid extra text content collected by [xmldom](https://www.npmjs.com/package/xmldom)
    if (child.nodeName === '#text' && !withText)
      return;

    // Recursive processing of children
    const ch = parseXmlNode(child, withText);
    // Store the result into a temporary object named as the child node name,
    if (!result[child.nodeName]) {
      // Create object and save key for later processing
      result[child.nodeName] = {};
      keys.push(child.nodeName);
    }
    // Use 'id' (or an incremental number if 'id' is not set) as a key
    if (ch.id)
      result[child.nodeName][ch.id] = ch;
    else {
      const n = Object.keys(result[child.nodeName]).length;
      result[child.nodeName][n] = ch;
    }
  });
  // Check temporary objects, converting it to an array, a single object or a complex object
  keys.forEach(k => {
    // Retrieve temporary object from `keys`
    const kx = Object.keys(result[k]);
    // If all keys are numbers, convert object into an array (or leave it as a single object)
    if (!kx.find(kk => isNaN(kk))) {
      if (kx.length === 1)
        // Array with a single element. Leave it as a simple object:
        result[k] = result[k][0];
      else {
        // Object with numeric keys. Convert it to array:
        const arr = [];
        kx.forEach(kk => arr.push(result[k][kk]));
        result[k] = arr;
      }
    }
  });
  // Save text content, if any:
  if (children.length === 0 && xml.textContent)
    result.textContent = xml.textContent;
  return result;
};

/**
 * Parse the given XML node, known as containing only text elements,
 * and return its content as a string (when possible)
 * @param {object} xml - The XML element to parse
 * @returns {string|object}
 */
function getXmlNodeText(node) {
  const result = parseXmlNode(node);
  return typeof result === 'string' ?
    result :
    result.hasOwnProperty('text') ?
      result.text :
      result.hasOwnProperty('textContent') ?
        result.textContent :
        result;
};

/**
 * Recursively explore the given object, converting to a string
 * all attributes with a single attribute named 'text'.
 * Example:
 * {a:1, b:{text:"hello"}, c:{d:2, text:"world"}} => {a:1, b:"hello", c:{d:2, text:"world"}}
 * @param {object} obj - The object to explore
 * @returns {object} - The same object, with text attributes reduced to strings
 */
function reduceTextsToStrings(obj) {
  if (obj) {
    const keys = Object.keys(obj);
    keys.forEach(k => {
      const attr = obj[k];
      if (typeof attr === 'object') {
        const ko = Object.keys(attr);
        if (ko.length === 1 && ko[0] === 'text')
          obj[k] = attr.text;
        else
          obj[k] = reduceTextsToStrings(attr);
      }
    });
  }
  return obj;
};

/**
 * Creates a string suitable to be used in the 'style' attribute of HTML tags, filled with the
 * CSS attributes contained in the provided object.
 * @param {object} cssObj
 * @returns {string}
 */
function cssToString(cssObj) {
  return Object.keys(cssObj).reduce((s, key) => `${s}${key}:${cssObj[key]};`, '');
};

/**
 * Converts java-like color codes (like '0xRRGGBB') to valid CSS values like '#RRGGBB' or 'rgba(r,g,b,a)'
 * @param {string} [color] - A color, as codified in Java
 * @param {string} [defaultColor] - The default color to be used
 * @returns {string}
 */
function checkColor(color, defaultColor = settings.BoxBase.BACK_COLOR) {
  if (typeof color === 'undefined' || color === null)
    color = defaultColor;
  color = color.replace('0x', '#');
  // Check for Alpha value
  if (color.charAt(0) === '#' && color.length > 7) {
    const alpha = fx(parseInt(color.substring(1, 3), 16) / 255.0, 2);
    color = `rgba(${parseInt(color.substring(3, 5), 16)},${parseInt(color.substring(5, 7), 16)},${parseInt(color.substring(7, 9), 16)},${alpha})`;
  }
  return color;
};

/**
 * Checks if the provided color has an alpha value less than 1
 * @param {string} color - The color to be analyzed
 * @returns {boolean}
 */
function colorHasTransparency(color) {
  if (startsWith(color, 'rgba(')) {
    var alpha = parseInt(color.substr(color.lastIndexOf(',')));
    return typeof alpha === 'number' && alpha < 1.0;
  }
  return false;
};

/**
 * Clones the provided object
 * See: https://stackoverflow.com/questions/41474986/how-to-clone-a-javascript-es6-class-instance
 * @param {object} obj
 * @returns {object}
 */
//cloneObject: obj => Object.assign(Object.create(Object.getPrototypeOf(obj)), obj),
function cloneObject(obj) {
  return external_jquery_default().extend(true, Object.create(Object.getPrototypeOf(obj)), obj);
};

/**
 * Converts string values to number or boolean when needed
 * @param {object} obj - The object to be processed
 * @returns {object} - A new object with normalized content
 */
function normalizeObject(obj) {
  const result = {};
  if (obj)
    external_jquery_default().each(obj, (key, value) => {
      let s;
      if (typeof value === 'string' && (s = value.trim().toLowerCase()) !== '')
        value = s === 'true' ? true : s === 'false' ? false : isNaN(s) ? value : Number(s);
      result[key] = value;
    });
  return result;
};

/**
 * Returns an partial clone of an object, containing only the own attributes specified in an array of possible keys.
 * When the value of an attribute is of type 'Object' and this object has a method named `getAttributes`, the result of calling
 * this method is returned instead of the crude object.
 * @param {object} obj - The object to be processed
 * @param {string[]} [keys] - An optional array of keys to be included in the resulting object.
 * When null or not set, all keys of `obj` are included. Keys can include a default value separed by '|'.
 * Attributes with default value will be excluded from the resulting object.
 * @returns {object}
 */
function getAttr(obj, keys = null) {
  let result = {};
  keys = keys || Object.keys(obj);
  keys.forEach(key => {
    const [k, d] = key.split('|');
    if (obj.hasOwnProperty(k) && typeof obj[k] !== 'undefined' && obj[k] !== null && obj[k].toString() !== d) {
      const v = getValue(obj[k]);
      if (!isEmpty(v))
        result[k] = v;
    }
  });

  // Convert to string objects with only a "text" attribute
  keys = Object.keys(result);
  if (keys.length === 1 && keys[0] === 'text')
    result = result.text;

  return result;
};

/**
 * Gets the minimal representation of the given value (object, array, string, number...)
 * @param {any} value - The value to be processed
 * @returns {any}
 */
function getValue(value) {
  return value.getAttributes ?
    value.getAttributes() :
    value instanceof Array ?
      value.map(e => getValue(e)) :
      value instanceof Date ?
        value.toISOString() :
        value instanceof Object ?
          getAttr(value) :
          value;
};

/**
 * Checks if the given value is an empty object, null or a zero-length string
 * @param {any} v - The value to be checked
 * @returns {boolean} - `true` if `v` is `{}`, `null` or `""`
 */
function isEmpty(v) {
  let result = (typeof v === 'undefined' || v === null);
  if (!result) {
    switch (typeof v) {
      case 'object':
        result = Object.keys(v).length === 0;
        break;

      case 'string':
        result = v.length === 0;
        break;
    }
  }
  return result;
};

/**
 * Fills an object with specific attributes from another data object
 * @param {object} obj - The target object
 * @param {object} data - The data object
 * @param {string[]} attr - The list of attributes to be copied from `data` to `obj`
 *                          Elements of this list can be:
 *                          a) Just a string. In this case, the native object will be used as a value
 *                          b) An object with the following members:
 *                          - `key`{string} - The attribute name
 *                          - `fn` {function} - The function to be invoked to build the object
 *                          - `params` {string[]} - Optional params to be passed to the `setAttributes` method of the created object
 *                          - `group` {string} - Used when `data` is an object or an array (possible values are `object` and `array`), and multiple results
 *                                               should be aggregated in a resulting object or array with the same keys (or ordering) as data.
 *                          - `init` {string} - Optional parameter indicating if `fn` should be passed with an additional param. This param can be:
 *                            - `key` - The member's key
 *
 * @returns {object} - Always returns `obj`
 */
function setAttr(obj, data, attr) {
  attr.forEach(a => {
    if (a.key) {
      const { key, fn, group, init, params } = a;
      // A new object should be built
      if (!isEmpty(data[key])) {
        const dataset = data[key];
        if (group === 'object')
          obj[key] = Object.keys(dataset).reduce((o, k) => {
            o[k] = buildObj(fn, dataset[k], init === 'key' ? k : init, params);
            return o;
          }, {});
        else if (group === 'array')
          obj[key] = dataset.map((element, n) => buildObj(fn, element, init === 'key' ? n : init, params));
        else
          obj[key] = buildObj(fn, dataset, init, params);
      }
    } else if (!isEmpty(data[a]))
      obj[a] = data[a];
  });
  return obj;
};

/**
 * Builds a new object based on the provided constructor, data and initialization value
 * Objects used with this function should implement `setAttributes`, or an static method named `factory`
 * @param {function} objType - A class or function to be invoked to build the object.
 * @param {object} [data] - An optional object filled with the attributes to be assigned to the newly created object.
 * @param {any} [init] - An optional value to be passed to the function when invoked with `new`
 * @param {object[]} [params=[]] - Optional array of params to be passed when calling `setAttributes` on the final object
 * @returns {object} - The resulting object
 */
function buildObj(objType, data, init, params = []) {
  return objType.factory ? objType.factory(data, init, params) : new objType(init).setAttributes(data, ...params);
};

/**
 * Check if the given char is a separator
 * @param {string} ch - A string with a single character
 * @returns {boolean}
 */
function isSeparator(ch) {
  return settings.SEPARATORS.includes(ch);
};

/**
 * Check if the given char is a word delimiter
 * @param {string} ch - A string with a single character
 * @returns {boolean}
 */
function isWordDelimiter(ch) {
  return settings.WORD_DELIMITERS.includes(ch);
}

/**
 * Converts a string in an array of objects with 'text' and 'sep' attributes, where 'text' are single words and 'sep'
 * are the word separators following each word in the sentence.
 * @example
 * stringToWords("Hello, World! That's all") returns:
 * [
 *   {text: "Hello", sep: ", "},
 *   {text: "World", sep: "! "},
 *   {text: "That", sep: "'"},
 *   {text: "s", sep: " "},
 *   {text: "all", sep: ""},
 * ]
 * @param {*} str - The text to be tokenized
 * @returns {object[]}
 */
function stringToWords(str) {
  const result = [];
  let token = { text: '', sep: '' };
  let inWord = true;
  for (let i = 0; i < str.length; i++) {
    const ch = str.charAt(i);
    const delim = isWordDelimiter(ch);
    if (inWord) {
      if (!delim)
        token.text += ch;
      else {
        inWord = false;
        token.sep = ch;
      }
    } else {
      if (delim)
        token.sep += ch;
      else {
        result.push(token);
        token = { text: ch, sep: '' };
        inWord = true;
      }
    }
  }
  result.push(token);
  return result;
}

/**
 * Rounds `v` to the nearest multiple of `n`
 * @param {number} v
 * @param {number} n - Cannot be zero!
 * @returns {number}
 */
function roundTo(v, n) {
  return Math.round(v / n) * n;
};

/**
 * Set the maximum number of decimals for a number
 * @param {any} v - The value to be converted to a fixed number of decimals. Can be anything.
 * @param {number} n=4 - the maximum number of decimals
 * @returns {any} - When `v` is a number, a number with fixed decimals is returned. Otherwise, returns `v`
 */
function fx(v, n = 4) {
  return v.toFixed ? Number(v.toFixed(n)) : v;
};

/**
 * Compares the provided answer against multiple valid options. These valid options are
 * concatenated in a string, separated by pipe chars (`|`). The comparing can be case sensitive.
 * @param {string} answer - The text to check against to
 * @param {string} check - String containing one or multiple options, separated by `|`
 * @param {boolean} [checkCase=false] - When true, the comparing will be case-sensitive
 * @param {boolean} [numeric=false] - When true, we are comparing numeric expressions
 * @returns {boolean}
 */
function compareMultipleOptions(answer, check, checkCase = false, numeric = false) {
  if (answer === null || answer.length === 0 || check === null || check.length === 0)
    return false;
  if (!checkCase && !numeric)
    answer = answer.toUpperCase();
  answer = answer.trim();

  // Check for numeric digits in answer!
  numeric = numeric && /\d/.test(answer);

  for (let token of check.split('|')) {
    if (numeric) {
      if (Number.parseFloat(answer.replace(/,/, '.')) === Number.parseFloat(token.replace(/,/, '.')))
        return true;
    }
    else if (answer === (checkCase ? token : token.toUpperCase()).trim())
      return true;
  }
  return false;
};

/**
 * Checks if the given string ends with the specified expression
 * @param {string} text - The string where to find the expression
 * @param {string} expr - The expression to search for.
 * @param {boolean} [trim] - When `true`, the `text` string will be trimmed before check
 * @returns {boolean}
 */
function endsWith(text = '', expr, trim) {
  return typeof text === 'string' && (trim ? text.trim() : text).endsWith(expr);
};

/**
 * Checks if the given string starts with the specified expression
 * @param {string} text - The string where to find the expression
 * @param {string} expr - The expression to search for.
 * @param {boolean} [trim] - When `true`, the `text` string will be trimmed before check
 * @returns {boolean}
 */
function startsWith(text = '', expr, trim) {
  return typeof text === 'string' && (trim ? text.trim() : text).indexOf(expr) === 0;
};

/**
 * Replaces all occurrences of the backslash character (`\`) by a regular slash (`/`)
 * This is useful to normalize bad path names present in some old JClic projects
 * @param {string} str - The string to be normalized
 * @returns {string}
 */
function nSlash(str) {
  return str ? str.replace(/\\/g, '/') : str;
};

/**
 * Checks if the given expression is an absolute URL
 * @param {string} exp - The expression to be checked
 * @returns {boolean}
 */
function isURL(exp) {
  return /^(filesystem:)?(https?|file|data|ftps?):/i.test(exp);
};

/**
 * Gets the base path of the given file path (absolute or full URL). This base path always ends
 * with `/`, meaning it can be concatenated with relative paths without adding a separator.
 * @param {string} path - The full path to be parsed
 * @returns {string}
 */
function getBasePath(path) {
  const p = path.lastIndexOf('/');
  return p >= 0 ? path.substring(0, p + 1) : '';
};

/**
 * Gets the full path of `file` relative to `basePath`
 * @param {string} file - The file name
 * @param {string} [path] - The base path
 * @returns {string}
 */
function getRelativePath(file, path) {
  return (!path || path === '' || file.indexOf(path) !== 0) ? file : file.substr(path.length);
};

/**
 * Gets the complete path of a relative or absolute URL, using the provided `basePath`
 * @param {string} basePath - The base URL
 * @param {string} path - The filename
 * @returns {string}
 */
function getPath(basePath, path) {
  return isURL(path) ? path : basePath + path;
};

/**
 * Gets a promise with the complete path of a relative or absolute URL, using the provided `basePath`
 * @param {string} basePath - The base URL
 * @param {string} path - The filename
 * @param {external:JSZip} [zip] - An optional {@link external:JSZip} object where to look
 * for the file
 * @returns {external:Promise}
 */
function getPathPromise(basePath, path, zip) {
  if (zip) {
    const fName = getRelativePath(basePath + path, zip.zipBasePath);
    if (zip.files[fName]) {
      return new Promise((resolve, reject) => {
        zip.file(fName).async('base64').then(data => {
          const ext = path.toLowerCase().split('.').pop();
          const mime = settings.MIME_TYPES[ext] || 'application/octet-stream';
          resolve(`data:${mime};base64,${data}`);
        }).catch(reject);
      });
    }
  }
  return Promise.resolve(getPath(basePath, path));
};

/**
 * Utility object that provides several methods to build simple and complex DOM objects
 * @type {object}
 */
const $HTML = {
  doubleCell: (a, b) => external_jquery_default()('<tr/>').append(external_jquery_default()('<td/>').html(a)).append(external_jquery_default()('<td/>').html(b)),
  p: txt => external_jquery_default()('<p/>').html(txt),
  td: (txt, className) => external_jquery_default()('<td/>', className ? { class: className } : null).html(txt),
  th: (txt, className) => external_jquery_default()('<th/>', className ? { class: className } : null).html(txt),
};

/**
 * Replaces `width`, `height` and `fill` attributes of a simple SVG image
 * with the provided values
 * @param {string} svg - The SVG image as XML string
 * @param {string} [width] - Optional setting for "width" property
 * @param {string} [height] - Optional setting for "height" property
 * @param {string} [fill] - Optional setting for "fill" property
 * @returns {string} - The resulting svg code
 */
function getSvg(svg, width, height, fill) {
  if (width)
    svg = svg.replace(/width=\"\d*\"/, `width="${width}"`);
  if (height)
    svg = svg.replace(/height=\"\d*\"/, `height="${height}"`);
  if (fill)
    svg = svg.replace(/fill=\"[#A-Za-z0-9]*\"/, `fill="${fill}"`);
  return svg;
};

/**
 * Encodes a svg expression into a {@link https://developer.mozilla.org/en-US/docs/Web/HTTP/data_URIs|data URI}
 * suitable for the `src` property of `img` elements, optionally changing its original size and fill values.
 * @param {string} svg - The SVG image as XML string
 * @param {string} [width] - Optional setting for "width" property
 * @param {string} [height] - Optional setting for "height" property
 * @param {string} [fill] - Optional setting for "fill" property
 * @returns {string} - The resulting Data URI
 */
function svgToURI(svg, width, height, fill) {
  return 'data:image/svg+xml;base64,' + window.btoa(getSvg(svg, width, height, fill));
};

/**
 * Converts the given expression into a valid value for CSS size values
 * @param {string|number} exp - The expression to be evaluated. Can be a numeric value, `null` or `undefined`.
 *                              Positive values are in "px" units, negative ones are "%"
 * @param {object} css - An optional Object where the resulting expression (if any) will be saved
 * @param {string} key - The key under which the result will be stored in `css`
 * @param {string} def - Default value to be used when `exp` is `null` or `undefined`
 * @returns {string} - A valid CSS value, or `null` if it can't be found. Default units are `px`
 */
function toCssSize(exp, css, key, def) {
  const result = typeof exp === 'undefined' || exp === null ? null : isNaN(exp) ? exp : exp < 0 ? `${Math.abs(exp)}%` : `${exp}px`;
  if (css && key && (result || def))
    css[key] = result !== null ? result : def;
  return result;
};

/**
 * Gets a clip of the give image data, in a URL base64 encoded format
 * @param {object} img - The binary data of the realized image, usually obtained from a {@link module:bads/MediaBagElement.MediaBagElement}
 * @param {module:AWT.Rectangle} rect - A rectangle containing the requested clip
 * @returns {string} - The URL with the image clip, as a PNG file encoded in base64
 */
function getImgClipUrl(img, rect) {
  const canvas = document.createElement('canvas');
  canvas.width = rect.dim.width;
  canvas.height = rect.dim.height;
  const ctx = canvas.getContext('2d');
  let result = '';
  try {
    ctx.drawImage(img, rect.pos.x, rect.pos.y, rect.dim.width, rect.dim.height, 0, 0, rect.dim.width, rect.dim.height);
    result = canvas.toDataURL();
  } catch (err) {
    // catch 'tainted canvases may not be exported' and other errors
    log('error', err);
  }
  return result;
};

/**
 * Finds the nearest `head` or root node of a given HTMLElement, useful to place `<style/>` elements when
 * the main component of JClic is behind a shadow-root.
 * This method will be replaced by a call to [Node.getRootNode()](https://developer.mozilla.org/en-US/docs/Web/API/Node/getRootNode)
 * when fully supported by all major browsers.
 * @param {external:HTMLElement} [el] - The element from which to start the search
 * @returns {external:HTMLElement}
 */
function getRootHead(el) {
  if (el) {
    // Skip HTMLElements
    while (el.parentElement)
      el = el.parentElement;
    // Get the parent node of the last HTMLElement
    if (el instanceof HTMLElement)
      el = el.parentNode || el;
    // If the root node has a `head`, take it
    el = el['head'] || el;
  }
  return el || document.head;
};

/**
 * Appends a stylesheet element to the `head` or root node nearest to the given `HTMLElement`.
 * @param {string} css - The content of the stylesheet
 * @param {module:JClicPlayer.JClicPlayer} [ps] - An optional `PlayStation` (currently a {@link module:JClicPlayer.JClicPlayer JClicPlayer}) used as a base to find the root node
 * @returns {external:HTMLStyleElement} - The appended style element
 */
function appendStyleAtHead(css, ps) {
  const root = getRootHead(ps && ps.$topDiv ? ps.$topDiv[0] : null);
  const style = document.createElement('style');
  style.type = 'text/css';
  style.appendChild(document.createTextNode(css));
  return root.appendChild(style);
};

/**
 * Traverses all the attributes defined in an Element, calling a function with its name and value as a parameters
 * @param {external:NamedNodeMap} attributes - The [Element.attributes](https://developer.mozilla.org/en-US/docs/Web/API/Element/attributes)
 * object to be traversed
 * @param {function} callback - The function to be called for each [Attr](https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap)
 * object. It should take two parametres: `name` and `value`
 */
function attrForEach(attributes, callback) {
  for (let i = 0; i < attributes.length; i++)
    callback(attributes[i].name, attributes[i].value);
};

/**
 * Recursive traversal of all nodes of the given object looking for children having the `childName` attribute
 * WARNING: Don't call this method on objects with circular dependencies!
 * @param {object} obj       - The object to be analized
 * @param {string} childName - Name of the attribute to search for
 * @returns {object[]}       - Array of children having the searched attribute
 */
function findParentsWithChild(obj, childName, _result = []) {
  if (obj[childName])
    _result.push(obj);
  else
    Object.values(obj).forEach(val => {
      if (typeof val === 'object')
        findParentsWithChild(val, childName, _result);
    });
  return _result;
};

//
// Functions useful to deal with caret position in `contentEditable` DOM elements
//
/**
 * Gets the caret position within the given element. Thanks to
 * {@link http://stackoverflow.com/users/96100/tim-down|Tim Down} answers in:
 * {@link http://stackoverflow.com/questions/4811822/get-a-ranges-start-and-end-offsets-relative-to-its-parent-container}
 * and {@link http://stackoverflow.com/questions/6240139/highlight-text-range-using-javascript/6242538}
 * @param {object} element - A DOM element
 * @returns {number}
 */
function getCaretCharacterOffsetWithin(element) {
  let caretOffset = 0;
  const doc = element.ownerDocument || element.document;
  const win = doc.defaultView || doc.parentWindow;
  let sel;
  if (typeof win.getSelection !== "undefined") {
    sel = win.getSelection();
    if (sel.rangeCount > 0) {
      const range = win.getSelection().getRangeAt(0);
      const preCaretRange = range.cloneRange();
      preCaretRange.selectNodeContents(element);
      preCaretRange.setEnd(range.endContainer, range.endOffset);
      caretOffset = preCaretRange.toString().length;
    }
  } else if ((sel = doc.selection) && sel.type !== "Control") {
    const textRange = sel.createRange();
    const preCaretTextRange = doc.body.createTextRange();
    preCaretTextRange.moveToElementText(element);
    preCaretTextRange.setEndPoint("EndToEnd", textRange);
    caretOffset = preCaretTextRange.text.length;
  }
  return caretOffset;
};

/**
 * Utility function called by {@link module:Utils.getCaretCharacterOffsetWithin}
 * @param {object} node - A text node
 * @returns {object[]}
 */
function getTextNodesIn(node) {
  const textNodes = [];
  if (node.nodeType === 3) {
    textNodes.push(node);
  } else {
    const children = node.childNodes;
    for (let i = 0, len = children.length; i < len; ++i) {
      textNodes.push.apply(textNodes, getTextNodesIn(children[i]));
    }
  }
  return textNodes;
};

/**
 * Sets the selection range (or the cursor position, when `start` and `end` are the same) to a
 * specific position inside a DOM element.
 * @param {object} el - The DOM element where to set the cursor
 * @param {number} start - The start position of the selection (or cursor position)
 * @param {number} end - The end position of the selection. When null or identical to `start`,
 * indicates a cursor position.
 */
function setSelectionRange(el, start, end) {
  if (isNullOrUndef(end))
    end = start;
  if (document.createRange && window.getSelection) {
    const range = document.createRange();
    range.selectNodeContents(el);
    const textNodes = getTextNodesIn(el);
    let foundStart = false;
    let charCount = 0, endCharCount, textNode;

    for (let i = 0; i < textNodes.length; i++) {
      textNode = textNodes[i];
      endCharCount = charCount + textNode.length;
      if (!foundStart && start >= charCount &&
        (start < endCharCount ||
          start === endCharCount && i + 1 <= textNodes.length)) {
        range.setStart(textNode, start - charCount);
        foundStart = true;
      }
      if (foundStart && end <= endCharCount) {
        range.setEnd(textNode, end - charCount);
        break;
      }
      charCount = endCharCount;
    }
    const sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(range);
  } else if (document.selection && document.body.createTextRange) {
    const textRange = document.body.createTextRange();
    textRange.moveToElementText(el);
    textRange.collapse(true);
    textRange.moveEnd('character', end);
    textRange.moveStart('character', start);
    textRange.select();
  }
};

/**
 * Performs multiple replacements on the provided string
 * See: https://stackoverflow.com/questions/2501435/replacing-multiple-patterns-in-a-block-of-data
 * @param {Object[]} replacements - Array of pairs formed by an "expression" (regexp or string) and a "value" (string) to replace the fragments found
 * @param {String} str - The string to be checked for replacements
 * @returns {String} - The original string with the fragments found already replaced
 */
function mReplace(replacements, str) {
  return replacements.reduce((result, [exp, replacement]) => result.replace(exp, replacement), str);
};

/**
 * Global constants
 * @const
 */
const settings = {
  // JClic.js Version
  VERSION: GlobalData.version,
  // Check if we are running on NodeJS with JSDOM
  NODEJS: window.name === 'nodejs',
  // layout constants
  AB: 0, BA: 1, AUB: 2, BUA: 3,
  LAYOUT_NAMES: ['AB', 'BA', 'AUB', 'BUA'],
  DEFAULT_WIDTH: 400,
  DEFAULT_HEIGHT: 300,
  MINIMUM_WIDTH: 40,
  MINIMUM_HEIGHT: 40,
  DEFAULT_NAME: '---',
  DEFAULT_MARGIN: 8,
  DEFAULT_SHUFFLES: 31,
  DEFAULT_GRID_ELEMENT_SIZE: 20,
  MIN_CELL_SIZE: 10,
  //DEFAULT_BG_COLOR: '#D3D3D3', // LightGray
  DEFAULT_BG_COLOR: '#C0C0C0', // LightGray
  ACTIONS: {
    ACTION_MATCH: 'MATCH', ACTION_PLACE: 'PLACE',
    ACTION_WRITE: 'WRITE', ACTION_SELECT: 'SELECT', ACTION_HELP: 'HELP'
  },
  PREVIOUS: 0, MAIN: 1, END: 2, END_ERROR: 3, NUM_MSG: 4,
  MSG_TYPE: ['previous', 'initial', 'final', 'finalError'],
  RANDOM_CHARS: "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
  NUM_COUNTERS: 3,
  MAX_RECORD_LENGTH: 180,
  // BoxBase defaults
  BoxBase: {
    REDUCE_FONT_STEP: 1.0,
    MIN_FONT_SIZE: 8,
    STROKE: 1,
    AC_MARGIN: 6,
    //BACK_COLOR: 'lightgray',
    BACK_COLOR: '#C0C0C0',
    TEXT_COLOR: 'black',
    SHADOW_COLOR: 'gray',
    INACTIVE_COLOR: 'gray',
    ALTERNATIVE_COLOR: 'gray',
    BORDER_COLOR: 'black',
    BORDER_STROKE_WIDTH: 0.75,
    MARKER_STROKE_WIDTH: 2.75
  },
  FILE_TYPES: {
    image: 'gif,jpg,png,jpeg,bmp,ico,svg',
    audio: 'wav,mp3,ogg,oga,au,aiff,flac',
    video: 'avi,mov,mpeg,mp4,ogv,m4v,webm',
    font: 'ttf,otf,eot,woff,woff2',
    midi: 'mid,midi',
    anim: 'swf',
    // Used in custom skins
    xml: 'xml'
  },
  MIME_TYPES: {
    xml: 'text/xml',
    gif: 'image/gif',
    jpg: 'image/jpeg',
    jpeg: 'image/jpeg',
    png: 'image/png',
    bmp: 'image/bmp',
    svg: 'image/svg+xml',
    ico: 'image/x-icon',
    wav: 'audio/wav',
    mp3: 'audio/mpeg',
    mp4: 'video/mp4',
    m4v: 'video/mp4',
    ogg: 'audio/ogg',
    oga: 'audio/ogg',
    ogv: 'video/ogg',
    webm: 'video/webm',
    au: 'audio/basic',
    aiff: 'audio/x-aiff',
    flac: 'audio/flac',
    avi: 'video/avi',
    mov: 'video/quicktime',
    mpeg: 'video/mpeg',
    ttf: 'application/font-sfnt',
    otf: 'application/font-sfnt',
    eot: ' application/vnd.ms-fontobject',
    woff: 'application/font-woff',
    woff2: 'application/font-woff2',
    swf: 'application/x-shockwave-flash',
    mid: 'audio/midi',
    midi: 'audio/midi'
  },
  // Global settings susceptible to be modified
  COMPRESS_IMAGES: true,
  // Keyboard key codes
  VK: {
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40
  },
  // Flag to indicate that we are running on a touch device
  TOUCH_DEVICE: false,
  // Amount of time (in milliseconds) to wait before a media resource is loaded
  LOAD_TIMEOUT: 10000,
  // Number of points to be calculated as polygon vertexs when simplifying bezier curves
  BEZIER_POINTS: 4,
  // Check if canvas accessibility features are enabled
  // See: http://codepen.io/francesc/pen/amwvRp
  // UPDATED May 2020: Detection removed since Canvas HitRegions have been deprecated
  // See: https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Hit_regions_and_accessibility
  //
  // CANVAS_HITREGIONS: typeof CanvasRenderingContext2D !== 'undefined' && typeof CanvasRenderingContext2D.prototype.addHitRegion === 'function',
  // CANVAS_HITREGIONS_FOCUS: typeof CanvasRenderingContext2D !== 'undefined' && typeof CanvasRenderingContext2D.prototype.drawFocusIfNeeded === 'function',
  //
  CANVAS_DRAW_FOCUS: typeof window.CanvasRenderingContext2D !== 'undefined' && typeof window.CanvasRenderingContext2D.prototype.drawFocusIfNeeded === 'function',
  // See: https://emptycharacter.com/
  // See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Character_Classes
  WHITESPACES: '  \f\n\r\t\v\u00a0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u2028\u2029\u202f\u205f\u3000\ufeff',
};
settings.SEPARATORS = `${settings.WHITESPACES}.,;-|`;
settings.WORD_DELIMITERS = `${settings.SEPARATORS}…_<>"“”«»'\xB4\x60\u2018\u2019\u2022~+\u2013\u2014\u2015=%¿?¡!:/\\()[]{}$£€`;

/**
 * Miscellaneous utility functions and constants
 */
const Utils = {
  pkg,
  settings,
  getMsg,
  LOG_LEVELS,
  LOG_PRINT_LABELS,
  LOG_OPTIONS,
  init,
  setLogLevel,
  log,
  getBoolean,
  getVal,
  getNumber,
  getPercent,
  zp,
  getHMStime,
  getDateTime,
  parseOldDate,
  cleanOldLanguageTag,
  FALSE,
  TRUE,
  DEFAULT,
  getTriState,
  fillString,
  isNullOrUndef,
  isEquivalent,
  getXmlText,
  parseXmlNode,
  getXmlNodeText,
  reduceTextsToStrings,
  cssToString,
  checkColor,
  colorHasTransparency,
  cloneObject,
  normalizeObject,
  getAttr,
  getValue,
  isEmpty,
  setAttr,
  buildObj,
  isSeparator,
  isWordDelimiter,
  stringToWords,
  roundTo,
  fx,
  compareMultipleOptions,
  endsWith,
  startsWith,
  nSlash,
  isURL,
  getBasePath,
  getRelativePath,
  getPath,
  getPathPromise,
  $HTML,
  getSvg,
  svgToURI,
  toCssSize,
  getImgClipUrl,
  getRootHead,
  appendStyleAtHead,
  attrForEach,
  findParentsWithChild,
  getCaretCharacterOffsetWithin,
  getTextNodesIn,
  setSelectionRange
};

/* harmony default export */ const src_Utils = (Utils);

;// CONCATENATED MODULE: ./src/AWT.js
/**
 *  File    : AWT.js
 *  Created : 12/04/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */

/* global console, window */





/**
 * Font contains properties and provides methods to manage fonts
 */
class Font {
  /**
   * Font constructor
   * @param {string} [family='Arial']
   * @param {number} [size=17]
   * @param {number} [bold=0]
   * @param {number} [italic=0]
   * @param {string} [variant='']
   */
  constructor(family, size, bold, italic, variant) {
    if (family)
      this.family = family;
    if (typeof size === 'number')
      this.size = size;
    if (bold)
      this.bold = bold;
    if (italic)
      this.italic = italic;
    if (variant)
      this.variant = variant;
    this._metrics = { ascent: -1, descent: -1, height: -1 };
  }

  /**
   * Finds the XML elements with typeface specifications, checks its value against the font
   * substitution list, replacing the `family` attribute and loading the alternative font when needed.
   * @param {external:jQuery} $tree - The xml element to be processed
   * @param {object} [options] - Optional param that can contain a `fontSubstitutions` attribute with
   * a substition table to be added to {@link module:AWT.Font.SUBSTITUTIONS SUBSTITUTIONS}
   */
  static checkTree($tree, options) {
    let substitutions = Font.SUBSTITUTIONS;
    // Load own fonts and remove it from the substitution table
    if (options && options.ownFonts) {
      options.ownFonts.forEach(name => {
        // Check WebFont as a workaround to avoid problems with a different version of `webfontloader` in agora.xtec.cat
        if (Font.ALREADY_LOADED_FONTS.indexOf(name) < 0 && (external_webfontloader_default()) && (external_webfontloader_default()).load) {
          external_webfontloader_default().load({ custom: { families: [name] } });
          Font.ALREADY_LOADED_FONTS.push(name);
          delete substitutions[name.trim().toLowerCase()];
        }
      });
    }

    // Add custom font substitutions
    if (options && options.fontSubstitutions)
      //substitutions = Object.assign({}, substitutions, options.fontSubstitutions)
      substitutions = external_jquery_default().extend(Object.create(substitutions), options.fontSubstitutions);

    if ($tree.jquery)
      $tree.find('style[family],font[family]').each((_n, style) => {
        const $style = external_jquery_default()(style),
          name = $style.attr('family').trim().toLowerCase();
        if (name in substitutions) {
          const newName = substitutions[name];
          if (newName !== '') {
            Font.loadGoogleFont(newName);
            $style.attr('family', newName);
          }
        }
      });
    else {
      findParentsWithChild($tree, 'family').forEach(parent => {
        if (typeof parent.family === 'string') {
          const name = parent.family;
          if (Font.GOOGLEFONTS.includes(name))
            Font.loadGoogleFont(name);
          else {
            const newName = substitutions[name.trim().toLowerCase()];
            if (newName) {
              Font.loadGoogleFont(newName);
              parent.family = newName;
            }
          }
        }
      });
    }
  }

  /**
   * Try to load a specific font from [http://www.google.com/fonts]
   * @param {string} name - The font family name
   */
  // Check WebFont as a workaround to avoid problems with a different version of `webfontloader` in agora.xtec.cat
  static loadGoogleFont(name) {
    if (name && !Font.ALREADY_LOADED_FONTS.includes(name) && (external_webfontloader_default()) && (external_webfontloader_default()).load) {
      external_webfontloader_default().load({ google: { families: [name] } });
      Font.ALREADY_LOADED_FONTS.push(name);
    }
  }

  /**
   * Try to load a set of Google fonts
   * @param {string[]} fonts - An array of font names
   */
  static loadGoogleFonts(fonts) {
    if (fonts && fonts.forEach)
      fonts.forEach(name => Font.loadGoogleFont(name));
  }

  /**
   * Reads the properties of this Font from an XML element
   * @param {external:jQuery} $xml - The xml element to be parsed
   * @returns {module:AWT.Font}
   */
  setProperties($xml) {
    if ($xml.attr('family'))
      this.family = $xml.attr('family');
    if ($xml.attr('size'))
      this.size = Number($xml.attr('size'));
    if ($xml.attr('bold'))
      this.bold = getBoolean($xml.attr('bold'));
    if ($xml.attr('italic'))
      this.italic = getBoolean($xml.attr('italic'));
    if ($xml.attr('variant'))
      this.variant = $xml.attr('variant');
    return this;
  }

  /**
   * Gets a object with the basic attributes needed to rebuild this instance excluding functions,
   * parent references, constants and also attributes retaining the default value.
   * The resulting object is commonly usued to serialize elements in JSON format.
   * @returns {object} - The resulting object, with minimal attrributes
   */
  getAttributes() {
    return getAttr(this, ['family|Arial', 'size|17', 'bold|0', 'italic|0', 'variant']);
  }

  /**
   * Reads the properties of this Font from a data object
   * @param {object} data - The data object to be parsed
   * @returns {module:AWT.Font}
   */
  setAttributes(data) {
    return setAttr(this, data, ['family', 'size', 'bold', 'italic', 'variant']);
  }

  /**
   * Allows to change the `size` member, recalculating the vertical metrics.
   * @param {number} size - The new size to set
   * @returns {module:AWT.Font}
   */
  setSize(size) {
    const currentSize = this.size;
    this.size = size;
    if (currentSize !== size)
      this._metrics.height = -1;
    return this;
  }

  /**
   * Increases or decreases the current font size by the specified amount
   * @param {number} amount - The amount to increase or decrease current size
   * @returns {module:AWT.Font}
   */
  zoom(amount) {
    return this.setSize(this.size + amount);
  }

  /**
   * Calculates the font metrics
   * @returns {Object} - The font metrics
   */
  getMetrics() {
    if (this._metrics.height < 0) {
      // Look for an equivalent font already calculated
      const font = Font.ALREADY_CALCULATED_FONTS.find(font => font.equals(this));
      if (font)
        Object.assign(this._metrics, font._metrics);

      if (this._metrics.height < 0) {
        this._calcHeight();
        if (this._metrics.height > 0)
          Font.ALREADY_CALCULATED_FONTS.push(this);
      }
    }
    return this._metrics;
  }

  /**
   * Calculates the font metrics and returns its height
   * @returns {number} - The font height
   */
  getHeight() {
    return this.getMetrics().height;
  }

  /**
   * Translates the Font properties into CSS statements
   * @param {object} css - The object where to add CSS properties. When null or undefined, a new
   * object will be created and returned.
   * @returns {object} - A set of CSS property-values pairs, ready to be used by JQuery
   * [.css(properties)](http://api.jquery.com/css/#css-properties).
   */
  toCss(css) {
    if (!css)
      css = {};
    css['font-family'] = this.family;
    css['font-size'] = `${this.size}px`;
    if (this.hasOwnProperty('bold'))
      css['font-weight'] = this.bold ? 'bold' : 'normal';
    if (this.hasOwnProperty('italic'))
      css['font-style'] = this.italic ? 'italic' : 'normal';
    if (this.hasOwnProperty('variant'))
      css['font-variant'] = this.variant;
    return css;
  }

  /**
   * Gets the codification of this font in a single string, suitable to be used in a `font`
   * CSS attribute.
   * @returns {string} - A string with all the CSS font properties concatenated
   */
  cssFont() {
    return `${this.italic ? 'italic ' : 'normal'} ${this.variant === '' ? 'normal' : this.variant} ${this.bold ? 'bold ' : 'normal'} ${this.size}px ${this.family}`;
  }

  /**
   * The {@link https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics TextMetrics} object used
   * by {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D CanvasRenderingContext2D}
   * does not provide a `heigth` value for rendered text.
   * This {@link http://stackoverflow.com/questions/1134586/how-can-you-find-the-height-of-text-on-an-html-canvas stackoverflow question}
   * has an excellent response by Daniel Earwicker explaining how to measure the
   * vertical dimension of rendered text using a `span` element.
   * The code has been slighty adapted to deal with Font objects.
   *
   * _Warning_: Do not call this method direcly. Use {@link module:AWT.Font#getHeight getHeight()} or {@link module:AWT.Font#getMetrics getMetrics()} instead
   *
   * @returns {module:AWT.Font}
   */
  _calcHeight() {
    const
      $text = external_jquery_default()('<span/>').html('Hg').css(this.toCss()),
      $block = external_jquery_default()('<div/>').css({ display: 'inline-block', width: '1px', height: '0px' }),
      $div = external_jquery_default()('<div/>').append($text, $block);

    external_jquery_default()('body').append($div);
    try {
      $block.css({ verticalAlign: 'baseline' });
      this._metrics.ascent = $block.offset().top - $text.offset().top;
      $block.css({ verticalAlign: 'bottom' });
      this._metrics.height = $block.offset().top - $text.offset().top;
      this._metrics.descent = this._metrics.height - this._metrics.ascent;
    } finally {
      $div.remove();
    }
    return this;
  }

  /**
   * Checks if two Font objects are equivalent
   * @param {module:AWT.Font} font - The Font object to compare against this one
   * @returns {boolean} - `true` if both objects are equivalent, `false` otherwise
   */
  equals(font) {
    return this.family === font.family &&
      this.size === font.size &&
      this.bold === font.bold &&
      this.italic === font.italic &&
      this.variant === font.variant;
  }
}


/**
 * Array of font objects with already calculated heights */
Font.ALREADY_CALCULATED_FONTS = [];

/**
 * Array of font names already loaded from Google Fonts, or generic names provided by browsers by default
 * See: https://developer.mozilla.org/en-US/docs/Web/CSS/font-family */
Font.ALREADY_LOADED_FONTS = ['serif', 'sans-serif', 'monospace', 'cursive', 'fantasy'];

/**
 * Google Fonts equivalent for special fonts used in some JClic projects.
 * More substitutions can be added to the list for specific projects indicating a
 * `fontSubstitutions` object in the `data-options` attribute of the HTML `div` element
 * containing the player.
 * For example:
 * `<div class ="JClic" data-project="demo.jclic" data-options='{"fontSubstitutions":{"arial":"Arimo"}}'/>`
 */
Font.SUBSTITUTIONS = {
  // Lowercase versions of JDK Logical Fonts (see: https://docs.oracle.com/javase/tutorial/2d/text/fonts.html)
  'dialog': 'sans-serif',
  'dialoginput': 'sans-serif',
  'monospaced': 'monospace',
  //'serif': 'serif',
  'sansserif': 'sans-serif',
  // Other fonts commonly used in JClic activities, mapped to similar Google Fonts
  'abc': 'Kalam',
  'a.c.m.e. secret agent': 'Permanent Marker',
  'comic sans ms': 'Patrick Hand',
  'impact': 'Oswald',
  'massallera': 'Vibur',
  'memima': 'Vibur',
  'memima_n1': 'Vibur',
  'memima_n2': 'Vibur',
  'memimas-regularalternate': 'Vibur',
  'palmemim': 'Vibur',
  'zurichcalligraphic': 'Felipa'
};
/**
 * Google Fonts currently used in substitutions
 */
Font.GOOGLEFONTS = [
  'Kalam', 'Permanent Marker', 'Patrick Hand', 'Oswald', 'Vibur', 'Felipa',
];

Object.assign(Font.prototype, {
  /**
   * The `font-family` property
   * @name module:AWT.Font#family
   * @type {string} */
  family: 'Arial',
  /**
   * The font size
   * __Warning__: Do not change `size` directly. Use {@link module:AWT.Font#setSize setSize()} instead.
   * @name module:AWT.Font#size
   * @type {number} */
  size: 17,
  /**
   * The font _bold_ value
   * @name module:AWT.Font#bold
   * @type {number} */
  bold: 0,
  /**
   * The font _italic_ value
   * @name module:AWT.Font#italic
   * @type {number} */
  italic: 0,
  /**
   * The font _variant_ value
   * @name module:AWT.Font#variant
   * @type {string}*/
  variant: '',
  /**
   * The font *_metrics* property contains the values for `ascent`, `descent` and `height`
   * attributes. Vertical font metrics are calculated in
   * {@link module:AWT.Font#_calcHeight|_calcHeight()} as needed.
   * @name module:AWT.Font#_metrics
   * @private
   * @type {{ascent: number, descent: number, height: number}} */
  _metrics: { ascent: -1, descent: -1, height: -1 },
});

/**
 * Contains parameters and methods to draw complex color gradients
 */
class Gradient {
  /**
   * Gradient constructor
   * @param {string} c1 - The initial color, in any CSS-valid form.
   * @param {string} c2 - The final color, in any CSS-valid form.
   * @param {number} [angle=0] - The inclination of the gradient relative to the horizontal line.
   * @param {number} [cycles=1] - The number of times the gradient will be repeated.
   */
  constructor(c1, c2, angle, cycles) {
    if (c1)
      this.c1 = c1;
    if (c2)
      this.c2 = c2;
    if (typeof angle === 'number')
      this.angle = angle % 360;
    if (typeof cycles === 'number')
      this.cycles = cycles;
  }

  /**
   * Reads the properties of this Gradient from an XML element
   * @param {external:jQuery} $xml - The xml element to be parsed
   * @returns {module:AWT.Gradient}
   */
  setProperties($xml) {
    this.c1 = checkColor($xml.attr('source'), 'black');
    this.c2 = checkColor($xml.attr('dest'), 'white');
    this.angle = Number($xml.attr('angle') || 0) % 360;
    this.cycles = Number($xml.attr('cycles') || 1);
    return this;
  }

  /**
   * Gets a object with the basic attributes needed to rebuild this instance excluding functions,
   * parent references, constants and also attributes retaining the default value.
   * The resulting object is commonly usued to serialize elements in JSON format.
   * @returns {object} - The resulting object, with minimal attrributes
   */
  getAttributes() {
    return getAttr(this, [
      'c1', 'c2', 'angle|0', 'cycles|1'
    ]);
  }

  /**
   * Reads the properties of this Gradient from a data object
   * @param {object} data - The data object to be parsed
   * @returns {module:AWT.Gradient}
   */
  setAttributes(data) {
    return setAttr(this, data, ['c1', 'c2', 'angle', 'cycles']);
  }

  /**
   * Creates a {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasGradient|CanvasGradient}
   * based on the provided context and rectangle.
   * @param {external:CanvasRenderingContext2D} ctx - The 2D rendering context
   * @param {module:AWT.Rectangle} rect - The rectangle where this gradient will be applied to
   * @returns {module:AWT.Gradient}
   */
  getGradient(ctx, rect) {
    const
      p2 = rect.getOppositeVertex(),
      gradient = ctx.createLinearGradient(rect.pos.x, rect.pos.y, p2.x, p2.y),
      step = 1 / Math.max(this.cycles, 1);
    for (let i = 0; i <= this.cycles; i++)
      gradient.addColorStop(i * step, i % 2 ? this.c1 : this.c2);
    return gradient;
  }

  /**
   * Gets the CSS 'linear-gradient' expression of this Gradient
   * @returns {string} - A string ready to be used as a value for the `linear-gradient` CSS attribute
   */
  getCss() {
    let result = `linear-gradient(${(this.angle + 90)}deg, ${this.c1}, ${this.c2}`;
    for (let i = 1; i < this.cycles; i++)
      result = `${result}, ${i % 2 > 0 ? this.c1 : this.c2}`;
    return `${result})`;
  }

  /**
   * Checks if any of the gradient colors has transparency
   * @returns {boolean} - `true` if this gradient uses colors with transparency, `false` otherwise.
   */
  hasTransparency() {
    return colorHasTransparency(this.c1) || colorHasTransparency(this.c2);
  }
}

Object.assign(Gradient.prototype, {
  /**
   * Initial color
   * @name module:AWT.Gradient#c1
   * @type {string} */
  c1: 'white',
  /**
   * Final color
   * @name module:AWT.Gradient#c2
   * @type {string} */
  c2: 'black',
  /**
   * Tilt angle
   * @name module:AWT.Gradient#angle
   * @type {number} */
  angle: 0,
  /**
   * Number of repetitions of the gradient
   * @name module:AWT.Gradient#cycles
   * @type {number} */
  cycles: 1,
});

/**
 * Contains properties used to draw lines in HTML `canvas` elements.
 * @see {@link http://bucephalus.org/text/CanvasHandbook/CanvasHandbook.html#line-caps-and-joins}
 */
class Stroke {
  /**
   * Stroke constructor
   * @param {number} [lineWidth=1] - The line width of the stroke
   * @param {string} [lineCap='butt'] - The line ending type. Possible values are: `butt`, `round`
   * and `square`.
   * @param {string} [lineJoin='miter'] - The type of drawing used when two lines join. Possible
   * values are: `round`, `bevel` and `miter`.
   * @param {number} [miterLimit=10] - The ratio between the miter length and half `lineWidth`.
   */
  constructor(lineWidth, lineCap, lineJoin, miterLimit) {
    if (typeof lineWidth === 'number')
      this.lineWidth = lineWidth;
    if (lineCap)
      this.lineCap = lineCap;
    if (lineJoin)
      this.lineJoin = lineJoin;
    if (typeof miterLimit === 'number')
      this.miterLimit = miterLimit;
  }

  /**
   * Gets a object with the basic attributes needed to rebuild this instance excluding functions,
   * parent references, constants and also attributes retaining the default value.
   * The resulting object is commonly usued to serialize elements in JSON format.
   * @returns {object} - The resulting object, with minimal attrributes
   */
  getAttributes() {
    return getAttr(this, [
      'lineWidth|1', 'lineCap|butt', 'lineJoin|miter', 'miterLimit|10',
    ]);
  }

  /**
   * Reads the properties of this Stroke from a data object
   * @param {object} data - The data object to be parsed
   * @returns {module:AWT.Stroke}
   */
  setAttributes(data) {
    return setAttr(this, data, ['lineWidth', 'lineCap', 'lineJoin', 'miterLimit']);
  }

  /**
   * Sets the properties of this stroke to a CanvasRenderingContext2D
   * @param {external:CanvasRenderingContext2D} ctx - The canvas 2D rendering context
   * @returns {external:CanvasRenderingContext2D}
   */
  setStroke(ctx) {
    ctx.lineWidth = this.lineWidth;
    ctx.lineCap = this.lineCap;
    ctx.lineJoin = this.lineJoin;
    ctx.miterLimit = this.miterLimit;
    return ctx;
  }
}

Object.assign(Stroke.prototype, {
  /**
   * The line width
   * @name module:AWT.Stroke#lineWidth
   * @type {number} */
  lineWidth: 1.0,
  /**
   * The line ending type (`butt`, `round` or `square`)
   * @name module:AWT.Stroke#lineCap
   * @type {string} */
  lineCap: 'butt',
  /**
   * The drawing used when two lines join (`round`, `bevel` or `miter`)
   * @name module:AWT.Stroke#lineJoin
   * @type {string} */
  lineJoin: 'miter',
  /**
   * Ratio between the miter length and half `lineWidth`
   * @name module:AWT.Stroke#miterLimit
   * @type {number} */
  miterLimit: 10.0,
});

/**
 * Contains the `x` andy `y` coordinates of a point, and provides some useful methods.
 */
class Point {
  /**
   * Point constructor
   * @param {number|Point} x - When `x` is an `Point` object, a clone of it will be created.
   * @param {number} [y] - Not used when `x` is an `Point`
   */
  constructor(x, y) {
    if (x instanceof Point) {
      // Special case: constructor passing another point as unique parameter
      this.x = x.x;
      this.y = x.y;
    } else {
      this.x = x || 0;
      this.y = y || 0;
    }
  }

  /**
   * Reads the properties of this Point from an XML element
   * @param {external:jQuery} $xml - The xml element to be parsed
   * @returns {module:AWT.Point}
   */
  setProperties($xml) {
    this.x = Number($xml.attr('x'));
    this.y = Number($xml.attr('y'));
    return this;
  }

  /**
   * Gets a object with the basic attributes needed to rebuild this instance excluding functions,
   * parent references, constants and also attributes retaining the default value.
   * The resulting object is commonly usued to serialize elements in JSON format.
   * @returns {object} - The resulting object, with minimal attrributes
   */
  getAttributes() {
    return getAttr(this, ['x', 'y']);
  }

  /**
   * Reads the properties of this Point from a data object
   * @param {object} data - The data object to be parsed
   * @returns {module:AWT.Point}
   */
  setAttributes(data) {
    return setAttr(this, data, ['x', 'y']);
  }

  /**
   * Moves this Point to a new position, by a specified displacement
   * @param {Point|Dimension} delta - The amount to move
   * @returns {module:AWT.Point}
   */
  moveBy(delta) {
    this.x += delta.x || delta.width || 0;
    this.y += delta.y || delta.height || 0;
    return this;
  }

  /**
   * Moves this Point to a new position
   * @param {number|Point} newPos - The new position, or a x coordinate
   * @param {number} [y] - `null` or `undefined` when `newPos` is a Point
   * @returns {module:AWT.Point}
   */
  moveTo(newPos, y) {
    if (typeof newPos === 'number') {
      this.x = newPos;
      this.y = y;
    } else {
      this.x = newPos.x;
      this.y = newPos.y;
    }
    return this;
  }

  /**
   * Multiplies the `x` and `y` coordinates by a specified `delta`
   * @param {Point|Dimension} delta - The amount to multiply by.
   * @returns {module:AWT.Point}
   */
  multBy(delta) {
    this.x *= delta.x || delta.width || 0;
    this.y *= delta.y || delta.height || 0;
    return this;
  }

  /**
   * Checks if two points are at the same place
   * @param {module:AWT.Point} p - The Point to check against to
   * @returns {boolean}
   */
  equals(p) {
    return this.x === p.x && this.y === p.y;
  }

  /**
   * Calculates the distance between two points
   * @param {module:AWT.Point} point - The Point to calculate the distance against to
   * @returns {number} - The distance between the two points.
   */
  distanceTo(point) {
    return Math.sqrt(Math.pow(this.x - point.x, 2), Math.pow(this.y - point.y, 2));
  }

  /**
   * Clones this point
   * @returns {module:AWT.Point}
   */
  clone() {
    return new Point(this);
  }
}

Object.assign(Point.prototype, {
  /**
   * @name module:AWT.Point#x
   * @type {number} */
  x: 0,
  /**
   * @name module:AWT.Point#y
   * @type {number} */
  y: 0,
});

/**
 * This class encapsulates `width` and `height` properties.
 */
class Dimension {
  /**
   * Dimension constructor
   * @param {number|Point} w - The width of this Dimension, or the upper-left vertex of a
   * virtual Rectangle
   * @param {number|Point} h - The height of this Dimension, or the bottom-right vertex of a
   * virtual Rectangle
   */
  constructor(w, h) {
    if (w instanceof Point && h instanceof Point) {
      this.width = h.x - w.x;
      this.height = h.y - w.y;
    } else {
      this.width = w || 0;
      this.height = h || 0;
    }
  }

  /**
   * Reads the properties of this Dimension from an XML element
   * @param {external:jQuery} $xml - The xml element to be parsed
   * @returns {module:AWT.Dimension}
   */
  setProperties($xml) {
    this.width = Number($xml.attr('width'));
    this.height = Number($xml.attr('height'));
    return this;
  }

  /**
   * Gets a object with the basic attributes needed to rebuild this instance excluding functions,
   * parent references, constants and also attributes retaining the default value.
   * The resulting object is commonly usued to serialize elements in JSON format.
   * @returns {object} - The resulting object, with minimal attrributes
   */
  getAttributes() {
    return getAttr(this, ['width', 'height']);
  }

  /**
   * Reads the properties of this Dimension from a data object
   * @param {object} data - The data object to be parsed
   * @returns {module:AWT.Dimension}
   */
  setAttributes(data) {
    return setAttr(this, data, ['width', 'height']);
  }

  /**
   * Check if two dimensions are equivalent
   * @param {module:AWT.Dimension} d
   * @returns {boolean}
   */
  equals(d) {
    return this.width === d.width && this.height === d.height;
  }

  /**
   * Multiplies the `w` and `h` co-ordinates by a specified `delta`
   * @param {Point|Dimension} delta
   * @returns {module:AWT.Dimension}
   */
  multBy(delta) {
    this.width *= delta.x || delta.width || 0;
    this.height *= delta.y || delta.height || 0;
    return this;
  }

  /**
   * Sets new values for width and height.
   * `width` can be a number or another `Dimension` object
   * @param {number|Dimension} width - The new width, or a full Dimension to copy it from.
   * @param {number} [height] - Not used when `width` is a Dimension
   * @returns {module:AWT.Dimension}
   */
  setDimension(width, height) {
    if (width instanceof Dimension) {
      height = width.height;
      width = width.width;
    }
    this.width = width;
    this.height = height;
    return this;
  }

  /**
   * Calculates the area of a Rectangle with this dimension
   * @returns {number} The resulting area
   */
  getSurface() {
    return this.width * this.height;
  }
}

Object.assign(Dimension.prototype, {
  /**
   * @name module:AWT.Dimension#width
   * @type {number} */
  width: 0,
  /**
   * @name module:AWT.Dimension#height
   * @type {number} */
  height: 0,
});

/**
 * Shape is a generic abstract class for rectangles, ellipses and stroke-free shapes.
 * @abstract
 */
class Shape {
  /**
   * Shape  constructor
   * @param {module:AWT.Point} pos - The top-left coordinates of this Shape
   */
  constructor(pos) {
    this.pos = pos || new Point();
  }

  /**
   * Shifts the shape a specified amount in horizontal and vertical directions
   * @param {Point|Dimension} delta - The amount to shift the Shape
   * @returns {module:AWT.Shape}
   */
  moveBy(delta) {
    this.pos.moveBy(delta);
    return this;
  }

  /**
   * Moves this shape to a new position
   * @param {module:AWT.Point} newPos - The new position of the shape
   * @returns {module:AWT.Shape}
   */
  moveTo(newPos) {
    this.pos.moveTo(newPos);
    return this;
  }

  /**
   * Gets the enclosing {@link module:AWT.Rectangle Rectangle} of this Shape.
   * @returns {module:AWT.Rectangle}
   */
  getBounds() {
    return new Rectangle(this.pos);
  }

  /**
   * Checks if two shapes are equivalent.
   * @param {module:AWT.Shape} p - The Shape to compare against
   * @returns {boolean}
   */
  equals(p) {
    return this.pos.equals(p.pos);
  }

  /**
   * Multiplies the dimension of the Shape by the specified `delta` amount.
   * @param {Point|Dimension} _delta - Object containing the X and Y ratio to be scaled.
   * @returns {module:AWT.Shape}
   */
  scaleBy(_delta) {
    // Nothing to scale in abstract shapes
    return this;
  }

  /**
   * Gets a clone of this shape moved to the `pos` component of the rectangle and scaled
   * by its `dim` value.
   * @param {module:AWT.Rectangle} rect - The rectangle to be taken as a base for moving and scaling
   * this shape.
   * @returns {module:AWT.Shape}
   */
  getShape(rect) {
    return this.clone().scaleBy(rect.dim).moveBy(rect.pos);
  }

  /**
   * Checks if the provided {@link module:AWT.Point} is inside this shape.
   * @param {module:AWT.Point} _p - The point to check
   * @returns {boolean}
   */
  contains(_p) {
    // Nothing to check in abstract shapes
    return false;
  }

  /**
   * Checks if the provided {@link module:AWT.Rectangle Rectangle} `r` intersects with this shape.
   * @param {module:AWT.Rectangle} _r
   * @returns {boolean}
   */
  intersects(_r) {
    // Nothing to check in abstract shapes
    return false;
  }

  /**
   * Fills the Shape with the current style in the provided HTML canvas context
   * @param {external:CanvasRenderingContext2D} ctx - The canvas 2D rendering context where to fill this shape.
   * @param {module:AWT.Rectangle} [dirtyRegion] - The context region to be updated. Used as clipping
   * region when drawing.
   * @returns {external:CanvasRenderingContext2D} - The provided rendering context
   */
  fill(ctx, dirtyRegion) {
    ctx.save();
    if (dirtyRegion && dirtyRegion.getSurface() > 0) {
      // Clip the dirty region
      ctx.beginPath();
      ctx.rect(dirtyRegion.pos.x, dirtyRegion.pos.y, dirtyRegion.dim.width, dirtyRegion.dim.height);
      ctx.clip();
    }
    // Prepare shape path and fill
    this.preparePath(ctx);
    ctx.fill();
    ctx.restore();
    return ctx;
  }

  /**
   * Draws this shape in the provided HTML canvas 2D rendering context.
   * @param {external:CanvasRenderingContext2D} ctx - The canvas 2D rendering context where to draw the shape.
   * @returns {external:CanvasRenderingContext2D} - The provided rendering context
   */
  stroke(ctx) {
    this.preparePath(ctx);
    ctx.stroke();
    return ctx;
  }

  /**
   * Prepares an HTML canvas 2D rendering context with a path that can be used to stroke a line,
   * to fill a surface or to define a clipping region.
   * @param {external:CanvasRenderingContext2D} ctx
   * @returns {external:CanvasRenderingContext2D} - The provided rendering context
   */
  preparePath(ctx) {
    // Nothing to do in abstract shapes
    return ctx;
  }

  /**
   * Creates a clipping region on the specified HTML canvas 2D rendering context
   * @param {external:CanvasRenderingContext2D} ctx - The rendering context
   * @param {string} [fillRule='nonzero'] - Can be 'nonzero' (default when not set) or 'evenodd'
   * @returns {external:CanvasRenderingContext2D} - The provided rendering context
   */
  clip(ctx, fillRule) {
    this.preparePath(ctx);
    ctx.clip(fillRule || 'nonzero');
    return ctx;
  }

  /**
   * Shorthand method for determining if a Shape is an {@link module:AWT.Rectangle Rectangle}
   * @returns {boolean}
   */
  isRect() {
    return false;
  }

  /**
   * Overwrites the original 'Object.toString' method with a more descriptive text
   * @returns {string}
   */
  toString() {
    return `Shape enclosed in ${this.getBounds().getCoords()}`;
  }

  /**
   * Reads the properties of this Shape from a data object
   * @param {object} data - The data object to be parsed
   * @returns {module:AWT.Shape}
   */
  setAttributes(data) {
    return Shape.buildShape(data);
    /*
    return setAttr(this, data, [
      'type',
      { key: 'pos', fn: Point },
    ]);
    */
  }

  /**
   * Builds a shape based on the provided `data` object.
   * Data should contain a 'type' member, specifying the type of shape requested ('rect', 'ellipse', 'rectangle' or 'path')
   * @param {object} data - Specific data for this shape
   * @returns {module:AWT.Shape}
   */
  static buildShape(data) {
    const shapeType = (data.type === 'rect' && Rectangle) || (data.type === 'ellipse' && Ellipse) || (data.type === 'path' && Path) || null;
    if (!shapeType) {
      console.log('unknown shape:', data);
    } else
      return (new shapeType()).setAttributes(data);
  }
}

Object.assign(Shape.prototype, {
  /**
   * Shape type id
   * @name module:AWT.Shape#type
   * @type {string} */
  type: 'shape',
  /**
   * The current position of the shape
   * @name module:AWT.Shape#pos
   * @type {module:AWT.Point} */
  pos: new Point(),
  /**
   * The type of shape (Rectangle, ellipse, path...)
   * @name module:AWT.Shape#type
   * @type {string} */
  type: 'shape',
});

/**
 * The rectangular {@link module:AWT.Shape} accepts five different sets of parameters:
 * @example
 * // Calling Rectangle() with different sets of parameters
 * // A Point and a Dimension:
 * new Rectangle(pos, dim)
 * // Another Rectangle, to be cloned:
 * new Rectangle(rect)
 * // Two Point objects containing the coordinates of upper-left and lower-right vertexs:
 * new Rectangle(p0, p1)
 * // An array of four numbers with the coordinates of the same vertexs:
 * new Rectangle([x0, y0, x1, y1])
 * // Four single numbers, meaning the same coordinates as above:
 * new Rectangle(x0, y0, x1, y1)
 * @extends module:AWT.Shape
 */
class Rectangle extends Shape {
  /**
   * Rectangle constructor
   * @param {Point|Rectangle|number|number[]} pos
   * @param {Dimension|number} [dim]
   * @param {number} [w]
   * @param {number} [h]
   */
  constructor(pos, dim, w, h) {
    let p = pos, d = dim;
    // Special case: constructor with a Rectangle as a unique parameter
    if (pos instanceof Rectangle) {
      d = new Dimension(pos.dim.width, pos.dim.height);
      p = new Point(pos.pos.x, pos.pos.y);
    } else if (pos instanceof Point) {
      p = new Point(pos.x, pos.y);
      if (dim instanceof Dimension)
        d = new Dimension(dim.width, dim.height);
    } else if (pos instanceof Array) {
      // Assume `pos` is an array of numbers indicating: x0, y0, x1, y1
      p = new Point(pos[0], pos[1]);
      d = new Dimension(pos[2] - pos[0], pos[3] - pos[1]);
    } else if (typeof w === 'number' && typeof h === 'number') {
      // width and height passed. Treat all parameters as co-ordinates:
      p = new Point(pos, dim);
      d = new Dimension(w, h);
    }
    super(p);

    if (d instanceof Dimension)
      this.dim = d;
    else if (d instanceof Point)
      this.dim = new Dimension(d.x - this.pos.x, d.y - this.pos.y);
    else
      this.dim = new Dimension();

    this.type = 'rect';
  }

  /**
   * Gets the enclosing {@link module:AWT.Rectangle Rectangle} of this Shape.
   * @returns {module:AWT.Rectangle}
   */
  getBounds() {
    return this;
  }

  /**
   * Sets this Rectangle the position and dimension of another one
   * @param {module:AWT.Rectangle} rect
   * @returns {module:AWT.Rectangle}
   */
  setBounds(rect) {
    if (!rect)
      rect = new Rectangle();
    this.pos.x = rect.pos.x;
    this.pos.y = rect.pos.y;
    this.dim.width = rect.dim.width;
    this.dim.height = rect.dim.height;
    return this;
  }

  /**
   * Checks if two shapes are equivalent.
   * @param {module:AWT.Shape} r - The Shape to compare against
   * @returns {boolean}
   */
  equals(r) {
    return r instanceof Rectangle && this.pos.equals(r.pos) && this.dim.equals(r.dim);
  }

  /**
   * Clones this Rectangle
   * @returns {module:AWT.Rectangle}
   */
  clone() {
    return new Rectangle(this);
  }

  /**
   * Multiplies the dimension of the Shape by the specified `delta` amount.
   * @param {Point|Dimension} delta - Object containing the X and Y ratio to be scaled.
   * @returns {module:AWT.Rectangle}
   */
  scaleBy(delta) {
    this.pos.multBy(delta);
    this.dim.multBy(delta);
    return this;
  }

  /**
   * Expands the boundaries of this shape. This affects the current position and dimension.
   * @param {number} dx - The amount to grow (or decrease) in horizontal direction
   * @param {number} dy - The amount to grow (or decrease) in vertical direction
   * @returns {module:AWT.Rectangle}
   */
  grow(dx, dy) {
    this.pos.x -= dx;
    this.pos.y -= dy;
    this.dim.width += 2 * dx;
    this.dim.height += 2 * dy;
    return this;
  }

  /**
   * Gets the {@link module:AWT.Point} corresponding to the lower-right vertex of the Rectangle.
   * @returns {module:AWT.Point}
   */
  getOppositeVertex() {
    return new Point(this.pos.x + this.dim.width, this.pos.y + this.dim.height);
  }

  /**
   * Adds the boundaries of another shape to the current one
   * @param {module:AWT.Shape} shape - The {@link module:AWT.Shape} to be added
   * @returns {module:AWT.Rectangle}
   */
  add(shape) {
    const
      myP2 = this.getOppositeVertex(),
      rectP2 = shape.getBounds().getOppositeVertex();

    this.pos.moveTo(
      Math.min(this.pos.x, shape.getBounds().pos.x),
      Math.min(this.pos.y, shape.getBounds().pos.y));
    this.dim.setDimension(
      Math.max(myP2.x, rectP2.x) - this.pos.x,
      Math.max(myP2.y, rectP2.y) - this.pos.y);
    return this;
  }

  //
  // Inherits the documentation of `contains` in Shape
  contains(p) {
    const p2 = this.getOppositeVertex();
    return p.x >= this.pos.x && p.x <= p2.x && p.y >= this.pos.y && p.y <= p2.y;
  }

  //
  // Inherits the documentation of `intersects` in Shape
  intersects(r) {
    const
      p1 = this.pos, p2 = this.getOppositeVertex(),
      r1 = r.pos, r2 = r.getOppositeVertex();
    return r2.x >= p1.x && r1.x <= p2.x && r2.y >= p1.y && r1.y <= p2.y;
  }

  //
  // Inherits the documentation of `preparePath` in Shape
  preparePath(ctx) {
    ctx.beginPath();
    ctx.rect(this.pos.x, this.pos.y, this.dim.width, this.dim.height);
    return ctx;
  }

  //
  // Inherits the documentation of `getSurface` in Shape
  getSurface() {
    return this.dim.getSurface();
  }

  //
  // Inherits the documentation of `isEmpty` in Shape
  isEmpty() {
    return this.getSurface() === 0;
  }

  //
  // Inherits the documentation of `isRect` in Shape
  isRect() {
    return true;
  }

  //
  // Inherits the documentation of `toString` in Shape
  toString() {
    return `Rectangle ${this.getCoords()}`;
  }

  /**
   * Gets a string with the co-ordinates of the upper-left and lower-right vertexs of this rectangle,
   * (with values rounded to int)
   * @returns {string}
   */
  getCoords() {
    return `[${Math.round(this.pos.x)},${Math.round(this.pos.y)},${Math.round(this.pos.x + this.dim.width)},${Math.round(this.pos.y + this.dim.height)}]`;
  }

  /**
   * Gets a object with the basic attributes needed to rebuild this instance excluding functions,
   * parent references, constants and also attributes retaining the default value.
   * The resulting object is commonly usued to serialize elements in JSON format.
   * @returns {object} - The resulting object, with minimal attrributes
   */
  getAttributes() {
    return getAttr(this, ['type', 'pos', 'dim']);
  }

  /**
   * Reads the properties of this Rectangle from a data object
   * @param {object} data - The data object to be parsed
   * @returns {module:AWT.Rectangle}
   */
  setAttributes(data) {
    return setAttr(this, data, [
      'type',
      { key: 'pos', fn: Point },
      { key: 'dim', fn: Dimension },
    ]);
  }
}

Object.assign(Rectangle.prototype, {
  /**
   * Shape type id
   * @name module:AWT.Rectangle#type
   * @type {string} */
  type: 'rect',
  /**
   * The {@link module:AWT.Dimension Dimension} of the Rectangle
   * @name module:AWT.Rectangle#dim
   * @type {module:AWT.Dimension} */
  dim: new Dimension(),
});

/**
 * The Ellipse shape has the same constructor options as {@link module:AWT.Rectangle Rectangle}
 * @extends module:AWT.Rectangle
 */
class Ellipse extends Rectangle {
  /**
   * Ellipse constructor
   * @param {Point|Rectangle|number|number[]} pos
   * @param {Dimension|number} [dim]
   * @param {number} [w]
   * @param {number} [h]
   */
  constructor(pos, dim, w, h) {
    super(pos, dim, w, h);
  }

  //
  // Inherits the documentation of `preparePath` in Rectangle
  preparePath(ctx) {

    // Using the solution 'drawEllipseWithBezier' proposed by Steve Tranby in:
    // [http://jsbin.com/sosugenegi/1/edit] as a response to:
    // [http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas]
    // Thanks Steve!!

    const kappa = 0.5522848,
      ox = kappa * this.dim.width / 2, // control point offset horizontal
      oy = kappa * this.dim.height / 2, // control point offset vertical
      xe = this.pos.x + this.dim.width, // x-end
      ye = this.pos.y + this.dim.height, // y-end
      xm = this.pos.x + this.dim.width / 2, // x-middle
      ym = this.pos.y + this.dim.height / 2; // y-middle

    ctx.beginPath();
    ctx.moveTo(this.pos.x, ym);
    ctx.bezierCurveTo(this.pos.x, ym - oy, xm - ox, this.pos.y, xm, this.pos.y);
    ctx.bezierCurveTo(xm + ox, this.pos.y, xe, ym - oy, xe, ym);
    ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
    ctx.bezierCurveTo(xm - ox, ye, this.pos.x, ym + oy, this.pos.x, ym);
    ctx.closePath();
    return ctx;
  }

  //
  // Inherits the documentation of `contains` in Shape
  contains(p) {
    // First check if the point is inside the enclosing rectangle
    let result = super.contains(p);
    if (result) {
      const
        rx = this.dim.width / 2,
        ry = this.dim.height / 2,
        cx = this.pos.x + rx,
        cy = this.pos.y + ry;
      // Apply the general equation of an ellipse
      // See: [http://math.stackexchange.com/questions/76457/check-if-a-point-is-within-an-ellipse]
      // rx and ry are > 0 because we are inside the enclosing rect,
      // so don't care about division by zero
      result = Math.pow(p.x - cx, 2) / Math.pow(rx, 2) + Math.pow(p.y - cy, 2) / Math.pow(ry, 2) <= 1;
    }
    return result;
  }

  //
  // Inherits the documentation of `getSurface` in Rectangle
  getSurface() {
    return Math.PI * this.dim.width / 2 * this.dim.height / 2;
  }

  //
  // Inherits the documentation of `equals` in Rectangle
  equals(e) {
    return e instanceof Ellipse && super.equals(e);
  }

  //
  // Inherits the documentation of `clone` in Rectangle
  clone() {
    return new Ellipse(this.pos, this.dim);
  }

  //
  // Inherits the documentation of `isRect` in Rectangle
  isRect() {
    return false;
  }

  //
  // Inherits the documentation of `toString` in Shape
  toString() {
    return `Ellipse enclosed in ${this.getCoords()}`;
  }
}

Object.assign(Ellipse.prototype, {
  /**
   * Shape type id
   * @name module:AWT.Ellipse#type
   * @type {string} */
  type: 'ellipse',
});

/**
 * A `Path` is a {@link module:AWT.Shape} formed by a serie of strokes, represented by
 * {@link module:AWT.PathStroke} objects
 * @extends module:AWT.Shape
 */
class Path extends Shape {
  /**
   * Path constructor
   * @param {module:AWT.PathStroke[]} strokes - The array of {@link module:AWT.PathStroke} objects defining this Path.
   */
  constructor(strokes) {
    super();
    // Deep copy of the array of strokes
    if (strokes)
      this.setStrokes(strokes);
  }

  setStrokes(strokes) {
    this.strokes = [];
    // In [Shaper](Shaper.html) objects, strokes have `action` instead of `type` and `data` instead of `points`
    strokes.forEach(str => this.strokes.push(new PathStroke(str.type || str.action, str.points || str.data)));
    // Calculate the enclosing rectangle
    this.enclosing = new Rectangle();
    this.enclosingPoints = [];
    this.calcEnclosingRect();
    this.pos = this.enclosing.pos;
    return this;
  }

  //
  // Inherits the documentation of `clone` in Shape
  clone() {
    return new Path(this.strokes.map(str => str.clone()));
  }

  /**
   * Adds a {@link module:AWT.PathStroke} to `strokes`
   * @param {module:AWT.PathStroke} stroke
   */
  addStroke(stroke) {
    this.strokes.push(stroke);
    return this;
  }

  /**
   * Calculates the polygon and the rectangle that (approximately) encloses this shape
   * @returns {module:AWT.Rectangle}
   */
  calcEnclosingRect() {
    this.enclosingPoints = [];
    let last = new Point();
    this.strokes.forEach(str => {
      str.getEnclosingPoints(last).forEach(pt => {
        last = new Point(pt);
        this.enclosingPoints.push(last);
      });
    });

    let l = this.enclosingPoints.length;
    if (l > 1 && this.enclosingPoints[0].equals(this.enclosingPoints[l - 1])) {
      this.enclosingPoints.pop();
      l--;
    }
    const
      p0 = new Point(this.enclosingPoints[0]),
      p1 = new Point(this.enclosingPoints[0]);

    for (let k = 1; k < l; k++) {
      const p = this.enclosingPoints[k];
      // Check if `p` is at left or above `p0`
      p0.x = Math.min(p.x, p0.x);
      p0.y = Math.min(p.y, p0.y);
      // Check if `p` is at right or below `p1`
      p1.x = Math.max(p.x, p1.x);
      p1.y = Math.max(p.y, p1.y);
    }
    this.enclosing.setBounds(new Rectangle(p0, new Dimension(p0, p1)));
    return this.enclosing;
  }

  //
  // Inherits the documentation of `getBounds` in Shape
  getBounds() {
    return this.enclosing;
  }

  //
  // Inherits the documentation of `moveBy` in Shape
  moveBy(delta) {
    this.strokes.forEach(str => str.moveBy(delta));
    this.enclosingPoints.forEach(pt => pt.moveBy(delta));
    this.enclosing.moveBy(delta);
    return this;
  }

  //
  // Inherits the documentation of `moveTo` in Shape
  moveTo(newPos) {
    return this.moveBy(new Dimension(newPos.x - this.pos.x, newPos.y - this.pos.y));
  }

  //
  // Inherits the documentation of `equals` in Shape
  // TODO: Implement comparision of complex paths
  equals(_p) {
    return false;
  }

  //
  // Inherits the documentation of `scaleBy` in Shape
  scaleBy(delta) {
    this.strokes.forEach(str => str.multBy(delta));
    this.enclosingPoints.forEach(pt => pt.multBy(delta));
    this.enclosing.scaleBy(delta);
    return this;
  }

  //
  // Inherits the documentation of `contains` in Shape
  contains(p) {
    let result = this.enclosing.contains(p);
    if (result) {
      // Let's see if the point really lies inside the polygon formed by enclosingPoints
      // Using the "Ray casting algorithm" described in [https://en.wikipedia.org/wiki/Point_in_polygon]
      const N = this.enclosingPoints.length;
      let
        xinters = 0,
        counter = 0,
        p1 = this.enclosingPoints[0];

      for (let i = 1; i <= N; i++) {
        const p2 = this.enclosingPoints[i % N];
        if (p.y > Math.min(p1.y, p2.y)) {
          if (p.y <= Math.max(p1.y, p2.y)) {
            if (p.x <= Math.max(p1.x, p2.x)) {
              if (p1.y !== p2.y) {
                xinters = (p.y - p1.y) * (p2.x - p1.x) / (p2.y - p1.y) + p1.x;
                if (p1.x === p2.x || p.x <= xinters)
                  counter++;
              }
            }
          }
        }
        p1 = p2;
      }
      if (counter % 2 === 0)
        result = false;
    }
    return result;
  }

  //
  // Inherits the documentation of `intersects` in Shape
  // TODO: Implement a check algorithm based on the real shape
  intersects(r) {
    return this.enclosing.intersects(r);
  }

  //
  // Inherits the documentation of `preparePath` in Shape
  preparePath(ctx) {
    // TODO: Implement filling paths
    ctx.beginPath();
    this.strokes.forEach(str => str.stroke(ctx));
    return ctx;
  }

  /**
   * Gets a object with the basic attributes needed to rebuild this instance excluding functions,
   * parent references, constants and also attributes retaining the default value.
   * The resulting object is commonly usued to serialize elements in JSON format.
   * @returns {object} - The resulting object, with minimal attrributes
   */
  getAttributes() {
    return {
      type: this.type,
      strokes: this.strokes.map(s => s.getAttributes()).join('|'),
    };
  }

  /**
   * Reads the properties of this Path from a data object
   * @param {object} data - The data object to be parsed
   * @returns {module:AWT.Path}
   */
  setAttributes(data) {
    const strData = data.strokes.split('|');
    const strokes = strData.map(s => {
      const [type, points] = s.split(':');
      return new PathStroke(type, points ? points.split(',') : []);
    });
    return this.setStrokes(strokes);
  }
}

Object.assign(Path.prototype, {
  /**
   * Shape type id
   * @name module:AWT.Path#type
   * @type {string} */
  type: 'path',
  /**
   * The strokes forming this Path.
   * @name module:AWT.Path#strokes
   * @type {module:AWT.PathStroke[]} */
  strokes: [],
  /**
   * The {@link module:AWT.Rectangle Rectangle} enclosing this Path (when drawing, this Rectangle don't include border width!)
   * @name module:AWT.Path#enclosing
   * @type {module:AWT.Rectangle} */
  enclosing: new Rectangle(),
  /**
   * Set of vertexs of a polygon close to the real path of this shape
   * @name module:AWT.Path#enclosingPoints
   * @type {module:AWT.Point[]} */
  enclosingPoints: [],
});

/**
 * PathStroke is the basic component of {@link module:AWT.Path} objects
 */
class PathStroke {
  /**
   * PathStroke constructor
   * @param {string} type - The type of stroke. Possible values are: `M` (move to), `L` (line to),
   * `Q` (quadratic to), `B` (bezier to) and `X` (close path).
   * @param {module:AWT.Point[]} points - The array of {@link module:AWT.Point} objects used in this Stroke.
   */
  constructor(type, points) {
    this.type = type;
    // Points are deep cloned, to avoid change the original values
    if (points && points.length > 0) {
      // Check if 'points' is an array of objects of type 'Point'
      if (points[0] instanceof Point)
        this.points = points.map(p => new Point(p));
      // otherwise assume that 'points' contains just numbers
      // to be readed in pairs of x and y co-ordinates
      else {
        this.points = [];
        for (let i = 0; i < points.length; i += 2)
          this.points.push(new Point(points[i], points[i + 1]));
      }
    }
  }

  /**
   * Calculates some of the points included in a quadratic Bézier curve
   * The number of points being calculated is defined in Utils.settings.BEZIER_POINTS
   * @see {@link https://en.wikipedia.org/wiki/B%C3%A9zier_curve}
   * @see {@link https://www.jasondavies.com/animated-bezier/}
   *
   * @param {module:AWT.Point} p0 - Starting point of the quadratic Bézier curve
   * @param {module:AWT.Point} p1 - Control point
   * @param {module:AWT.Point} p2 - Ending point
   * @param {number} [numPoints] - The number of intermediate points to calculate. When not defined,
   * the value will be obtained from {@link module:Utils.settings.BEZIER_POINTS}.
   * @returns {module:AWT.Point[]} - Array with some intermediate points from the resulting Bézier curve
   */
  static getQuadraticPoints(p0, p1, p2, numPoints) {
    if (!numPoints)
      numPoints = settings.BEZIER_POINTS;
    const
      result = [],
      pxa = new Point(),
      pxb = new Point();
    for (let i = 0; i < numPoints; i++) {
      const n = (i + 1) / (numPoints + 1);
      pxa.x = p0.x + (p1.x - p0.x) * n;
      pxa.y = p0.y - (p0.y - p1.y) * n;
      pxb.x = p1.x + (p2.x - p1.x) * n;
      pxb.y = p1.y + (p2.y - p1.y) * n;
      result.push(new Point(pxa.x + (pxb.x - pxa.x) * n, pxa.y - (pxa.y - pxb.y) * n));
    }
    return result;
  }

  /**
   * Calculates some of the points included in a cubic Bézier (curve with two control points)
   * The number of points being calculated is defined in Utils.settings.BEZIER_POINTS
   * @param {module:AWT.Point} p0 - Starting point of the cubic Bézier curve
   * @param {module:AWT.Point} p1 - First control point
   * @param {module:AWT.Point} p2 - Second control point
   * @param {module:AWT.Point} p3 - Ending point
   * @param {number} [numPoints] - The number of intermediate points to calculate. When not defined,
   * the value will be obtained from {@link module:Utils.settings.BEZIER_POINTS}.
   * @returns {module:AWT.Point[]} - Array with some intermediate points from the resulting Bézier curve
   */
  static getCubicPoints(p0, p1, p2, p3, numPoints) {
    const result = [];
    if (!numPoints)
      numPoints = settings.BEZIER_POINTS;
    const pr = PathStroke.getQuadraticPoints(p0, p1, p2, numPoints);
    const pq = PathStroke.getQuadraticPoints(p1, p2, p3, numPoints);
    for (let i = 0; i < numPoints; i++) {
      const n = (i + 1) / (numPoints + 1);
      result.push(new Point(pr[i].x + (pq[i].x - pr[i].x) * n, pr[i].y - (pr[0].y - pq[0].y) * n));
    }
    return result;
  }

  /**
   * Clones this PathStroke
   * @returns {module:AWT.PathStroke}
   */
  clone() {
    // The constructors of PathStroke always make a deep copy of the `points` array
    return new PathStroke(this.type, this.points);
  }

  /**
   * Increments or decrements by `delta` the x and y coordinates of all points
   * @param {Point|Dimension} delta - The amount to add to the `x` and `y`
   * coordinates of each point.
   */
  moveBy(delta) {
    if (this.points)
      this.points.forEach(pt => pt.moveBy(delta));
    return this;
  }

  /**
   * Multiplies each point coordinates by the `x` and `y` (or `w` and `h`) values of the
   * passed {@link module:AWT.Point} or {@link module:AWT.Dimension Dimension}.
   * @param {Point|Dimension} delta
   */
  multBy(delta) {
    if (this.points)
      this.points.forEach(pt => pt.multBy(delta));
    return this;
  }

  /**
   * Draws this PathStroke in the provided HTML canvas context
   * @param {external:CanvasRenderingContext2D} ctx - The HTML canvas 2D rendering context
   */
  stroke(ctx) {
    switch (this.type) {
      case 'M':
        ctx.moveTo(this.points[0].x, this.points[0].y);
        break;
      case 'L':
        ctx.lineTo(this.points[0].x, this.points[0].y);
        break;
      case 'Q':
        ctx.quadraticCurveTo(
          this.points[0].x, this.points[0].y,
          this.points[1].x, this.points[1].y);
        break;
      case 'B':
        ctx.bezierCurveTo(
          this.points[0].x, this.points[0].y,
          this.points[1].x, this.points[1].y,
          this.points[2].x, this.points[2].y);
        break;
      case 'X':
        ctx.closePath();
        break;
    }
    return ctx;
  }

  /**
   * Gets the set of points that will be included as a vertexs on the owner's shape
   * enclosing polygon.
   * @param {module:AWT.Point} from - The starting point for this stroke
   * @returns {module:AWT.Point[]}
   */
  getEnclosingPoints(from) {
    let result = [];
    switch (this.type) {
      case 'M':
      case 'L':
        result.push(this.points[0]);
        break;
      case 'Q':
        result = PathStroke.getQuadraticPoints(from, this.points[0], this.points[1]);
        result.push(this.points[1]);
        break;
      case 'B':
        result = PathStroke.getCubicPoints(from, this.points[0], this.points[1], this.points[2]);
        result.push(this.points[2]);
        break;
    }
    return result;
  }

  /**
   * Gets a object with the basic attributes needed to rebuild this instance excluding functions,
   * parent references, constants and also attributes retaining the default value.
   * The resulting object is commonly usued to serialize elements in JSON format.
   * @returns {object} - The resulting object, with minimal attrributes
   */
  getAttributes() {
    return `${this.type}:${this.points ? this.points.map(p => `${fx(p.x)},${fx(p.y)}`).join(',') : ''}`;
  }
}

Object.assign(PathStroke.prototype, {
  /**
   * The Stroke type. Possible values are: `M` (move to), `L` (line to), `Q` (quadratic to),
   * `B` (bezier to) and `X` (close path).
   * @name module:AWT.PathStroke#type
   * @type {string} */
  type: 'X',
  /**
   * The array of points used by this stroke. Can be `null`.
   * @name module:AWT.PathStroke#points
   * @type {module:AWT.Point[]} */
  points: null,
});

/**
 * This class encapsulates actions that can be linked to buttons, menus and other active objects
 */
class Action {
  /**
   * Action constructor
   * @param {string} name - The name of this Action
   * @param {function} actionPerformed - The callback to be triggered by this Action
   */
  constructor(name, actionPerformed) {
    this.name = name;
    this.actionPerformed = actionPerformed;
    this._statusListeners = [];
  }

  /**
   * Here is where subclasses must define the callback to be triggered when
   * this Action object is called
   * @param {module:AWT.Action} _thisAction - Pointer to this Action object
   * @param {object} _event - The original action event that has originated this action
   */
  actionPerformed(_thisAction, _event) {
    return this;
  }

  /**
   * This is the method to be passed to DOM event triggers
   * @example
   * const myFunc = () => { alert('Hello!') }
   * const myAction = new Action('hello', myFunc)
   * $( "#foo" ).bind( "click", myAction.processEvent)
   * @param {object} event - The event object passed by the DOM event trigger
   */
  processEvent(event) {
    return this.actionPerformed(this, event);
  }

  /**
   * Adds a status listener
   * @param {function} listener - The callback method to be called when the status of this
   * Action changes
   */
  addStatusListener(listener) {
    this._statusListeners.push(listener);
  }

  /**
   * Removes a previously registered status listener
   * @param {function} listener - The listener to be removed
   */
  removeStatusListener(listener) {
    this._statusListeners = this._statusListeners.map(l => l !== listener);
  }

  /**
   * Enables or disables this action
   * @param {boolean} enabled
   */
  setEnabled(enabled) {
    this.enabled = enabled;
    this._statusListeners.forEach(listener => listener.call(this, this));
    return this;
  }
}

Object.assign(Action.prototype, {
  /**
   * The action's name
   * @name module:AWT.Action#name
   * @type {string} */
  name: null,
  /**
   * An optional description
   * @name module:AWT.Action#description
   * @type {string} */
  description: null,
  /**
   * Action status. `true` means enabled, `false` disabled
   * @name module:AWT.Action#enabled
   * @type {boolean} */
  enabled: false,
  /**
   * Array of callback functions to be triggered when the `enabled` flag changes
   * @name module:AWT.Action#_statusListeners
   * @private
   * @type {function[]} */
  _statusListeners: null,
});

/**
 * This class provides a timer that will launch a function at specific intervals
 */
class Timer {
  /**
   * Timer constructor
   * @param {function} actionPerformed - The function to be triggered when the timer is enabled.
   * @param {number} interval - The interval between action calls, specified in milliseconds.
   * @param {boolean} [enabled=false] - Flag to indicate if the timer will be initially enabled.
   */
  constructor(actionPerformed, interval, enabled) {
    this.actionPerformed = actionPerformed;
    this.interval = interval;
    this.setEnabled(enabled === true);
  }

  /**
   * Here is where subclasses must define the function to be performed when this timer ticks.
   * @param {module:AWT.Timer} _thisTimer
   */
  actionPerformed(_thisTimer) {
    return this;
  }

  /**
   * This is the method called by `window.setInterval`
   * @param {external:Event} _event
   */
  processTimer(_event) {
    this.ticks++;
    if (!this.repeats)
      this.stop();
    return this.actionPerformed.call(this);
  }

  /**
   * Enables or disables this timer
   * @param {boolean} enabled - Indicates if the timer should be enabled or disabled
   * @param {boolean} [retainCounter=false] - When `true`, the ticks counter will not be cleared
   */
  setEnabled(enabled, retainCounter) {
    if (!retainCounter)
      this.ticks = 0;
    if (enabled && this.timer !== null) {
      // Timer already running
      return;
    }

    if (enabled) {
      this.timer = window.setInterval(() => this.processTimer(null), this.interval);
    } else {
      if (this.timer !== null) {
        window.clearInterval(this.timer);
        this.timer = null;
      }
    }
    return this;
  }

  /**
   * Checks if this timer is running
   * @returns {boolean}
   */
  isRunning() {
    return this.timer !== null;
  }

  /**
   * Starts this timer
   * @param {boolean} [retainCounter=false] - When `true`, the ticks counter will not be cleared
   */
  start(retainCounter) {
    return this.setEnabled(true, retainCounter);
  }

  /**
   * Stops this timer
   * @param {boolean} [retainCounter=false] - When `true`, the ticks counter will not be cleared
   */
  stop(retainCounter) {
    return this.setEnabled(false, retainCounter);
  }
}

Object.assign(Timer.prototype, {
  /**
   * The timer interval, in milliseconds
   * @name module:AWT.Timer#interval
   * @type {number} */
  interval: 0,
  /**
   * The ticks counter
   * @name module:AWT.Timer#ticks
   * @type {number} */
  ticks: 0,
  /**
   * The object returned by `window.setInterval`
   * @name module:AWT.Timer#timer
   * @type {object} */
  timer: null,
  /**
   * When `true`, the timer should repeat until `stop` is called
   * @name module:AWT.Timer#repeats
   * @type {boolean} */
  repeats: true,
});

/**
 * Logic object that takes care of an "invalidated" rectangle that will be repainted
 * at the next update of a 2D object, usually an HTML Canvas.
 * Container has the same constructor options as {@link module:AWT.Rectangle Rectangle}
 * @extends module:AWT.Rectangle
 */
class Container extends Rectangle {
  /**
   * Container constructor
   * @param {Point|Rectangle|number|number[]} pos
   * @param {Dimension|number} [dim]
   * @param {number} [w]
   * @param {number} [h]
   */
  constructor(pos, dim, w, h) {
    super(pos, dim, w, h);
  }

  /**
   * Adds the provided rectangle to the invalidated area.
   * @param {module:AWT.Rectangle} rect
   */
  invalidate(rect) {
    if (rect) {
      if (this.invalidatedRect === null)
        this.invalidatedRect = rect.clone();
      else
        this.invalidatedRect.add(rect);
    } else
      this.invalidatedRect = null;
    return this;
  }

  /**
   * Updates the invalidated area
   */
  update() {
    this.updateContent(this.invalidatedRect);
    this.invalidatedRect = null;
    return this;
  }

  /**
   * Containers should implement this method to update its graphic contents. It should
   * be called from {@link module:AWT.Container#update}
   * @param {module:AWT.Shape} _dirtyRegion - Specifies the area to be updated. When `null`, it's the whole
   * Container.
   */
  updateContent(_dirtyRegion) {
    // To be overrided by subclasses. Here does nothing.
    return this;
  }
}

Object.assign(Container.prototype, {
  /**
   * The currently "invalidated" area
   * @name module:AWT.Container#invalidatedRect
   * @type {module:AWT.Rectangle} */
  invalidatedRect: null,
});

/**
 * This object contains utility clases for painting graphics and images,
 * as found in the Java [Abstract Window Toolkit](http://docs.oracle.com/javase/7/docs/api/java/awt/package-summary.html)
 *
 * The objects defined here are: {@link module:AWT.Font Font}, {@link module:AWT.Gradient Gradient}, {@link module:AWT.Stroke Stroke},
 * {@link module:AWT.Point Point}, {@link module:AWT.Dimension Dimension}, {@link module:AWT.Shape Shape}, {@link module:AWT.Rectangle Rectangle},
 * {@link module:AWT.Ellipse Ellipse}, {@link module:AWT.Path Path}, {@link module:AWT.PathStroke PathStroke}, {@link module:AWT.Action Action},
 * {@link module:AWT.Timer Timer} and {@link module:AWT.Container Container}.
 */
/* harmony default export */ const AWT = ({
  Font,
  Gradient,
  Stroke,
  Point,
  Dimension,
  Shape,
  Rectangle,
  Ellipse,
  Path,
  PathStroke,
  Action,
  Timer,
  Container
});

;// CONCATENATED MODULE: ./src/PlayerHistory.js
/**
 *  File    : PlayerHistory.js
 *  Created : 28/04/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */

/* global window */




/**
 *
 * PlayerHistory uses an array to store the list of projects and activities done by the user.
 * This class allows {@link module:JClicPlayer.JClicPlayer JClicPlayer} objects to rewind a sequence or to go back to a caller menu.
 */
class PlayerHistory {
  /**
   * PlayerHistory constructor
   * @param {module:JClicPlayer.JClicPlayer} player - The JClicPlayer associated to this history
   */
  constructor(player) {
    this.player = player;
    this.sequenceStack = [];
    if (window && window.history && player.options.browserHistory) {
      this.browserHistory = true;
      external_jquery_default()(window).on('popstate', (ev) => {
        const state = ev.originalEvent.state;
        if (state)
          this.processPopStateEvent(state);
      });
    }
  }

  /**
   *
   * Process the `state` object received in a `popstate` event
   * @param {PlayerHistory#HistoryElement} state - The previously stored state
   */
  processPopStateEvent(state) {
    log('info', 'Processing History popstate event with state:', state);
    this.processingPop = true;
    if (state.projectPath === this.player.project.path &&
      isEquivalent(state.fullZipPath, this.player.zip ? this.player.zip.fullZipPath : null))
      this.player.load(null, state.activity, null);
    else
      this.player.load(state.fullZipPath || state.projectPath, state.activity, null);
  }

  /**
   * Push a new entry on the window.History stack,
   * only when `browserHistory` is true and there is no `popstate` event in progress
   */
  pushBrowserHistory() {
    if (this.browserHistory) {

      if (this.processingPop) {
        // A 'popstate' event is currently being processed, so just clear this flag and return
        this.processingPop = false;
        return;
      }

      const
        ase = this.player.project.activitySequence,
        act = ase.currentAct,
        title = this.player.actPanel.act.name || 'No name',
        state = new this.HistoryElement(
          this.player.project.path,
          ase.getSequenceForElement(act),
          act,
          this.player.zip ? this.player.zip.fullZipPath : null);

      // Push a new history entry, or update the current one if it has no `state`
      if (!window.history.state)
        window.history.replaceState(state, title);
      else
        window.history.pushState(state, title);
    }
  }

  /**
   *
   * Counts the number of {@link module:PlayerHistory.PlayerHistory#HistoryElement HistoryElement} objects stored in
   * {@link module:PlayerHistory.PlayerHistory#sequenceStack sequenceStack}
   * @returns {number}
   */
  storedElementsCount() {
    return this.sequenceStack.length;
  }

  /**
   *
   * Removes all elements from {@link module:PlayerHistory.PlayerHistory#sequenceStack sequenceStack}
   */
  clearHistory() {
    this.sequenceStack = [0];
  }

  /**
   * Adds the current project and activity to the top of the history stack.
   */
  push() {
    if (this.player.project !== null && this.player.project.path !== null) {
      const
        ase = this.player.project.activitySequence,
        act = ase.currentAct;
      if (act >= 0) {
        if (this.sequenceStack.length > 0) {
          const last = this.sequenceStack[this.sequenceStack.length - 1];
          if (last.projectPath === this.player.project.path && last.activity === act)
            return;
        }
        this.sequenceStack.push(
          new this.HistoryElement(
            this.player.project.path,
            ase.getSequenceForElement(act),
            act,
            this.player.zip ? this.player.zip.fullZipPath : null));
      }
    }
  }

  /**
   * Retrieves the {@link module:PlayerHistory.PlayerHistory#HistoryElement HistoryElement} placed at the top of the
   * stack (if any) and instructs {@link module:JClicPlayer.JClicPlayer JClicPlayer} to load it. The obtained effect is to
   * "rewind" or "go back", usually to an activity that acts as a menu.
   * @returns {boolean}
   */
  pop() {
    // todo: check return value
    if (this.sequenceStack.length > 0) {
      const e = this.sequenceStack.pop();
      if (e.projectPath === this.player.project.path &&
        isEquivalent(e.fullZipPath, this.player.zip ? this.player.zip.fullZipPath : null))
        this.player.load(null, e.activity, null);
      else
        if (this.testMode && e.projectPath !== null && e.projectPath.length > 0)
          log('info', `At this point, a jump to "${e.projectPath}" should be performed.`);
        else
          this.player.load(e.fullZipPath || e.projectPath, e.activity, null);
    }
    return true;
  }

  /**
   *
   * Processes the provided {@link module:bags/JumpInfo.JumpInfo JumpInfo} object, instructing {@link module:JClicPlayer.JClicPlayer JClicPlayer} to go back,
   * stop or jump to another point in the sequence.
   * @param {module:bags/JumpInfo.JumpInfo} ji - The object to be processed
   * @param {boolean} allowReturn - When this parameter is `true`, the jump instructed by `ji` (if any)
   * will be recorded, thus allowing to return to the current activity.
   * @returns {boolean} - `true` if the jump can be processed without errors, `false` otherwise.
   */
  processJump(ji, allowReturn) {
    let result = false;
    if (ji !== null && this.player.project !== null) {
      switch (ji.action) {
        case 'STOP':
          break;
        case 'RETURN':
          if (this.sequenceStack.length > 0 || !this.player.options.returnAsExit) {
            result = this.pop();
            break;
          }
        case 'EXIT':
          if (this.testMode)
            log('info', 'At this point, the program should exit.');
          else
            this.player.exit(ji.sequence);
          break;
        case 'JUMP':
          if (!ji.sequence && !ji.projectPath) {
            const ase = this.player.project.activitySequence.getElement(ji.actNum, true);
            if (ase !== null) {
              if (allowReturn)
                this.push();
              this.player.load(null, null, ase.activity);
              result = true;
            }
          } else {
            if (this.testMode && ji.projectPath !== null && ji.projectPath.length > 0) {
              log('info', `At this point, a jump to "${ji.projectPath}" should be performed.`);
            } else {
              result = this.jumpToSequence(ji.sequence,
                ji.projectPath ? getPath(this.player.project.basePath, ji.projectPath) : null,
                allowReturn);
            }
          }
          break;
      }
    }
    return result;
  }

  /**
   * Performs a jump to the specified sequence
   * @param {string} sequence - The {@link module:bags/ActivitySequence.ActivitySequence ActivitySequence} tag to jump to.
   * @param {string} [path] - When not `null`, indicates a new project file that must be loaded.
   * Otherwise, the `sequence` parameter refers to a tag on the {@link module:bags/ActivitySequence.ActivitySequence ActivitySequence} of the
   * current project.
   * @param {boolean} [allowReturn] - When this parameter is `true`, the jump will be recorded, thus
   * allowing to return to the current activity.
   */
  jumpToSequence(sequence, path = null, allowReturn = false) {
    if (isNullOrUndef(sequence) && isNullOrUndef(path))
      return false;
    if (isNullOrUndef(path))
      path = this.player.project.path;
    if (this.sequenceStack.length > 0) {
      const e = this.sequenceStack[this.sequenceStack.length - 1];
      if (!isNullOrUndef(sequence) && path === e.projectPath) {
        let same = sequence === e.sequence;
        if (path === this.player.project.path) {
          const ase = this.player.project.activitySequence.getElement(e.activity, false);
          same = ase !== null && sequence === ase.tag;
        }
        if (same)
          return this.pop();
      }
    }
    if (allowReturn)
      this.push();
    if (path === this.player.project.path)
      this.player.load(null, sequence, null);
    else
      this.player.load(path, sequence, null);
    return true;
  }
}

Object.assign(PlayerHistory.prototype, {
  /**
   * The {@link module:JClicPlayer.JClicPlayer JClicPlayer} object to which this `PlayerHistory` belongs
   * @name module:PlayerHistory.PlayerHistory#player
   * @type {module:JClicPlayer.JClicPlayer} */
  player: null,
  /**
   * This is the main member of the class. PlayerHistory puts and retrieves
   * on it information about the proects and activities done by the current user.
   * @name module:PlayerHistory.PlayerHistory#sequenceStack
   * @type {module:PlayerHistory.PlayerHistory#HistoryElement[]} */
  sequenceStack: [],
  /**
   * When in test mode, jumps are only simulated.
   * @name module:PlayerHistory.PlayerHistory#testMode
   * @type {boolean} */
  testMode: false,
  /**
   * When true, JClic history is in sync with browser history
   * @name PlayerHistory#browserHistory
   * @type {boolean} */
  browserHistory: false,
  /**
   * When true, a window.history event is currently being processed, so window.pushState should not be performed
   * @name PlayerHistory#processingPop
   * @type {boolean} */
  processingPop: false,
  /**
   * Inner class used to store history elements.
   * @name module:PlayerHistory.PlayerHistory#HistoryElement
   */
  HistoryElement: class {
    /**
     * HistoryElement constructor
     * @param {string} projectPath - The full path of the project file
     * @param {string} sequence - The nearest sequence tag
     * @param {number} activity - The index of the current activity on the project's {@link module:bags/ActivitySequence.ActivitySequence ActivitySequence}
     * @param {string} fullZipPath - If `projectPath` resides in a {@link external:JSZip JSZip} object,
     * the full path of the zip file.
     */
    constructor(projectPath, sequence, activity, fullZipPath) {
      this.projectPath = projectPath;
      this.sequence = sequence;
      this.activity = activity;
      this.fullZipPath = fullZipPath;
    }
  }
});

/* harmony default export */ const src_PlayerHistory = (PlayerHistory);

;// CONCATENATED MODULE: ./src/media/AudioBuffer.js
/**
 *  File    : media/EventSoundsElement.js
 *  Created : 01/04/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */

/* global navigator, window, document, Blob, URL, MediaRecorder */



/**
 * The AudioBuffer object provides sound recording and replaying to activities.
 */
class AudioBuffer {
  /**
   * AudioBuffer constructor
   * @param {number} [seconds] - The maximum amount of time allowed to be recorded by this AudioBuffer
   */
  constructor(seconds) {
    if (navigator && navigator.mediaDevices && navigator.mediaDevices.getUserMedia)
      this.enabled = true;
    if (seconds)
      this.seconds = seconds;
    this.chunks = [];
  }

  /**
   * Starts playing the currently recorded audio, if any.
   */
  play() {
    this.stop();
    if (this.mediaPlayer) {
      this.mediaPlayer.currentTime = 0;
      this.mediaPlayer.play();
    } else {
      this.playWhenFinished = true;
    }
  }

  /**
   * Stops the current operation, either recording or playing audio
   */
  stop() {
    if (this.mediaRecorder && this.mediaRecorder.state === 'recording')
      this.mediaRecorder.stop();
    else if (this.mediaPlayer && !this.mediaPlayer.paused)
      this.mediaPlayer.pause();
  }

  /**
   * Starts recording audio, or stops the recording if already started.
   * @param {external:jQuery} [$div] - Optional `div` element where the recording is performed, as a jQuery ref.
   */
  record($div) {
    if (this.mediaRecorder && this.mediaRecorder.state === 'recording')
      this.mediaRecorder.stop();
    else if (this.enabled) {
      this.stop();
      this.mediaPlayer = null;

      navigator.mediaDevices.getUserMedia({ audio: true, video: false })
        .then(mediaStream => {

          this.mediaRecorder = new MediaRecorder(mediaStream);

          this.mediaRecorder.ondataavailable = ev => this.chunks.push(ev.data);

          this.mediaRecorder.onerror = err => {
            log('error', `Error recording audio: ${err}`);
            this.mediaRecorder = null;
          };

          this.mediaRecorder.onstart = () => {
            log('debug', 'Recording audio started');
            this.visualFeedbak(true, $div);
          };

          this.mediaRecorder.onstop = () => {
            log('debug', 'Recording audio finished');
            this.visualFeedbak(false, $div);

            if (this.timeoutID) {
              window.clearTimeout(this.timeoutID);
              this.timeoutID = null;
            }

            const options = {};
            if (this.chunks.length > 0 && this.chunks[0].type)
              options.type = this.chunks[0].type;
            const blob = new Blob(this.chunks, options);
            this.chunks = [];
            this.mediaPlayer = document.createElement('audio');
            this.mediaPlayer.src = URL.createObjectURL(blob);
            this.mediaPlayer.pause();
            this.mediaRecorder = null;
            if (this.playWhenFinished) {
              this.playWhenFinished = false;
              this.mediaPlayer.play();
            }
          };

          this.mediaRecorder.onwarning = ev => log('warn', `Warning recording audio: ${ev}`);

          this.playWhenFinished = false;

          this.mediaRecorder.start();

          this.timeoutID = window.setTimeout(() => {
            if (this.mediaRecorder);
            this.mediaRecorder.stop();
          }, this.seconds * 1000);
        })
        .catch(err => {
          log('error', err.toString());
          this.visualFeedbak(false, $div);
        });
    }
  }

  /**
   * Set visual feedback to the user while the system is recording audio
   * Currently changes the cursor pointer associated to the HTML element
   * containing the recorder.
   * @param {boolean} enabled - Flag indicating if the visual feedback should be active or inactive
   * @param {external:jQuery} [$div] - Optional `div` element where the recording is performed, as a jQuery ref.
   */
  visualFeedbak(enabled, $div) {
    if ($div)
      $div.css('cursor', enabled ? 'progress' : 'inherit');
  }

  /**
   * Clears all data associated to this AudioBuffer
   */
  clear() {
    this.stop();
    this.mediaPlayer = null;
  }
}

Object.assign(AudioBuffer.prototype, {
  /**
   * AudioBuffer is enabled only in browsers with `navigator.MediaDevices.getuserMedia`
   * @name module:media/AudioBuffer.AudioBuffer#enabled
   * @type {boolean}
   */
  enabled: false,
  /**
   * Maximum length of recordings allowed to this AudioBuffer (in seconds)
   * @name module:media/AudioBuffer.AudioBuffer#seconds
   * @type {number}
   */
  seconds: 20,
  /**
   * The object used to record audio data and convert it to a valid stream for the {@link module:media/ActiveMediaPlayer.ActiveMediaPlayer ActiveMediaPlayer}
   * @name module:media/AudioBuffer.AudioBuffer#mediaRecorder
   * @type {external:MediaRecorder}
   */
  mediaRecorder: null,
  /**
   * Array of data chunks collected during the recording
   * @name module:media/AudioBuffer.AudioBuffer#chunks
   * @type {external:Blob[]}
   */
  chunks: null,
  /**
   * The HTML audio element used to play the recorded sound
   * @name module:media/AudioBuffer.AudioBuffer#mediaPlayer
   * @type {external:HTMLAudioElement}
   */
  mediaPlayer: null,
  /**
   * The identifier of the timer launched to stop the recording when the maximum time is exceeded.
   * This member is `null` when no timeout function is associated to this AudioBuffer
   * @name module:media/AudioBuffer.AudioBuffer#timeoutID
   * @type {number}
   */
  timeoutID: null,
  /**
   * Instructs this AudioBuffer recorder to start playing the collected audio at the end of the
   * current `mediaRecorder` task.
   * @name module:media/AudioBuffer.AudioBuffer#playWhenFinished
   * @type {boolean}
   */
  playWhenFinished: false,
});

/**
 * Maximum amount of time allowed for recordings (in seconds)
 * @type {number}
 */
AudioBuffer.MAX_RECORD_LENGTH = 180;

/* harmony default export */ const media_AudioBuffer = (AudioBuffer);

;// CONCATENATED MODULE: ./src/media/ActiveMediaPlayer.js
/**
 *  File    : media/ActiveMediaPlayer.js
 *  Created : 28/04/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */

/* global navigator */




/**
 * This kind of object encapsulates a realized {@link module:media/MediaContent.MediaContent} and provides methods to start,
 * stop, pause and record different types of media (audio, video, MIDI, voice recording...)
 */
class ActiveMediaPlayer {
  /**
   * ActiveMediaPlayer constructor
   * @param {module:media/MediaContent.MediaContent} mc - - The content used by this player
   * @param {module:bags/MediaBag.MediaBag} mb - The project's MediaBag
   * @param {module:JClicPlayer.JClicPlayer} ps - An object implementing the
   * {@link http://projectestac.github.io/jclic/apidoc/edu/xtec/jclic/PlayStation.html PlayStation} interface,
   * usually a {@link module:JClicPlayer.JClicPlayer JClicPlayer}.
   */
  constructor(mc, mb, ps) {
    this.mc = mc;
    this.ps = ps;
    switch (mc.type) {
      case 'RECORD_AUDIO':
        if (ActiveMediaPlayer.AUDIO_BUFFERS) {
          this.clearAudioBuffer(mc.recBuffer);
          ActiveMediaPlayer.AUDIO_BUFFERS[mc.recBuffer] = new media_AudioBuffer(mc.length);
        }
      /* falls through */
      case 'PLAY_RECORDED_AUDIO':
        this.useAudioBuffer = true;
        break;
      case 'PLAY_AUDIO':
      case 'PLAY_VIDEO':
      case 'PLAY_MIDI':
        this.mbe = mb.getElement(mc.file, true);
        break;
      default:
        break;
    }
  }

  /**
   * Generates the objects that will play media
   */
  realize() {
    if (this.mbe) {
      this.mbe.build(mbe => {
        if (mbe.data && mbe.data.pause && !mbe.data.paused && !mbe.data.ended && mbe.data.currentTime)
          mbe.data.pause();
        if ((mbe.type === 'video' || mbe.type === 'anim') && mbe.data) {
          this.$visualComponent = external_jquery_default()(mbe.data);
          this.$visualComponent.css('z-index', 20);
        }
      }, this.ps, false, this.mc.level);
    }
  }

  /**
   * Plays the media, realizing it if needed.
   * @param {module:boxes/ActiveBox.ActiveBox} [_setBx] - The active box where this media will be placed (when video)
   */
  playNow(_setBx) {
    // TODO: Remove unused param "_setBx"
    if (this.useAudioBuffer) {
      if (ActiveMediaPlayer.AUDIO_BUFFERS) {
        const $div = this.ps && this.ps.$div;
        const buffer = ActiveMediaPlayer.AUDIO_BUFFERS[this.mc.recBuffer];
        if (buffer) {
          if (this.mc.type === 'RECORD_AUDIO') {
            buffer.record($div);
          } else {
            buffer.play();
          }
        }
      }
    } else if (this.mbe) {
      this.mbe.build(() => {
        if (this.mbe.data) {
          if (this.mbe.type === 'midi') {
            this.mbe.data.playTo = this.mc.to || 0;
          } else {
            let armed = false;
            const $player = external_jquery_default()(this.mbe.data);
            // Clear previous event handlers
            $player.off();
            // If there is a time fragment specified, prepare to stop when the `to` position is reached
            if (this.mc.to > 0) {
              $player.on('timeupdate', () => {
                if (armed && this.mbe.data.currentTime >= this.mc.to / 1000) {
                  $player.off('timeupdate');
                  this.mbe.data.pause();
                }
              });
            }
            // Launch the media despite of its readyState
            armed = true;
          }
          if (!this.mbe.data.paused && !this.mbe.data.ended && this.mbe.data.currentTime)
            this.mbe.data.pause();
          // Seek the media position
          this.mbe.data.currentTime = this.mc.from > 0 ? this.mc.from / 1000 : 0;
          this.mbe.data.play();
        }
      }, this.ps, true, this.mc.level);
    }
  }

  /**
   * Plays the media when available, without blocking the current thread.
   * @param {module:boxes/ActiveBox.ActiveBox} [setBx] - The active box where this media will be placed (when video)
   */
  play(setBx) {
    this.stopAllAudioBuffers();
    this.playNow(setBx);
  }

  /**
   * Stops the media playing
   */
  stop() {
    if (this.useAudioBuffer)
      this.stopAudioBuffer(this.mc.recBuffer);
    else if (this.mbe && this.mbe.data && this.mbe.data.pause && !this.mbe.data.paused && !this.mbe.data.ended && this.mbe.data.currentTime)
      this.mbe.data.pause();
  }

  /**
   * Frees all resources used by this player
   */
  clear() {
    this.stop();
    if (this.useAudioBuffer)
      this.clearAudioBuffer(this.mc.recBuffer);
  }

  /**
   * Clears the specified audio buffer
   * @param {number} buffer - Index of the buffer in {@link module:media/ActiveMediaPlayer.ActiveMediaPlayer#AUDIO_BUFFERS AUDIO_BUFFERS}
   */
  clearAudioBuffer(buffer) {
    if (ActiveMediaPlayer.AUDIO_BUFFERS &&
      buffer >= 0 && buffer < ActiveMediaPlayer.AUDIO_BUFFERS.length &&
      ActiveMediaPlayer.AUDIO_BUFFERS[buffer]) {
      ActiveMediaPlayer.AUDIO_BUFFERS[buffer].clear();
      ActiveMediaPlayer.AUDIO_BUFFERS[buffer] = null;
    }
  }

  /**
   * Clears all audio buffers
   */
  clearAllAudioBuffers() {
    if (ActiveMediaPlayer.AUDIO_BUFFERS)
      ActiveMediaPlayer.AUDIO_BUFFERS.forEach((_buffer, n) => this.clearAudioBuffer(n));
  }

  /**
   * Counts the number of active audio buffers
   * @returns {number}
   */
  countActiveBuffers() {
    return ActiveMediaPlayer.AUDIO_BUFFERS ? ActiveMediaPlayer.AUDIO_BUFFERS.reduce((c, ab) => c + ab ? 1 : 0, 0) : 0;
  }

  /**
   * Stops the playing or recording actions of all audio buffers
   */
  stopAllAudioBuffers() {
    if (ActiveMediaPlayer.AUDIO_BUFFERS)
      ActiveMediaPlayer.AUDIO_BUFFERS.forEach(ab => ab ? ab.stop() : null);
  }

  /**
   * Stops a specific audio buffer
   * @param {number} buffer - Index of the buffer in {@link module:media/ActiveMediaPlayer.ActiveMediaPlayer#AUDIO_BUFFERS AUDIO_BUFFERS}
   */
  stopAudioBuffer(buffer) {
    if (ActiveMediaPlayer.AUDIO_BUFFERS &&
      buffer >= 0 && buffer < ActiveMediaPlayer.AUDIO_BUFFERS.length &&
      ActiveMediaPlayer.AUDIO_BUFFERS[buffer])
      ActiveMediaPlayer.AUDIO_BUFFERS[buffer].stop();
  }

  /**
   * Checks the position of visual components after a displacement or resizing of its container
   * @param {module:boxes/ActiveBox.ActiveBox} _bxi - The container where this player is hosted
   */
  checkVisualComponentBounds(_bxi) {
    // does nothing
  }

  /**
   * Sets the visual component of this player visible or invisible
   * @param {boolean} _state - `true` for visible
   */
  setVisualComponentVisible(_state) {
    // TODO: Implement setVisualComponentVisible
  }

  /**
   * Sets the ActiveBox associated to this media player
   * @param {module:boxes/ActiveBox.ActiveBox} setBx - The new container of this media. Can be `null`.
   */
  linkTo(setBx) {
    this.bx = setBx;
    if (this.bx && this.$visualComponent)
      this.bx.setHostedComponent(this.$visualComponent);
  }
}

Object.assign(ActiveMediaPlayer.prototype, {
  /**
   * The MediaContent associated to this player.
   * @name module:media/ActiveMediaPlayer.ActiveMediaPlayer#mc
   * @type {module:media/MediaContent.MediaContent} */
  mc: null,
  /**
   * The player to which this player belongs.
   * @name module:media/ActiveMediaPlayer.ActiveMediaPlayer#ps
   * @type {module:JClicPlayer.JClicPlayer} */
  ps: null,
  /**
   * MediaPlayers should be linked to {@link module:boxes/ActiveBox.ActiveBox ActiveBox} objects.
   * @name module:media/ActiveMediaPlayer.ActiveMediaPlayer#bx
   * @type {module:boxes/ActiveBox.ActiveBox} */
  bx: null,
  /**
   * The visual component for videos, usually a `video` HTML element
   * @name module:media/ActiveMediaPlayer.ActiveMediaPlayer#$visualComponent
   * @type {external:jQuery} */
  $visualComponent: null,
  /**
   * When `true`, this player makes use of a recording audio buffer
   * @name module:media/ActiveMediaPlayer.ActiveMediaPlayer#useAudioBuffer
   * @type {boolean} */
  useAudioBuffer: false,
  /**
   * The {@link module:bads/MediaBagElement.MediaBagElement} containing the reference to the media to be played
   * @name module:media/ActiveMediaPlayer.ActiveMediaPlayer#mbe
   * @type {module:bags/MediaBagElement.MediaBagElement} */
  mbe: null,
});

/**
 * Recording of audio is enabled only when `navigator.getUserMedia` and `MediaRecorder` are defined
 * In 02-Mar-2016 this is implemented only in Firefox 41 and Chrome 49 or later.
 * See: {@link https://addpipe.com/blog/mediarecorder-api}
 * @type Boolean
 */
ActiveMediaPlayer.REC_ENABLED = typeof MediaRecorder !== 'undefined' && typeof navigator !== 'undefined';

if (ActiveMediaPlayer.REC_ENABLED) {
  navigator.getUserMedia = navigator.getUserMedia ||
    navigator.webkitGetUserMedia ||
    navigator.mozGetUserMedia ||
    navigator.msGetUserMedia;
}

/**
 * Audio buffers used for recording and playing voice are stored in a static array because
 * they are common to all instances of {@link module:media/ActiveMediaPlayer.ActiveMediaPlayer ActiveMediaPlayer}
 * Only initialized when {@link module:media/ActiveMediaPlayer.ActiveMediaPlayer#REC_ENABLED REC_ENABLED} is `true`.
 * @type {external:AudioBuffer[]} */
ActiveMediaPlayer.AUDIO_BUFFERS = ActiveMediaPlayer.REC_ENABLED ? [] : null;

/* harmony default export */ const media_ActiveMediaPlayer = (ActiveMediaPlayer);

;// CONCATENATED MODULE: ./src/media/ActiveMediaBag.js
/**
 *  File    : media/ActiveMediaBag.js
 *  Created : 28/04/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */




/**
 * This class stores a collection of realized {@link module:media/ActiveMediaPlayer.ActiveMediaPlayer ActiveMediaPlayer} objects, related to a
 * {@link module:project/JClicProject.JClicProject JClicProject} or {@link module:Activity.Activity Activity}.
 */
class ActiveMediaBag {
  /**
   * ActiveMediaBag constructor
   */
  constructor() {
    this.players = [];
  }

  /**
   * Creates a new {@link module:media/ActiveMediaPlayer.ActiveMediaPlayer ActiveMediaPlayer} linked to this media bag
   * @param {module:media/MediaContent.MediaContent} mc - The content used by the new player
   * @param {module:bags/MediaBag.MediaBag} mb - The project's MediaBag
   * @param {module:JClicPlayer.JClicPlayer} ps - An object implementing the
   * [PlayStation](http://projectestac.github.io/jclic/apidoc/edu/xtec/jclic/PlayStation.html) interface,
   * usually a {@link module:JClicPlayer.JClicPlayer JClicPlayer}.
   * @returns {module:media/ActiveMediaPlayer.ActiveMediaPlayer}
   */
  createActiveMediaPlayer(mc, mb, ps) {
    let amp = null;
    switch (mc.type) {
      case 'RECORD_AUDIO':
        if (mc.length <= 0 || mc.length >= settings.MAX_RECORD_LENGTH)
          break;
      /* falls through */
      case 'PLAY_RECORDED_AUDIO':
        if (mc.recBuffer < 0 || mc.recBuffer >= 10)
          break;
      /* falls through */
      case 'PLAY_AUDIO':
      case 'PLAY_MIDI':
      case 'PLAY_VIDEO':
        amp = new media_ActiveMediaPlayer(mc, mb, ps);
        break;
    }
    if (amp !== null)
      this.players.push(amp);
    return amp;
  }

  /**
   * Looks for an already existing {@link module:media/ActiveMediaPlayer.ActiveMediaPlayer ActiveMediaPlayer} equivalent to the requested.
   * When not found, a new one is created and and returned.
   * @param {module:media/MediaContent.MediaContent} mc - The content used by the new player
   * @param {module:bags/MediaBag.MediaBag} mb - The project's MediaBag
   * @param {module:JClicPlayer.JClicPlayer} ps - An object implementing the
   * {@link http://projectestac.github.io/jclic/apidoc/edu/xtec/jclic/PlayStation.html|PlayStation} interface,
   * usually a {@link module:JClicPlayer.JClicPlayer JClicPlayer}.
   * @returns {module:media/ActiveMediaPlayer.ActiveMediaPlayer}
   */
  getActiveMediaPlayer(mc, mb, ps) {
    return this.players.find(p => p.mc === mc || p.mc.isEquivalent(mc))
      || this.createActiveMediaPlayer(mc, mb, ps);
  }

  /**
   * Removes from the list of players the {@link module:media/ActiveMediaPlayer.ActiveMediaPlayer ActiveMediaPlayer} related to the specified {@link module:media/MediaContent.MediaContent}.
   * @param {module:media/MediaContent.MediaContent} mc - The media content to look for.
   */
  removeActiveMediaPlayer(mc) {
    const i = this.players.findIndex(p => p.mc === mc);
    if (i >= 0) {
      this.players[i].clear();
      // removes the element pointed by 'i'
      this.players.splice(i, 1);
    }
  }

  /**
   * Realizes all the media elements stored in this bag
   */
  realizeAll() {
    this.players.forEach(p => p.realize());
  }

  /**
   * Stops playing all media elements stored in this bag
   * @param {number} level - Level at and below what all media players will be muted.
   */
  stopAll(level) {
    if (typeof level === 'undefined')
      level = -1;
    this.players.forEach(amp => {
      if (level === -1 || amp.mc !== null && amp.mc.level <= level)
        amp.stop();
    });
  }

  /**
   * Removes all players from this media bag
   */
  removeAll() {
    this.players.forEach(p => p.clear());
    // Empty the `players` array
    this.players.length = 0;
    media_ActiveMediaPlayer.prototype.clearAllAudioBuffers();
  }
}

Object.assign(ActiveMediaBag.prototype, {
  /**
   * The collection of {@link module:media/ActiveMediaPlayer.ActiveMediaPlayer ActiveMediaPlayer} objects stored in this media bag.
   * @name module:media/ActiveMediaBag.ActiveMediaBag#players
   * @type {module:media/ActiveMediaPlayer.ActiveMediaPlayer[]} */
  players: [],
});

/* harmony default export */ const media_ActiveMediaBag = (ActiveMediaBag);

;// CONCATENATED MODULE: ./src/skins/assets/basic.css
const basic_namespaceObject = ".ID {\n  width: 100%;\n  background-color: #3F51B5;\n  display: -webkit-flex;\n  display: flex;\n  -webkit-flex-direction: column;\n  flex-direction: column;\n}\n\n.ID .JClicPlayerCnt {\n  background-color: lightblue;\n  margin: 18px;\n  -webkit-flex-grow: 1;\n  flex-grow: 1;\n  position: relative;\n}\n\n.ID .JClicPlayerCnt>div {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n}\n\n.ID button:not(.StockBtn) {\n  background: transparent;\n  padding: 0;\n  border: none;\n  box-shadow: none;\n  text-shadow: none;\n}\n\n.ID .unselectableText {\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\n.ID .progressBar {\n  width: 250px\n}\n";
;// CONCATENATED MODULE: ./src/skins/assets/waitAnim.css
const waitAnim_namespaceObject = ".ID .waitPanel {\n  display: -webkit-flex;\n  display: flex;\n  width: 100%;\n  height: 100%;\n  -webkit-justify-content: center;\n  justify-content: center;\n  -webkit-align-items: center;\n  align-items: center;\n}\n\n.ID .animImgBox {\n  position: relative;\n  width: 300px;\n  height: 300px;\n  max-width: 80%;\n  max-height: 80%;\n}\n\n.ID .animImgBox svg {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  animation-iteration-count: infinite;\n  animation-timing-function: linear;\n}\n\n.ID #waitImgBig {\n  animation-duration: 0.8s;\n  animation-name: rotate-right;\n}\n\n@keyframes rotate-right {\n  from {\n    transform: rotate(0);\n  }\n  to {\n    transform: rotate(1turn);\n  }\n}\n\n.ID #waitImgSmall {\n  animation-duration: 0.6s;\n  animation-name: rotate-left;\n}\n\n@keyframes rotate-left {\n  from {\n    transform: rotate(0);\n  }\n  to {\n    transform: rotate(-1turn);\n  }\n}\n";
;// CONCATENATED MODULE: ./src/skins/assets/reports.css
const reports_namespaceObject = ".ID .dlgDiv {\n  background-color: #efefef;\n  color: #757575;\n  font-family: Roboto, sans-serif;\n  font-size: 10pt;\n  line-height: normal;\n}\n\n.ID .dlgDiv a, a:visited, a:active, a:hover {\n  text-decoration: none;\n  color: inherit;\n}\n\n.ID .dlgMainPanel {\n  padding: 1em 2em;\n  max-height: calc(100vh - 8em);\n  max-width: calc(100vw - 2em);\n  min-width: 20em;\n  overflow: auto;\n}\n\n.ID .dlgMainPanel .headTitle {\n  font-size: 2.5em;\n  font-weight: bold;\n  margin: auto;\n}\n\n.ID .dlgMainPanel .subTitle {\n  font-size: 1.4em;\n  font-weight: bold;\n  margin-bottom: 0.5em;\n}\n\n.ID .dlgMainPanel p {\n  font-size: 1.1em;\n  margin-bottom: 0.5em;\n}\n\n.ID .dlgMainPanel table {\n  table-layout: fixed;\n  width: 40em;\n  margin: 0.5em 0 1.7em 0;\n  border-collapse: collapse;\n}\n\n.ID .dlgMainPanel select {\n  min-width: 20em;\n  font-size: 1.2em;\n  font-family: Roboto, sans-serif;\n  color: #757575;\n}\n\n.ID .dlgMainPanel input {\n  margin-left: 1em;\n  font-size: 1.2em;\n  font-family: Roboto, sans-serif;\n  border-color: lightgray;\n}\n\n.ID .infoHead {\n  padding: 1em 0em 0.5em;\n}\n\n.ID .JCGlobalResults td {\n  padding: 0.4em;\n  border-bottom: 1px solid #b6b6b6;\n}\n\n.ID .JCGlobalResults td:first-child {\n  font-weight: 600;\n  width: 14em;\n}\n\n.ID .JCDetailed td, th {\n  border-bottom: 1px solid #b6b6b6;\n  padding: 0.3em 0.4em;\n  vertical-align: top;\n  text-align: center;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n\n.ID .JCDetailed thead {\n  font-weight: 600;\n}\n\n.ID .JCDetailed th:first-child {\n  width: 7em;\n}\n\n.ID .JCDetailed th:nth-last-child(4) {\n  width: 4em;\n}\n\n.ID .JCDetailed th:nth-last-child(-n+3) {\n  width: 4.1em;\n  text-align: right;\n}\n\n.ID .JCDetailed td:nth-last-child(-n+3) {\n  text-align: right;\n}\n\n.ID .JCDetailed .ok {\n  color: #4bae4f;\n  font-weight: 600;\n}\n\n.ID .JCDetailed .no {\n  color: #f34235;\n  font-weight: 600;\n}\n\n.ID .JCDetailed tr:last-child {\n  font-weight: bold;\n}\n\n.ID .JCDetailed .incomplete {\n  font-style: italic;\n}\n\n.ID .dlgBottomPanel {\n  height: 3.5em;\n  background-color: white;\n  padding: 0.5em;\n  font-weight: bold;\n  text-align: right;\n  border-top: 1px solid #eee;\n  position: relative;\n}\n\n.ID .dlgBottomPanel .smallPopup {\n  background-color: #222;\n  color: #ddd;\n  padding: 0.5em;\n  font-size: 0.9em;\n  position: absolute;\n  right: 6em;\n  top: 1em;\n}\n\n.ID .dlgBottomPanel button {\n  display: inline-block;\n  padding: 10px;\n  cursor: pointer;\n  line-height: 0;\n}\n\n.ID .dlgBottomPanel button:hover {\n  background-color: #eee;\n  border-radius: 80px;\n}\n\n.ID .dlgBottomPanel button:active {\n  background-color: #b3e5fc;\n}\n";
;// CONCATENATED MODULE: ./src/skins/assets/waitImgSmall.svg
const waitImgSmall_namespaceObject = "<svg id=\"waitImgSmall\" viewBox=\"0 0 80 80\" xmlns=\"http://www.w3.org/2000/svg\">\n  <path fill=\"#3F51B5\" d=\"m 57.00,39.43 c -0.28,-3.53 5.16,-3.27 5.37,-0.13 0.26,3.99 -5.13,21.04 -20.63,21.44 C 23.85,61.19 19.93,46.50 19.92,39.94 23.48,67.11 58.73,61.35 57.00,39.43 Z\" />\n</svg>\n";
;// CONCATENATED MODULE: ./src/skins/assets/waitImgBig.svg
const waitImgBig_namespaceObject = "<svg id=\"waitImgBig\" viewBox=\"0 0 80 80\" xmlns=\"http://www.w3.org/2000/svg\">\n  <path fill=\"#3F51B5\" d=\"m 65.99,40.19 c -0.42,5.33 7.80,4.94 8.11,0.20 C 74.50,34.37 66.35,8.59 42.92,7.98 15.90,7.29 9.96,29.50 9.94,39.41 15.33,-1.66 68.61,7.048 65.99,40.19 Z\" />\n</svg>\n";
;// CONCATENATED MODULE: ./src/skins/assets/appLogo.svg
const appLogo_namespaceObject = "<svg viewBox=\"0 0 64 64\" xmlns=\"http://www.w3.org/2000/svg\">\n  <g transform=\"matrix(.02081 0 0-.02081 5 62.33)\">\n    <path d=\"m1263 1297l270 1003 996-267-267-990c-427-1583-2420-1046-1999 519 3 11 999-266 999-266z\" fill=\"none\" stroke=\"#9d6329\" stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-width=\"180\" stroke-miterlimit=\"3.864\" />\n    <path d=\"m1263 1297l270 1003 996-267-267-990c-427-1583-2420-1046-1998 519 3 11 999-266 999-266\" fill=\"#f89c0e\" />\n    <path d=\"m357 2850l1000-268-267-992-1000 266 267 994z\" fill=\"none\" stroke=\"#86882b\" stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-width=\"180\" stroke-miterlimit=\"3.864\" />\n    <path d=\"m357 2850l1000-268-267-992-1000 266 267 994\" fill=\"#d9e70c\" />\n  </g>\n</svg>\n";
;// CONCATENATED MODULE: ./src/skins/assets/closeDialogIcon.svg
const closeDialogIcon_namespaceObject = "<svg fill=\"#757575\" viewBox=\"0 0 24 24\" width=\"36\" height=\"36\" xmlns=\"http://www.w3.org/2000/svg\">\n  <path d=\"M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z\" />\n</svg>\n";
;// CONCATENATED MODULE: ./src/skins/assets/okDialogIcon.svg
const okDialogIcon_namespaceObject = "<svg fill=\"#757575\" viewBox=\"0 0 24 24\" width=\"36\" height=\"36\" xmlns=\"http://www.w3.org/2000/svg\">\n  <path d=\"M9 16.2L4.8 12l-1.4 1.4L9 19 21 7l-1.4-1.4L9 16.2z\" />\n</svg>\n";
;// CONCATENATED MODULE: ./src/skins/assets/copyIcon.svg
const copyIcon_namespaceObject = "<svg fill=\"#757575\" viewBox=\"0 0 24 24\" width=\"36\" height=\"36\" xmlns=\"http://www.w3.org/2000/svg\">\n  <path d=\"M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z\" />\n</svg>\n";
;// CONCATENATED MODULE: ./src/skins/Skin.js
/**
 *  File    : skins/Skin.js
 *  Created : 29/04/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */

/* global Promise, window, document */






// Use Webpack to import CSS and SVG files










/**
 * This abstract class manages the layout, position ans size of the visual components of JClic:
 * player window, message box, counters, buttons, status... and also the appearance of the main
 * container.
 * The basic implementation of Skin is {@link module:skins/DefaultSkin.DefaultSkin DefaultSkin}.
 * @abstract
 * @extends module:AWT.Container
 */
class Skin extends Container {
  /**
   * Skin constructor
   * @param {module:JClicPlayer.JClicPlayer} ps - The `PlayStation` (currently a {@link module:JClicPlayer.JClicPlayer JClicPlayer}) used to load and
   * realize the media objects needed tot build the Skin.
   * @param {string} [name] - The skin name
   * @param {object} [options] - Optional parameter with additional options
   */
  constructor(ps, name = null, options = {}) {

    // Skin extends [AWT.Container](AWT.html)
    super();

    // Save parameters for later use
    this.ps = ps;
    if (name !== null)
      this.name = name;
    this.options = options;

    if (this.options.skinId)
      this.skinId = this.options.skinId;

    if (!Skin.registerStyleSheet(this.skinId, ps)) {
      let css = this._getStyleSheets('default');
      let twoThirds = this._getStyleSheets('twoThirds');
      if (twoThirds.length > 0)
        css += ` @media (max-width:${this.twoThirdsMedia.width}px),(max-height:${this.twoThirdsMedia.height}px){${twoThirds}}`;
      let half = this._getStyleSheets('half');
      if (half.length > 0)
        css += ` @media (max-width:${this.halfMedia.width}px),(max-height:${this.halfMedia.height}px){${half}}`;
      appendStyleAtHead(css.replace(/\.ID/g, `.${this.skinId}`), ps);
    }

    let msg = '';

    this.$div = external_jquery_default()('<div/>', { class: this.skinId });
    this.$playerCnt = external_jquery_default()('<div/>', { class: 'JClicPlayerCnt' });

    // Add waiting panel and progress bar
    this.$progress = external_jquery_default()('<progress/>', { class: 'progressBar' })
      .css({ display: 'none' });
    this.$waitPanel = external_jquery_default()('<div/>')
      .css({ display: 'none', 'background-color': 'rgba(255, 255, 255, .60)', 'z-index': 99 })
      .append(external_jquery_default()('<div/>', { class: 'waitPanel' }).css({ display: 'flex', 'flex-direction': 'column' })
        .append(external_jquery_default()('<div/>', { class: 'animImgBox' })
          .append(external_jquery_default()(this.waitImgBig), external_jquery_default()(this.waitImgSmall)))
        .append(this.$progress));
    this.$playerCnt.append(this.$waitPanel);

    this.buttons = cloneObject(Skin.prototype.buttons);
    this.counters = cloneObject(Skin.prototype.counters);
    this.msgArea = cloneObject(Skin.prototype.msgArea);

    // Create dialog overlay and panel
    this.$dlgOverlay = external_jquery_default()('<div/>', { class: 'dlgOverlay' }).css({
      'z-index': 98,
      position: 'fixed',
      left: 0,
      top: 0,
      width: '100%',
      height: '100%',
      display: 'none',
      'background-color': 'rgba(30,30,30,0.7)'
    }).on('click', () => {
      if (!this._isModalDlg)
        // Non-modal dialogs are closed on click outside the main area
        this._closeDlg(true);
      return false;
    });

    const $dlgDiv = external_jquery_default()('<div/>', {
      class: 'dlgDiv',
      role: 'dialog',
      'aria-labelledby': ps.getUniqueId('ReportsLb'),
      'aria-describedby': ps.getUniqueId('ReportsCnt')
    }).css({
      display: 'inline-block',
      position: 'relative',
      top: '50%',
      left: '50%',
      transform: 'translate(-50%, -50%)'
    }).on('click', () => {
      // Clicks not passed to parent
      return false;
    });

    this.$dlgMainPanel = external_jquery_default()('<div/>', { class: 'dlgMainPanel', id: ps.getUniqueId('ReportsCnt') });
    this.$dlgBottomPanel = external_jquery_default()('<div/>', { class: 'dlgBottomPanel', role: 'navigation' });

    // Basic dialog structure:
    this.$div.append(
      this.$playerCnt,
      this.$dlgOverlay.append(
        $dlgDiv.append(
          this.$dlgMainPanel,
          this.$dlgBottomPanel)));

    msg = getMsg('JClic logo');
    this.$infoHead = external_jquery_default()('<div/>', { class: 'infoHead' })
      .append(external_jquery_default()('<div/>', { class: 'headTitle unselectableText' })
        .append(external_jquery_default()(this.appLogo, { 'aria-label': msg }).css({ width: '1.5em', height: '1.5em', 'vertical-align': 'bottom' })
          .on('dblclick', () => {
            // Double click on JClic logo is a hidden method to increase verbosity on Javascript console
            setLogLevel('all');
            log('trace', 'Log level set to "trace"');
          }))
        .append(external_jquery_default()('<span/>').html('JClic.js')))
      .append(external_jquery_default()('<p/>').css({ 'margin-top': 0, 'margin-left': '3.5em' })
        .append(external_jquery_default()('<a/>', { href: 'http://clic.xtec.cat/repo/index.html?page=info' }).html('http://clic.xtec.cat'))
        .append(external_jquery_default()('<br>'))
        .append(external_jquery_default()('<span/>').html(`${getMsg('Version')} ${settings.VERSION}`)));

    this.$reportsPanel = external_jquery_default()('<div/>', { class: 'reportsPanel', role: 'document' });

    msg = getMsg('Copy data to clipboard');
    this.$copyBtn = external_jquery_default()('<button/>', { title: msg, 'aria-label': msg })
      .append(external_jquery_default()(this.copyIcon).css({ width: '26px', height: '26px' }))
      .on('click', () => {
        const item = new external_clipboard_polyfill_namespaceObject.ClipboardItem({
          'text/plain': `===> ${getMsg('The data has been copied in HTML format. Please paste them into a spreadsheet or in a rich text editor')} <===`,
          'text/html': this.$reportsPanel.html(),
        });
        external_clipboard_polyfill_namespaceObject.write([item])
          .then(() => this.$copyBtn.parent().append(
            external_jquery_default()('<div/>', { class: 'smallPopup' })
              .html(getMsg('The data has been copied to clipboard'))
              .fadeIn()
              .delay(3000)
              .fadeOut(function () { external_jquery_default()(this).remove(); })))
          .catch(err => this.$copyBtn.parent().append(
            external_jquery_default()('<div/>', { class: 'smallPopup' })
              .html(`ERROR: Unable to write data into the clipboard: ${err}`)
              .fadeIn()
              .delay(3000)
              .fadeOut(function () { external_jquery_default()(this).remove(); })));
      });

    msg = getMsg('Close');
    this.$closeDlgBtn = external_jquery_default()('<button/>', { title: msg, 'aria-label': msg })
      .append(external_jquery_default()(this.closeDialogIcon).css({ width: '26px', height: '26px' }))
      .on('click', () => this._closeDlg(true));

    msg = getMsg('OK');
    this.$okDlgBtn = external_jquery_default()('<button/>', { title: msg, 'aria-label': msg })
      .append(external_jquery_default()(this.okDialogIcon).css({ width: '26px', height: '26px' }))
      .on('click', () => this._closeDlg(true));

    msg = getMsg('Cancel');
    this.$cancelDlgBtn = external_jquery_default()('<button/>', { title: msg, 'aria-label': msg })
      .append(external_jquery_default()(this.closeDialogIcon).css({ width: '26px', height: '26px' }))
      .on('click', () => this._closeDlg(false));

    // Registers this Skin in the list of realized Skin objects
    Skin.skinStack.push(this);
  }

  /**
   * Registers a new type of skin
   * @param {string} skinName - The name used to identify this skin
   * @param {function} skinClass - The skin class, usually extending Skin
   * @returns {module:skins/Skin.Skin} - The provided skin class
   */
  static registerClass(skinName, skinClass) {
    Skin.CLASSES[skinName] = skinClass;
    return skinClass;
  }

  /**
   * Checks if the provided stylesheet ID is already registered in the root node where the current player is placed
   * @param {string} skinId - The unique identifier of the skin to check
   * @param {module:JClicPlayer.JClicPlayer} [ps] - An optional `PlayStation` (currently a {@link module:JClicPlayer.JClicPlayer JClicPlayer}) used as a base to find the root node
   * @returns {boolean} - _true_ when the skin stylesheet is already defined in the current root node, _false_ otherwise
   */
  static registerStyleSheet(skinId, ps) {
    let result = false;
    const root = getRootHead(ps);
    if (!root['__JClicID'])
      root.__JClicID = `SK${Skin.lastId++}`;

    let styles = Skin.rootStyles[root.__JClicID];
    if (!styles) {
      styles = [];
      Skin.rootStyles[root.__JClicID] = styles;
    }

    if (styles.indexOf(skinId) < 0) {
      log('trace', `Stylesheet "${skinId}" has been registered for root node labeled as "${root.__JClicID}"`);
      styles.push(skinId);
    } else
      result = true;

    return result;
  }

  /**
   * Gets the specified Skin from `skinStack`, or creates a new one if not found.
   * This function should be used only through `Skin.getSkin`
   * @param {string} skinName - The name of the searched skin
   * @param {module:JClicPlayer.JClicPlayer} ps - The PlayStation (usually a {@link module:JClicPlayer.JClicPlayer JClicPlayer}) used to build the new skin.
   * @param {object} [options] - Optional parameter with additional options
   * @returns {module:skins/Skin.Skin}
   */
  static getSkin(skinName = 'default', ps, options = {}) {
    skinName = skinName || 'default';

    // Correct old skin names
    if (skinName.charAt(0, 1) === '@' && skinName.substr(-4) === '.xml')
      skinName = skinName.substr(1, skinName.length - 5);

    // look for the skin in the stack of realized skins
    if (skinName && ps) {
      // TODO: Check also `options`!
      const sk = Skin.skinStack.find(s => s.name === skinName && s.ps === ps);
      if (sk)
        return sk;
    }

    // Locates the class of the requested Skin (or [DefaultSkin](DefaultSkin.html)
    // if not specified). When not found, a new one is created and registered in `skinStack`
    let cl = Skin.CLASSES[skinName];
    if (!cl) {
      // Process custom skin XML files
      const mbe = ps.project.mediaBag.getElement(skinName, false);
      if (mbe && mbe.data) {
        options = Object.assign({}, options, mbe.data);
        options.skinId = `JClic-${skinName.replace('.xml', '')}`;
      }

      if (!ps.zip
        && options.class === 'edu.xtec.jclic.skins.BasicSkin'
        && options.image
        && ps.project.mediaBag.getElement(options.image, false)
        && ps.project.mediaBag.getElement(options.image, false).data)
        cl = Skin.CLASSES.custom;
      else {
        log('warn', `Unknown skin class: ${skinName}`);
        cl = Skin.CLASSES.default;
      }
    }

    // Build and return the requested skin
    return new cl(ps, skinName, options);
  }

  /**
   * Returns the CSS styles used by this skin. This method should be called only from
   * the `Skin` constructor, and overridded by subclasses if needed.
   * @param {string} media - A specific media size. Possible values are: 'default', 'half' and 'twoThirds'
   * @returns {string}
   */
  _getStyleSheets(media = 'default') {
    return media === 'default' ? (this.basicCSS + this.waitAnimCSS + this.reportsCSS) : '';
  }

  /**
   * Attaches a {@link module:JClicPlayer.JClicPlayer JClicPlayer} object to this Skin
   * @param {module:JClicPlayer.JClicPlayer} player
   */
  attach(player) {
    this.detach();
    if (player !== null && player.skin !== null)
      player.skin.detach();
    this.player = player;
    this.$playerCnt.prepend(player.$div);
    this.setSkinSizes();
    player.$mainContainer.append(this.$div);
  }

  /**
   * Sets the 'size' CSS values (max, min and compulsory) to the main `div` of this skin
   * @param {boolean} full - `true` when the skin is in full screen mode
   */
  setSkinSizes(full) {
    const
      css = {},
      topHeight = this.player?.$topDiv.height() || 0,
      nilValue = this.player.fullScreenChecked ? 'inherit' : null;

    // When `full` no set, detect the current status
    if (typeof full === 'undefined')
      full = document && document.fullscreenElement ? true : false;

    toCssSize(full ? '100vw' : this.ps.options.minWidth, css, 'min-width', nilValue);
    toCssSize(full ? '100vh' : this.ps.options.minHeight, css, 'min-height', nilValue);
    toCssSize(full ? '100vw' : this.ps.options.maxWidth, css, 'max-width', nilValue);
    toCssSize(full ? '100vh' : this.ps.options.maxHeight, css, 'max-height', nilValue);
    toCssSize(full ? '100vw' : this.ps.options.width, css, 'width', '100%');
    toCssSize(full ? '100vh' : this.ps.options.height, css, 'height', topHeight > 0 ? '100%' : '100vh');
    this.$div.css(css);
  }

  /**
   * Detaches the `player` element from this Skin
   */
  detach() {
    if (this.player !== null) {
      this.player.$div.remove();
      this.$div.detach();
      this.player = null;
    }
  }

  /**
   * Updates the graphic contents of this skin.
   * This method should be called from {@link module:skins/Skin.Skin#update}
   * @override
   * @param {module:AWT.Rectangle} dirtyRegion - Specifies the area to be updated. When `null`, it's the
   * whole panel.
   */
  updateContent(dirtyRegion) {
    if (this.$msgBoxDivCanvas) {
      const ctx = this.$msgBoxDivCanvas.get(-1).getContext('2d');
      ctx.clearRect(0, 0, ctx.canvas.clientWidth, ctx.canvas.clientHeight);
      this.msgBox.update(ctx, dirtyRegion);
    }
    return super.updateContent();
  }

  /**
   * Resets all counters
   * @param {boolean} bEnabled - Leave it enabled/disabled
   */
  resetAllCounters(bEnabled) {
    external_jquery_default().each(this.counters, (_name, counter) => {
      if (counter !== null) {
        counter.value = 0;
        counter.countDown = 0;
        counter.enabled = bEnabled;
        counter.refreshDisplay();
      }
    });
  }

  /**
   * Sets/unsets the 'wait' state
   * @param {boolean} status - Whether to set or unset the wait status. When `undefined`, the
   * `waitCursorCount` member is evaluated to decide if the wait state should be activated or deactivated.
   */
  setWaitCursor(status) {
    if (typeof status === 'undefined') {
      if (this.$waitPanel)
        this.$waitPanel.css({
          display: this.waitCursorCount > 0 ? 'initial' : 'none'
        });
    } else {
      switch (status) {
        case true:
          this.waitCursorCount++;
          break;
        case false:
          if (--this.waitCursorCount < 0)
            this.waitCursorCount = 0;
          break;
        case 'reset':
          this.waitCursorCount = 0;
          break;
      }
      this.setWaitCursor();
    }
  }

  /**
   * Sets the current value of the progress bar
   * @param {number} val - The current value. Should be less or equal than `max`. When -1, the progress bar will be hidden.
   * @param {number} [max] - Optional parameter representing the maximum value. When passed, the progress bar will be displayed.
   */
  setProgress(val, max) {
    if (this.$progress) {
      this.currentProgress = val;
      if (val < 0)
        this.$progress.css({ display: 'none' });
      else {
        if (max) {
          this.maxProgress = max;
          this.$progress.attr('max', max).css({ display: 'initial' });
        }
        this.$progress.attr('value', val);
      }
      log('trace', `Progress: ${this.currentProgress}/${this.maxProgress}`);
    }
  }

  /**
   * Increments the progress bar value by the specified amount, only when the progress bar is running.
   * @param {number} [val] - The amount to increment. When not defined, it's 1.
   */
  incProgress(val) {
    if (this.currentProgress >= 0)
      this.setProgress(this.currentProgress + (val || 1));
  }

  /**
   * Shows a window with clues or help for the current activity
   * @param {external:jQuery} _$hlpComponent - A JQuery DOM element with the information to be shown.
   * It can be a string or number. When `null`, the help window (if any) must be closed.
   */
  showHelp(_$hlpComponent) {
    // TODO: Implement HelpWindow
  }

  /**
   * Shows a "dialog" panel, useful for displaying information or prompt something to users
   * @param {boolean} modal - When `true`, the dialog should be closed by any click outside the main panel
   * @param {object} options - This object should have two components: `main` and `bottom`, both
   * containing a jQuery HTML element (or array of elements) to be placed on the main and bottom panels
   * of the dialog.
   * @returns {external:Promise} - A Promise that will be fulfilled when the dialog is closed.
   */
  showDlg(modal, options) {
    return new Promise((resolve, reject) => {
      this._dlgOkValue = 'ok';
      this._dlgCancelValue = 'cancelled';
      this._isModalDlg = modal;

      this.$dlgMainPanel.children().detach();
      this.$dlgBottomPanel.children().detach();
      if (options.main)
        this.$dlgMainPanel.append(options.main);
      if (options.bottom)
        this.$dlgBottomPanel.append(options.bottom);

      this._closeDlg = resolved => {
        if (resolved && resolve)
          resolve(this._dlgOkValue);
        else if (!resolved && reject)
          reject(this._dlgCancelValue);
        this.$dlgOverlay.css({ display: 'none' });
        this.enableMainButtons(true);
        this._closeDlg = Skin.prototype._closeDlg;
      };
      this.enableMainButtons(false);
      this.$dlgOverlay.css({ display: 'initial' });
    });
  }

  /**
   * Enables or disables the `tabindex` attribute of the main buttons. Useful when a modal dialog
   * overlay is active, to avoid direct access to controls not related with the dialog.
   * @param {boolean} status - `true` to make main controls navigable, `false` otherwise
   */
  enableMainButtons(status) {
    this.$playerCnt.find('button').attr('tabindex', status ? '0' : '-1');
  }

  /**
   * Called when the dialog must be closed, usually only by Skin members.
   * This method is re-defined on each call to `showDlg`, so the `resolve` and `reject`
   * functions can be safely called.
   */
  _closeDlg() {
    // Do nothing
  }

  /**
   * Displays a dialog with a report of the current results achieved by the user.
   * @param {module:report/Reporter.Reporter} reporter - The reporter system currently in use
   * @returns {external:Promise} - The Promise returned by {@link module:skins/Skin.Skin.showDlg}.
   */
  showReports(reporter) {
    this.$reportsPanel.html(this.$printReport(reporter));
    return this.showDlg(false, {
      main: [this.$infoHead, this.$reportsPanel],
      bottom: [this.$copyBtn, this.$closeDlgBtn]
    });
  }

  /**
   * Formats the current report in a DOM tree, ready to be placed in `$reportsPanel`
   * @param {module:report/Reporter.Reporter} reporter - The reporter system currently in use
   * @returns {external:jQuery[]} - An array of jQuery objects containing the full report
   */
  $printReport(reporter) {
    let result = [];
    if (reporter) {
      const
        report = reporter.getData(),
        started = new Date(report.started);

      result.push(external_jquery_default()('<div/>', { class: 'subTitle', id: this.ps.getUniqueId('ReportsLb') }).html(getMsg('Current results')));

      const $t = external_jquery_default()('<table/>', { class: 'JCGlobalResults' });
      $t.append(
        $HTML.doubleCell(
          getMsg('Session started:'),
          `${started.toLocaleDateString()} ${started.toLocaleTimeString()}`),
        $HTML.doubleCell(
          getMsg('Reports system:'),
          `${getMsg(report.descriptionKey)} ${report.descriptionDetail}`));
      if (report.userId)
        $t.append($HTML.doubleCell(
          getMsg('User:'),
          report.userId));
      else if (report.user) // SCORM user
        $t.append($HTML.doubleCell(
          getMsg('User:'),
          report.user));

      if (report.sequences > 0) {
        if (report.sessions.length > 1)
          $t.append($HTML.doubleCell(
            getMsg('Projects:'),
            report.sessions.length));
        $t.append(
          $HTML.doubleCell(
            getMsg('Sequences:'),
            report.sequences),
          $HTML.doubleCell(
            getMsg('Activities done:'),
            report.activitiesDone),
          $HTML.doubleCell(
            getMsg('Activities played at least once:'),
            `${report.playedOnce}/${report.reportable} (${getPercent(report.ratioPlayed / 100)})`));
        if (report.activitiesDone > 0) {
          $t.append($HTML.doubleCell(
            getMsg('Activities solved:'),
            `${report.activitiesSolved} (${getPercent(report.ratioSolved / 100)})`));
          if (report.actScore > 0)
            $t.append(
              $HTML.doubleCell(
                getMsg('Partial score:'),
                `${getPercent(report.partialScore / 100)} ${getMsg('(out of played activities)')}`),
              $HTML.doubleCell(
                getMsg('Global score:'),
                `${getPercent(report.globalScore / 100)} ${getMsg('(out of all project activities)')}`));
          $t.append(
            $HTML.doubleCell(
              getMsg('Total time in activities:'),
              getHMStime(report.time * 1000)),
            $HTML.doubleCell(
              getMsg('Actions done:'),
              report.actions));
        }
        result.push($t);

        report.sessions.forEach(sr => {
          if (sr.sequences.length > 0) {
            const $t = external_jquery_default()('<table/>', { class: 'JCDetailed' });
            result.push(external_jquery_default()('<p/>').html(report.sessions.length > 1 ? `${getMsg('Project')} ${sr.projectName}` : ''));
            $t.append(external_jquery_default()('<thead/>').append(external_jquery_default()('<tr/>').append(
              $HTML.th(getMsg('sequence')),
              $HTML.th(getMsg('activity')),
              $HTML.th(getMsg('OK')),
              $HTML.th(getMsg('actions')),
              $HTML.th(getMsg('score')),
              $HTML.th(getMsg('time')))));

            sr.sequences.forEach(seq => {
              let $tr = external_jquery_default()('<tr/>').append(external_jquery_default()('<td/>', { rowspan: seq.activities.length }).html(seq.sequence));
              seq.activities.forEach(act => {
                if (act.closed) {
                  $tr.append($HTML.td(act.name));
                  $tr.append(act.solved ? $HTML.td(getMsg('YES'), 'ok') : $HTML.td(getMsg('NO'), 'no'));
                  $tr.append($HTML.td(act.actions));
                  $tr.append($HTML.td(getPercent(act.precision / 100)));
                  $tr.append($HTML.td(getHMStime(act.time * 1000)));
                } else {
                  $tr.append($HTML.td(act.name, 'incomplete'));
                  for (let r = 0; r < 4; r++)
                    $tr.append($HTML.td('-', 'incomplete'));
                }
                $t.append($tr);
                $tr = external_jquery_default()('<tr/>');
              });
            });

            $t.append(external_jquery_default()('<tr/>').append(
              $HTML.td(getMsg('Total:')),
              $HTML.td(`${sr.played} (${getPercent(sr.ratioPlayed / 100)})`),
              $HTML.td(`${sr.solved} (${getPercent(sr.ratioSolved / 100)})`),
              $HTML.td(sr.actions),
              $HTML.td(getPercent(sr.score / 100)),
              $HTML.td(getHMStime(sr.time * 1000))));

            result.push($t);
          }
        }, this);
      } else
        result.push(external_jquery_default()('<p/>').html(getMsg('No activities done!')));
    }
    return result;
  }

  /**
   * Enables or disables a specific counter
   * @param {string} counter - Which counter
   * @param {boolean} bEnabled - When `true`, the counter will be enabled.
   */
  enableCounter(counter, bEnabled) {
    if (this.counters[counter])
      this.counters[counter].setEnabled(bEnabled);
  }

  /**
   * Main method used to build the content of the skin. Resizes and places internal objects.
   */
  doLayout() {
    // Resize player
    this.player.doLayout();

    // Build ths canvas at the end of current thread, thus avoiding
    // invalid sizes due to incomplete layout of DOM objects
    if (this.$msgBoxDiv)
      window.setTimeout(() => {

        // Temporary remove canvas to let div get its natural size:
        if (this.$msgBoxDivCanvas)
          this.$msgBoxDivCanvas.remove();

        // Get current size of message box div without canvas
        const
          msgWidth = this.$msgBoxDiv.outerWidth(),
          msgHeight = this.$msgBoxDiv.outerHeight();

        // Replace existing canvas if size has changed
        if (this.$msgBoxDivCanvas === null ||
          this.msgBox.dim.widht !== msgWidth ||
          this.msgBox.dim.height !== msgHeight) {
          this.$msgBoxDivCanvas = external_jquery_default()(`<canvas width="${msgWidth}" height="${msgHeight}"/>`);
          this.msgBox.setBounds(new Rectangle(0, 0, msgWidth + 1, msgHeight));
          this.msgBox.buildAccessibleElement(this.$msgBoxDivCanvas, this.$msgBoxDiv);
        }
        // restore canvas
        this.$msgBoxDiv.append(this.$msgBoxDivCanvas);
        this.updateContent();
      }, 0);
  }

  /**
   * adjusts the skin to the dimension of its `$div` container
   * @returns {module:AWT.Dimension} the new dimension of the skin
   */
  fit() {
    this.doLayout();
    return new Dimension(this.$div.width(), this.$div.height());
  }

  /**
   * Sets or unsets the player in fullscreen mode, when allowed, using the
   * {@link https://github.com/sindresorhus/screenfull.js|screenfull.js} library.
   * @param {boolean} status - Whether to set or unset the player in fullscreen mode. When `null`
   * or `undefined`, the status toggles between fullscreen and windowed modes.
   * @returns {boolean} `true` if the request was successful, `false` otherwise.
   */
  setScreenFull(status) {
    if (document && document.fullscreenEnabled && (
      status === true && !document.fullscreenElement ||
      status === false && !document.fullscreenElement ||
      status !== true && status !== false)) {
      // Save current value of fullScreen for later use
      const full = document.fullscreenElement ? true : false;
      if (!document.fullscreenElement) {
        const element = this.player.$mainContainer.get(-1);
        if (element && element.requestFullscreen)
          element.requestFullscreen();
      } else {
        if (document.exitFullscreen) {
          document.exitFullscreen();
        }
      }
      this.player.fullScreenChecked = true;
      // Firefox don't updates `document.fullscreenElement` in real time, so use the saved value instead
      this.setSkinSizes(!full);
    }
  }

  /**
   * Method used to notify this skin that a specific action has changed its enabled/disabled status
   * @param {module:AWT.Action} _action - The action originating the change event
   */
  actionStatusChanged(act) {
    if (act.name && this.buttons[act.name])
      this.setEnabled(this.buttons[act.name], act.enabled);
  }

  /**
   * Enables or disables an object
   * @param {external:jQuery} $object - A JQuery DOM element
   * @override
   * @param {boolean} enabled
   */
  setEnabled($object, enabled) {
    if ($object && enabled)
      $object.removeAttr('disabled');
    else if ($object)
      $object.attr('disabled', true);
  }

  /**
   * Compares two Skin objects
   * @param {module:skins/Skin.Skin} skin - The Skin to compare against this
   * @returns {boolean} - `true` if both skins are equivalent.
   */
  equals(skin) {
    return skin &&
      this.name === skin.name &&
      this.ps === skin.ps;
  }

  /**
   * Gets the {@link module:boxes/ActiveBox.ActiveBox ActiveBox} used to display the main messages of activities
   * @returns {module:boxes/ActiveBox.ActiveBox}
   */
  getMsgBox() {
    return this.msgBox;
  }
}

/**
 * Collection of realized __Skin__ objects.
 * @type {module:skins/Skin.Skin[]}
 */
Skin.skinStack = [];

/**
 * Collection of skin style sheets already registered on the current document
 * @type {object}
 */
Skin.rootStyles = {};

/**
 * Counter used to label root nodes with unique IDs
 * @type {number}
 */
Skin.lastId = 1;

/**
 * List of classes derived from Skin. It should be filled by real skin classes at declaration time.
 * @type {object}
 */
Skin.CLASSES = {};

Object.assign(Skin.prototype, {
  /**
   * Class name of this skin. It will be used as a base selector in the definition of all CSS styles.
   * @name module:skins/Skin.Skin#skinId
   * @type {string} */
  skinId: 'JClicBasicSkin',
  /**
   * The HTML div object used by this Skin
   * @name module:skins/Skin.Skin#$div
   * @type {external:jQuery} */
  $div: null,
  /**
   * The HTML div where JClic Player will be placed
   * @name module:skins/Skin.Skin#$playerCnt
   * @type {external:jQuery} */
  $playerCnt: null,
  /**
   * Current name of the skin.
   * @name module:skins/Skin.Skin#name
   * @type {string} */
  name: 'default',
  /**
   * Specific options of this skin
   * @name module:skins/Skin.Skin#options
   * @type {object} */
  options: {},
  /**
   * Waiting panel, displayed while loading resources.
   * @name module:skins/Skin.Skin#$waitPanel
   * @type {external:jQuery} */
  $waitPanel: null,
  /**
   * Graphic indicator of loading progress
   * @name module:skins/Skin.Skin#$progress
   * @type {external:jQuery} */
  $progress: null,
  /**
   * Current value of the progress bar
   * @name module:skins/Skin.Skin#currentProgress
   * @type {number} */
  currentProgress: -1,
  /**
   * Max value of the progress bar
   * @name module:skins/Skin.Skin#maxProgress
   * @type {number} */
  maxProgress: 0,
  /**
   * The box used to display the main messages of JClic activities
   * @name module:skins/Skin.DefaultSkin#msgBox
   * @type {module:boxes/ActiveBox.ActiveBox} */
  msgBox: null,
  /**
   * The `div` DOM object where `msgBox` is located
   * @name module:skins/Skin.DefaultSkin#$msgBoxDiv
   * @type {external:jQuery} */
  $msgBoxDiv: null,
  /*
   * An HTML `canvas` object created in `$msgBoxDiv`
   * @name module:skins/Skin.DefaultSkin#$msgBoxDivCanvas
   * @type {external:jQuery} */
  $msgBoxDivCanvas: null,
  /**
   * Main panel used to display modal and non-modal dialogs
   * @name module:skins/Skin.Skin#$dlgOverlay
   * @type {external:jQuery} */
  $dlgOverlay: null,
  /**
   * Main panel of dialogs, where relevant information must be placed
   * @name module:skins/Skin.Skin#$dlgMainPanel
   * @type {external:jQuery} */
  $dlgMainPanel: null,
  /**
   * Bottom panel of dialogs, used for action buttons
   * @name module:skins/Skin.Skin#$dlgBottomPanel
   * @type {external:jQuery} */
  $dlgBottomPanel: null,
  /**
   * Element usually used as header in dialogs, with JClic logo, name and version
   * @name module:skins/Skin.Skin#infoHead
   * @type {external:jQuery} */
  $infoHead: null,
  /**
   * Iconic button used to copy content to clipboard
   * @name module:skins/Skin.Skin#$copyBtn
   * @type {external:jQuery} */
  $copyBtn: null,
  /**
   * Iconic button used to close the dialog
   * @name module:skins/Skin.Skin#$closeDlgBtn
   * @type {external:jQuery} */
  $closeDlgBtn: null,
  /**
   * OK dialog button
   * @name module:skins/Skin.Skin#$okDlgBtn
   * @type {external:jQuery} */
  $okDlgBtn: null,
  /**
   * Cancel dialog button
   * @name module:skins/Skin.Skin#$cancelDlgBtn
   * @type {external:jQuery} */
  $cancelDlgBtn: null,
  /**
   * Value to be returned by the dialog promise when the presented task is fulfilled
   * @name module:skins/Skin.Skin#_dlgOkValue
   * @type {object} */
  _dlgOkValue: null,
  /**
   * Value to be returned in user-canceled dialogs
   * @name module:skins/Skin.Skin#_dlgCancelValue
   * @type {object} */
  _dlgCancelValue: null,
  /**
   * Flag indicating if the current dialog is modal or not
   * @name module:skins/Skin.Skin#_isModalDlg
   * @type {boolean} */
  _isModalDlg: false,
  /**
   * Div inside {@link module:skins/Skin.Skin#$dlgOverlay $dlgOverlay} where JClicPlayer will place the information to be shown
   * @name module:skins/Skin.Skin#$reportsPanel
   * @type {external:jQuery} */
  $reportsPanel: null,
  /**
   * The basic collection of buttons that most skins implement
   * @name module:skins/Skin.Skin#buttons
   * @type {object} */
  buttons: {
    'prev': null,
    'next': null,
    'return': null,
    'reset': null,
    'info': null,
    'help': null,
    'audio': null,
    'about': null,
    'fullscreen': null,
    'close': null
  },
  /**
   * The collection of counters
   * @name module:skins/Skin.Skin#counters
   * @type {object} */
  counters: {
    'actions': null,
    'score': null,
    'time': null
  },
  /**
   * The collection of message areas
   * @name module:skins/Skin.Skin#msgArea
   * @type {object} */
  msgArea: {
    'main': null,
    'aux': null,
    'mem': null
  },
  /**
   * The {@link module:JClicPlayer.JClicPlayer JClicPlayer} object associated to this skin
   * @name module:skins/Skin.Skin#player
   * @type {module:JClicPlayer.JClicPlayer} */
  player: null,
  /**
   * The {@link http://projectestac.github.io/jclic/apidoc/edu/xtec/jclic/PlayStation.html|PlayStation}
   * used by this Skin. Usually, the same as `player`
   * @name module:skins/Skin.Skin#ps
   * @type {module:JClicPlayer.JClicPlayer} */
  ps: null,
  /**
   * Counter to be incremented or decremented as `waitCursor` is requested or released.
   * @name module:skins/Skin.Skin#waitCursorCount
   * @type {number} */
  waitCursorCount: 0,
  //
  // Buttons and other graphical resources used by this skin.
  //
  /**
   * Main styles
   * @name module:skins/Skin.Skin#basicCSS
   * @type {string} */
  basicCSS: basic_namespaceObject,
  /**
   * Waiting screen styles
   * @name module:skins/Skin.Skin#waitAnimCSS
   * @type {string} */
  waitAnimCSS: waitAnim_namespaceObject,
  /**
   * Animated image displayed while loading resources
   * Based on Ryan Allen's [svg-spinner](http://articles.dappergentlemen.com/2015/01/13/svg-spinner/)
   * @name module:skins/Skin.Skin#waitImgBig
   * @type {string} */
  waitImgBig: waitImgBig_namespaceObject,
  /**
   * Animated image displayed while loading resources (small)
   * @name module:skins/Skin.Skin#waitImgSmall
   * @type {string} */
  waitImgSmall: waitImgSmall_namespaceObject,
  /**
   * Reports screen styles
   * @name module:skins/Skin.Skin#reportsCSS
   * @type {string} */
  reportsCSS: reports_namespaceObject,
  //
  // Icons used in buttons:
  //
  /**
   * Icon for 'close dialog' button
   * @name module:skins/Skin.Skin#closeDialogIcon
   * @type {string} */
  closeDialogIcon: closeDialogIcon_namespaceObject,
  /**
   * Icon for 'ok' button
   * @name module:skins/Skin.Skin#okDialogIcon
   * @type {string} */
  okDialogIcon: okDialogIcon_namespaceObject,
  /**
   * Icon for 'copy' button
   * @name module:skins/Skin.Skin#copyIcon
   * @type {string} */
  copyIcon: copyIcon_namespaceObject,
  /**
   * JClic logo
   * @name module:skins/Skin.Skin#appLogo
   * @type {string} */
  appLogo: appLogo_namespaceObject,
  /**
   * Screen sizes (width and height) below which will half sized elements will be used
   * @name module:skins/Skin.DefaultSkin#halfMedia
   * @type {object} */
  halfMedia: { width: 376, height: 282 },
  /**
   * Screen sizes (width and height) below which will two-thirds sized elements will be used
   * @name module:skins/Skin.DefaultSkin#twoThirdsMedia
   * @type {object} */
  twoThirdsMedia: { width: 420, height: 315 },
});

/* harmony default export */ const skins_Skin = (Skin);

;// CONCATENATED MODULE: ./src/media/icons/generic.svg
const generic_namespaceObject = "<svg height=\"48\" viewBox=\"0 0 48 48\" width=\"48\" xmlns=\"http://www.w3.org/2000/svg\">\n  <path d=\"M28.8 12L28 8H10v34h4V28h11.2l.8 4h14V12z\" />\n</svg>\n";
;// CONCATENATED MODULE: ./src/media/icons/audio.svg
const audio_namespaceObject = "<svg fill=\"#000000\" height=\"48\" viewBox=\"0 0 24 24\" width=\"48\" xmlns=\"http://www.w3.org/2000/svg\">\n  <path d=\"M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z\" />\n</svg>\n";
;// CONCATENATED MODULE: ./src/media/icons/mic.svg
const mic_namespaceObject = "<svg fill=\"#000000\" height=\"48\" viewBox=\"0 0 24 24\" width=\"48\" xmlns=\"http://www.w3.org/2000/svg\">\n  <path d=\"M12 14c1.66 0 2.99-1.34 2.99-3L15 5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.3-3c0 3-2.54 5.1-5.3 5.1S6.7 14 6.7 11H5c0 3.41 2.72 6.23 6 6.72V21h2v-3.28c3.28-.48 6-3.3 6-6.72h-1.7z\" />\n</svg>\n";
;// CONCATENATED MODULE: ./src/media/icons/movie.svg
const movie_namespaceObject = "<svg fill=\"#000000\" height=\"48\" viewBox=\"0 0 24 24\" width=\"48\" xmlns=\"http://www.w3.org/2000/svg\">\n  <path d=\"M18 4l2 4h-3l-2-4h-2l2 4h-3l-2-4H8l2 4H7L5 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V4h-4z\" />\n</svg>\n";
;// CONCATENATED MODULE: ./src/media/icons/music.svg
const music_namespaceObject = "<svg fill=\"#000000\" height=\"48\" viewBox=\"0 0 24 24\" width=\"48\" xmlns=\"http://www.w3.org/2000/svg\">\n  <path d=\"M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z\" />\n</svg>\n";
;// CONCATENATED MODULE: ./src/media/icons/url.svg
const url_namespaceObject = "<svg fill=\"#000000\" height=\"48\" viewBox=\"0 0 24 24\" width=\"48\" xmlns=\"http://www.w3.org/2000/svg\">\n  <path d=\"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z\" />\n</svg>\n";
;// CONCATENATED MODULE: ./src/media/MediaContent.js
/**
 *  File    : media/MediaContent.js
 *  Created : 13/04/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */

/* global Image */












/**
 * This object contains a description of any multimedia content (sound, video, MIDI, voice
 * recording..) or special actions (jump to another point in the sequence, link to an URL, etc.)
 * associated to an {@link module:boxes/ActiveBox.ActiveBox ActiveBox} object.
 */
class MediaContent {
  /**
   * MediaContent constructor
   * @param {string} type - The type of media. Valid values are: `UNKNOWN`, `PLAY_AUDIO`, `PLAY_VIDEO`,
   * `PLAY_MIDI`, `PLAY_CDAUDIO`, `RECORD_AUDIO`, `PLAY_RECORDED_AUDIO`, `RUN_CLIC_ACTIVITY`,
   * `RUN_CLIC_PACKAGE`, `RUN_EXTERNAL`, `URL`, `EXIT` and `RETURN`
   * @param {string} [file] - Optional parameter indicating the media file name
   */
  constructor(type, file) {
    this.type = type;
    if (file)
      this.file = file;
  }

  /**
   * Loads the MediaContent settings from a specific JQuery XML element
   * @param {external:jQuery} $xml
   */
  setProperties($xml) {
    attrForEach($xml.get(0).attributes, (name, val) => {
      switch (name) {
        case 'type':
          this.type = val;
          break;
        case 'file':
          this.file = nSlash(val);
          break;
        case 'params':
          this.externalParam = nSlash(val);
          break;

        case 'pFrom':
          this.absLocationFrom = val;
          break;

        case 'buffer':
          this.recBuffer = Number(val);
          break;
        case 'level':
        case 'from':
        case 'to':
        case 'length':
          this[name] = Number(val);
          break;

        case 'px':
        case 'py':
          if (this.absLocation === null)
            this.absLocation = new Point(0, 0);
          if (name === 'px')
            this.absLocation.x = Number(val);
          else
            this.absLocation.y = Number(val);
          break;

        case 'stretch':
        case 'free':
        case 'catchMouseEvents':
        case 'loop':
        case 'autostart':
          this[name] = getBoolean(val);
          break;
      }
    });
    return this;
  }

  /**
   * Gets a object with the basic attributes needed to rebuild this instance excluding functions,
   * parent references, constants and also attributes retaining the default value.
   * The resulting object is commonly usued to serialize elements in JSON format.
   * @returns {object} - The resulting object, with minimal attrributes
   */
  getAttributes() {
    return getAttr(this, [
      'type', 'file', 'externalParam',
      'absLocation', // -> AWT.Point
      'absLocationFrom', 'recBuffer',
      'level|1', 'from', 'to', 'length',
      'stretch', 'free', 'catchMouseEvents', 'loop', 'autostart'
    ]);
  }

  /**
   * Reads the properties of this MediaContent from a data object
   * @param {object} data - The data object to be parsed
   * @returns {module:media/MediaContent.MediaContent}
   */
  setAttributes(data) {
    return setAttr(this, data, [
      'type', 'file', 'externalParam',
      { key: 'absLocation', fn: Point },
      'absLocationFrom', 'recBuffer',
      'level', 'from', 'to', 'length',
      'stretch', 'free', 'catchMouseEvents', 'loop', 'autostart',
    ]);
  }

  /**
   * Compares this object with another MediaContent.
   * @param {module:media/MediaContent.MediaContent} mc - The Media Content to compare against to.
   * @returns {boolean} - `true` when both objects are equivalent.
   */
  isEquivalent(mc) {
    return this.type === mc.type &&
      (this.file === mc.file ||
        this.file !== null && mc.file !== null &&
        this.file.toLocaleLowerCase() === mc.file.toLocaleLowerCase()) &&
      this.from === mc.from &&
      this.to === mc.to &&
      this.recBuffer === mc.recBuffer;
  }

  /**
   * Gets a string representing this media content, useful for checking if two different elements
   * are equivalent.
   * @returns {string}
   */
  getDescription() {
    let result = `${this.type}`;
    if (this.file)
      result = `${result} ${this.file}${this.from >= 0 ? ` from:${this.from}` : ''}${this.to >= 0 ? ` to:${this.to}` : ''}`;
    else if (this.externalParam)
      result = `${result} ${this.externalParam}`;
    return result;
  }

  /**
   * Returns a simplified description of this media content. Useful for accessibility methods.
   * @returns {string}
   */
  toString() {
    return `${this.type}${this.file ? ` ${this.file}` : ''}`;
  }

  /**
   * Returns an image to be used as icon for representing this media content.
   * @returns {external:HTMLImageElement}
   */
  getIcon() {
    let icon = null;
    switch (this.type) {
      case 'PLAY_AUDIO':
      case 'PLAY_RECORDED_AUDIO':
        icon = 'audio';
        break;
      case 'RECORD_AUDIO':
        icon = 'mic';
        break;
      case 'PLAY_VIDEO':
        icon = 'movie';
        break;
      case 'PLAY_MIDI':
        icon = 'music';
        break;
      case 'URL':
        icon = 'url';
        break;
      default:
        icon = 'generic';
        break;
    }
    return icon ? MediaContent.ICONS[icon] : null;
  }
}

Object.assign(MediaContent.prototype, {
  /**
   * The type of media. Valid values are: `UNKNOWN`, `PLAY_AUDIO`, `PLAY_VIDEO`,
   * `PLAY_MIDI`, `PLAY_CDAUDIO`, `RECORD_AUDIO`, `PLAY_RECORDED_AUDIO`, `RUN_CLIC_ACTIVITY`,
   * `RUN_CLIC_PACKAGE`, `RUN_EXTERNAL`, `URL`, `EXIT` and `RETURN`
   * @name module:media/MediaContent.MediaContent#type
   * @type {string} */
  type: 'UNKNOWN',
  /**
   * The priority level is important when different medias want to play together. Objects with
   * highest priority level can mute lower ones.
   * @name module:media/MediaContent.MediaContent#level
   * @type {number} */
  level: 1,
  /**
   * Media file name
   * @name module:media/MediaContent.MediaContent#file
   * @type {string} */
  file: null,
  /**
   * Optional parameters passed to external calls
   * @name module:media/MediaContent.MediaContent#externalParams
   * @type {string} */
  externalParam: null,
  /**
   * Special setting used to play only a fragment of media. `-1` means not used (plays full
   * length, from the beginning)
   * @name module:media/MediaContent.MediaContent#from
   * @type {number} */
  from: -1,
  /**
   * Special setting used to play only a fragment of media. `-1` means not used (plays to the end
   * of the media)
   * @name module:media/MediaContent.MediaContent#to
   * @type {number} */
  to: -1,
  /**
   * When `type` is `RECORD_AUDIO`, this member stores the maximum length of the recorded
   * sound, in seconds.
   * @name module:media/MediaContent.MediaContent#length
   * @type {number} */
  length: 3,
  /**
   * When `type` is `RECORD_AUDIO`, this member stores the buffer ID where the recording
   * will be stored.
   * @name module:media/MediaContent.MediaContent#recBuffer
   * @type {number} */
  recBuffer: 0,
  /**
   * Whether to stretch or not the video size to fit the cell space.
   * @name module:media/MediaContent.MediaContent#stretch
   * @type {boolean} */
  stretch: false,
  /**
   * When `true`, the video plays out of the cell, centered on the activity window.
   * @name module:media/MediaContent.MediaContent#free
   * @type {boolean} */
  free: false,
  /**
   * Places the video window at a specific location.
   * @name module:media/MediaContent.MediaContent#absLocation
   * @type {module:AWT.Point} */
  absLocation: null,
  /**
   * When {@link module:media/MediaContent.MediaContent#absLocation} is not `null`, this field indicates from where to
   * measure its coordinates. Valid values are: `BOX`, `WINDOW` or `FRAME`.
   * @name module:media/MediaContent.MediaContent#absLocationFrom
   * @type {string} */
  absLocationFrom: null,
  /**
   * `true` when the video window must catch mouse clicks.
   * @name module:media/MediaContent.MediaContent#catchMouseEvents
   * @type {boolean} */
  catchMouseEvents: false,
  /**
   * Whether to repeat the media in loop, or just one time.
   * @name module:media/MediaContent.MediaContent#loop
   * @type {boolean} */
  loop: false,
  /**
   * When `true`, the media will automatically start playing when the associated {@link module:boxes/ActiveBox.ActiveBox ActiveBox}
   * become active.
   * @name module:media/MediaContent.MediaContent#autoStart
   * @type {boolean} */
  autoStart: false,
});

/**
 * Default icons for media types.
 * @type {object} */
const ICONS = {
  generic: generic_namespaceObject,
  audio: audio_namespaceObject,
  movie: movie_namespaceObject,
  mic: mic_namespaceObject,
  music: music_namespaceObject,
  url: url_namespaceObject,
};

/**
 * Collection of icon {@link external:HTMLImageElement} objects
 * @name module:media/MediaContent.MediaContent.ICONS
 * @type {object} */
MediaContent.ICONS = {};

// Load the icons
external_jquery_default().each(ICONS, (key, value) => {
  const img = new Image();
  img.src = svgToURI(value);
  MediaContent.ICONS[key] = img;
});

/* harmony default export */ const media_MediaContent = (MediaContent);

;// CONCATENATED MODULE: ./src/media/EventSoundsElement.js
/**
 *  File    : media/EventSoundsElement.js
 *  Created : 01/04/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */

/* global Audio */





/**
 * The EventSoundsElement object contains the description of a specific sound to be played when
 * one of the JClic events are fired.
 * For a full list of the JClic events see: {@link module:media/EventSounds.EventSounds EventSounds}
 */
class EventSoundsElement {
  /**
   * EventSoundsElement constructor
   * @param {string} id - The identifier of this media sound
   * @param {string} [file] - An optional file name or URL containing the sound data
   */
  constructor(id, file) {
    this.id = id;
    if (file) {
      if (startsWith(file, 'data:'))
        this.audio = new Audio(file);
      else
        this.file = file;
    }
  }

  /**
   * Reads the properties of this object from an XML element
   * @param {external:jQuery} $xml - The XML element to be parsed
   */
  setProperties($xml) {
    this.file = $xml.attr('file');
    this.enabled = getTriState($xml.attr('enabled'));
    return this;
  }

  /**
   * Gets a object with the basic attributes needed to rebuild this instance excluding functions,
   * parent references, constants and also attributes retaining the default value.
   * The resulting object is commonly usued to serialize elements in JSON format.
   * @returns {object} - The resulting object, with minimal attrributes
   */
  getAttributes() {
    return getAttr(this, [
      `enabled|${DEFAULT}`,
      'file',
    ]);
  }

  /**
   * Reads the properties of this EventSoundsElement from a data object
   * @param {object} data - The data object to be parsed
   * @returns {module:media/EventSoundsElement.EventSoundsElement}
   */
  setAttributes(data) {
    return setAttr(this, data, [
      'enabled',
      'file',
    ]);
  }

  /**
   * Instantiates this audio object
   * @param {module:JClicPlayer.JClicPlayer} ps
   * @param {module:bags/MediaBag.MediaBag} mediaBag
   */
  realize(ps, mediaBag) {
    if (!this.audio && this.player === null && this.file !== null) {
      this.player = new media_ActiveMediaPlayer(new media_MediaContent('PLAY_AUDIO', this.file), mediaBag, ps);
      this.player.realize();
    }
  }

  /**
   * Plays the audio associated to this event
   */
  play() {
    if (this.enabled) {
      if (this.audio) {
        this.audio.currentTime = 0;
        this.audio.play();
      } else if (this.player)
        this.player.play();
    }
  }

  /**
   * Stops playing the audio associated to this event
   */
  stop() {
    if (this.enabled) {
      if (this.audio)
        this.audio.pause();
      else if (this.player)
        this.player.stop();
    }
  }
}

Object.assign(EventSoundsElement.prototype, {
  /**
   * The name of the sound file used by this element
   * @name module:media/EventSoundsElement.EventSoundsElement#file
   * @type {string} */
  file: null,
  /**
   * Whether the sound for this event is enabled or not
   * @name module:media/EventSoundsElement.EventSoundsElement#enabled
   * @type {number} */
  enabled: DEFAULT,
  /**
   * Media player used to play this sound
   * @name module:media/EventSoundsElement.EventSoundsElement#player
   * @type {module:media/ActiveMediaPlayer.ActiveMediaPlayer} */
  player: null,
  /**
   * HTMLAudioElement used to play this sound
   * @name module:media/EventSoundsElement.EventSoundsElement#audio
   * @type {external:HTMLAudioElement} */
  audio: null,
});

/* harmony default export */ const media_EventSoundsElement = (EventSoundsElement);

;// CONCATENATED MODULE: ./src/media/sounds/start.mp3
const start_namespaceObject = "data:audio/mpeg;base64,//NAxAARGk5RdUEQANIEZEBAPGPyIAAYAKMY/6EaQn8hP+c/yEb//kITU7oc9Cf6nPnPoT/8nQhCKEEEnDizkAwM8ThYH1Bj/EAYEhyUGghyivv7fn0vtsLdYI0CiTQE+aaqfH3BW37/80LEFhl6nvZfj1ACplLtsfx19gOQfBp7iHeEWRj8WxiLLI6khikjEI9IvsePycfERCSpPJ9s95IbO1O/tRX70XQiOGX+n+hmeb+aMirKxN/IibInf//G3K9PVym7NoL/W2usCkcMT5T/80DEDBcivuJd0lADkXMLoGxcA7ENhPlAY8LMK280iLkhQq80ojkRQCwz/rEsTjjTlMPMu3RWZ2c3dmONON0NVDzDzDzP79Y9PFg9v//oqi4hHyp+7HGl2b///I8VcYAAls9qrCT1Mv/zQsQKFsrCvlzLRNa/FN/jd/HUrGLUa8tKonzDK8+t55alG5sbKYilBExD8Id1ugmp+eKIdSplGpaoxNZiznEU/J9KJmUsqBzPVjJ/+Aif//71QCdv+gE7f//6gICqPAAci1sbgH8/G//zQMQKFfF2qb9ZaAKU9PlY3uHFsAqAXfgZvyyhtTM2fC1zH/8+tFlslODFHjTHsClFqSTfprRCxdzMcppQ8yHsbbEkzpoLvZFBnWt1GBa/+8se/+SPdQe//FIIsAAAba7YbC65AQAf//NCxA0XMh6xv5OIAEIz0mVENAJ0DbwIQjpGYFNAvTSI1ePBuh+MwYk+xib0DA/K5YQadIk+o0Z0UyLmiv+h5bMD1Ro3/3/TSUggmu/+v/7KNL03CcLAh//5dpCqkltAAAqFFpldqAHI//NAxAwXGl7aXYxoABm/nTyF8EwhIPY/DSOKUIQ2WXUzAlFDQXzyRCXBUNUk33XoqQNhyeltWFUL6CKTImv7/vSZNZw0MP6v/v2oFQ5EUR7/1SVyb//E7FkIn9f9NXWQAg47vXRBbzv/80LEChbaYs5f2IAC9rPHK1z/yygqmvwSoaAGvNLr9jCagdVUGyxOpVqpp79lJPf9ZNEttWXTUvf/9azMUgOcZrZPMThF00d7//v///9SnpUlpJJJJJFeLhp3///yKi4QAHWdrdQE07P/80DEChTJvrI+Ro6Oalhjl3DYQyyMpMHHcIbTFNlqYvp6GKBJBYZ89G+PKyt/Q4oCbx9z9b//80CTA+F3zTlSqOz6G0PoVCIItC3/CnwN/xZAvcr/99VSIAEKz7+UABhWz01LyctXJv/zQsQRE5nOvl4WFHISWA9Ybn87+VaIKzA0kk7n33/KHo6qv1QKoNjMTHtX//ocaRCuGg2MP8jbueS9WIWU3NPcenOEv/CbcsVAKiIkATNv/9QAb60qFitrzbcZQ+ixX7169gCfAOpwHf/zQMQeE+Fasl4T0HJRrdobjyh8XBKr80WAqJQaiQPhY7vmJ4///ppkOhOaLMDbgVOwVdYt0SgqM/4hBQO+qglKQAFQM0aPnrrVvpRJLyCYt2amWVGBpcJrSl6ypI4hgoMQk5Di+Yv3//NCxCkP+IpANGYehC+92dkrPJ/1a+z+3/r/sL/6f+6G7BotKqkVeDWsJLMDPP8pf2a4///Jf+VgHuRkfn85h7MIeAY9RE3ZM3IRTyUaGvCJpep52lDPb0nCY5xRqRkEWzDKgw+8Ftdp//NAxEUS42YhgAhHHAG9ZCQjo0VONppYbQStB6qWUv5f591O8bze0/3y//62eUqnWzSn9vNsnOBzK8TN6urr6bcxGukbeqNZjuyIMO5FREnqzI6SVZVcahzgpCwMa561B4M8zjedy6v/80LEVBI7ViYoCEsdN5b7kv/+Rsub5P/X6yz0/JdhcZdZl+/hII/xFYdTSmc0ck3O0055fkc2R+ZgsyZsEagnMwRqkK1xle//6iZh/ITJmiF/yEKT4QyEKEP8hMQl/mNYxv+hn/lKZyn/80DEZxEbPiWICEc9StmmMZW0r1KXR/qYxnX0UpWMZAxQFqoapnCiQwqxihWDAQEBAQEKE6mZGZGTTMiMjTWZHa/aZkZlTRGXojIzL///////8yP85/5k1lspGrWRyNWCggYME4kGJf/zQsR9EkNiDAAARN1MNUkqTEFNRTMuOTkuNaqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqv/zQMSQDcslQAoAR1mqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq";
;// CONCATENATED MODULE: ./src/media/sounds/click.mp3
const click_namespaceObject = "data:audio/mpeg;base64,//NAxAASsyJgIUEQAY///gX8///yfyHO/8hCEafoRp3nPQgAAEUAABBCEIT//QhCKQhNGyEIQhCNITU5//OQhCN7f/yEZQAAIynOc5CEIhGnABGY/4gAIQZ4h4h4d3Z2Z9Jba5XWhWP/80LEEBhJOxcfiUAC9BEda+oiKFQsViiMpvHFC98pLjySjUNeKoYxMpwIT21HmHlEhx83A9K5vDAuZUQxzq7nJPgEVWKQZ1Iu5oJH3UpGObWV/MfAgLC4Z/yhP/ULKnqHd/syOQenhOL/80DEChZpZs7rzBgAT3bBWub0T/xNtn9nY5bvQdCA0TvnpXNC7EJ3iRPtebJ//7xK4IAqIii2AKbfkBAJxATDLN7wiUGv6VANBNjqQwGCayGoaBAJaNC79/z5wP2IuJbfZsNFgBVo7P/zQsQLF0lGxvRJhlQVDyEmYldHXJGadquTRs6aYmq9VY1hqqt6xmqts2zGTvGNrl+u1IMBHREJREbkpaFQkFRoa2FYSDvBp6DwSf1lgFqfkQ0JcRCYlKxKg0eEw8sKqgaEogGBH3EZpv/zQMQJEyEudaoIBoAf+HV2UBjoOsP2/IwrkezQ1Y4e2wVxgxlVAqDQUSRUBRU6LrBY1lvxEdUBWBIOnZWOCrvlVnTsltWNOqPP4seUBcKgKpW44m3GkHLjaBS4ohHZdTGi6FXXVo6+//NCxBcNYAYyWAhEAJ3U+j3uXdl1z1Du30fCySCGablvUTrhwggLTomAAmrWsmWY9ym89ZcvlwX/zf+a95ZLwXOar/LNrJ60LUl25Hs58yKRWIjSbt9DCIs0UtF/TOlm2cyNTpKysuCB//NAxD0Rw1YliAhHPdmd9nYYQOsGCgAfmqIAXlnhbNZeUBQvyL/y6NlP/r1LLlEiSPL/7lE9SirM5zxZEwCseMDL330yrtl8/8jJs6mt5dTloYsvNSGbmTkYQhpVpRpCG1yr9YSfr1b/80LEURFLZiWQCEc8v/rLXPzys+Z9z8v+H9qyCMpGLn3bla9qtcxYZXk9cbOUjb8t0q2ytz79ImM1R0ht3QdWK11myihIpt8SZBRAlbWq3CDpDKWUte/VHgJDH6k+lsqSPbRj+pHWWrL/80DEZxKjYh2ICIfhxIKhMBeLPjgKlFRIKjCxIKjCukkFAKCSCxFtgTAQFIkisqIg2EngUVFg8FQCQUxBTUUzLjk5LjVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/zQsR3EnAF9kgARgBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVQ==";
;// CONCATENATED MODULE: ./src/media/sounds/actionOk.mp3
const actionOk_namespaceObject = "data:audio/mpeg;base64,//NAxAAT+gKmPUFoAI81KAANYQZECuQAASjAD820006kC+buYDgGEGEKIcsCYAUQYA6JeI2JmS5wcY5yXL6b1IJpp6kG////9X+h/oaaaadAvpvBA5/9QIDQQOQ+cbQllsQQAKTggvn/80LECxdCcupdjFACwA8cFoNFZuosRJUe3E48kEhWIRueePjSdR4T9XMQ4SwB/BZ1GQNAtHHOPzOFryImV2zlb//rZV/6MYp56IY00sPgvi5vp1NN///3Q4ZlSUVV6wAAHLn//b/+Bv3/80DEChbo7s5fmGgA8cDgPEdPslrmVdkwdsV66+p2vZktFECYbF0sxMc6XTyGfU7omIDWqTLdIdocopcSHkqkN/1OLnGEiTI5lQIHz6F//h8+Aw////SWn6Ai////RQCALJttttthGP/zQsQJFgLXBl+PUAJpUBpuDr/a/Bn7vbuBpTSaJu9C26HLGnV05pymMa+52rjwoQl9HX5xkseQEWn/zR+C+CGcTN1IQsr/O/6N///////zyotv//Ulb+WNu/4a/G/DAGASAsBQ86QpAv/zQMQNFyqWqFWaUACorGJ3w70JwQXdB1Iw8FBR6w8BkLlXmCwSQKbRFEDGyFEFw/LiWNeT8eOSG/++3///5oEpv5wrF/RmoYsz////+yuLZ55GT//yosfyqj5gugANMBv///+Bt0Bw//NCxAsWul7hv49QAIAcsuZ3XnIKHgXVwYS+wjbgGuEvA8WjfAsaQmNk2QkZh5517ceH7uZegsm5y///0VTDzzDz09dev/6IIMKcL8i/5CSjE3/oqRMBZpmk7R/RgAAbjwkkcZrZNKRG//NAxAwW4j6pudpoAwwbDspelxARGBQ5l21KTHGz7RkyVSuLZ5l3/S9SQ1CutfuvPzIvF4HUFzRXNkiXJVH+pv//mvMTVRJGyT6S29LRao2Wqj///UbLJxLHVPBVD9SWyADnc5p6REf/80LECxb6Uoxe3A7SY0MyGLYtINLEx4dXVEEvywRGZ7pcZEtrkjRpam6yOArCCRZNX/W3WOoGKq04z/0I/nt/UCYZf6GfovMahvTn21oZ7KnY4oNhuRFQuLsBID8cKC5qSQAC9j29EzH/80DECxNZYoT+xuAyRLbuBA8WRBNAN0Eq+mboAV7G62xjgCvi7cM0Ov1kOELDyoy/75RGdB8iaMZJ//S9SaPWe8oonsV4o5NO40K5FG2xNQZo78WcFOwcZjQQYvlIW6mGkh0f0ZiOBv/zQsQYE8jiVBDfVogDF7hUFzGQhTgpeTFkKEeXlL8syjVHZ03ZCDR2nSxR7Pq7np3LRaHB9adBZ07r018kdy3tjTX1KiSqekjtoMGlaAKNEYCZkOHzpZziA0FmwmEDZhMwfvxGWFAY3P/zQMQkE5DaRAjW1ohECprRK1TRrKRtJsNpyJrNfLvndF7g+gSnAyt351B5obyX8r/u//////rqgBmlYGs01hNdBQpEQyNoHhEMuUtgytPS01oLy0hu6NVNabzryYxwzfIqvKPaRFls//NCxDAQ+FYw8gjSKH7tHbMxfJlUtVpIB16SI0SEXBsf68/+/L//zfLll/nmj7F/1pcpZ/+Z3Ur5Eq5WpbM9MfPljxeb9Lamv/nXIuOSkVXJVRmzRxLpVUlMiBhOahamKCgmCgSwVXHX//NAxEgRU1YcAABGvSNI0Nzzp5SNpUj5aE3ZUqAvIkhEnnq1D3/yxFqrceAgEVIho8WKlhKVGBUJHjzvOh0JndVbtdYykkFQmdDoaDqCIaLKTEFNRTMuOTkuNaqqqqqqqqqqqqqqqqr/80LEXRFYBf5ICEYAqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqo=";
;// CONCATENATED MODULE: ./src/media/sounds/actionError.mp3
const actionError_namespaceObject = "data:audio/mpeg;base64,//M4xAAUuVJUAUgYARcXFz4DgFAeKHAeChiIie7u+iaIibgYuAYGcTz3OIhf/Xd38v+J6J7u+gGBiw8P8PDw8PDHRw8/+O6GADo/h78BEQz8HAHh5+v+A4A6H/8AAEfIiZmZBXlicwVCsWj1//M4xAwYWvL/H4goAHY5EADTzSBEDUpfz/OhTMPGC+NAMWAgfAcAgHFSjhZD1PCRAUQFBjMUxMhGGuOVyndnXzvlH2dGLp+jbHsUykMTTFkX/+ror2841v+k//+MIOdv/GUVmvrpkGSqAYta//M4xAkXMsLmN89oAg/iwxc/bCcqY374+ZYv8ms1WUWQHQlTUFCJgbIjvMcd6K1m71G+ttB9Pt32bR6OptTZxtV0l/ov20P3b9/1/1f0dSCkh7FjKTdSRbQKiRLyBKFroXi7uP0CAvGOAWNk//M4xAsXwr7a/mPUwS+O1HXtgEWD0qvqiuk8xOG4QoqkAU5eFUIMYl8WHoK3Hcq2dx5p5fTjLvlFtLucF2SuaciHhslc4JhNnm5XU2pCS6c3n6+3/9GyFsk+xwWUQmSTumm7e5ggAEWsUBor//M4xAsXCrLXHntO7NUoPTkrtfAzt+Vmc1QDhdvOk4mMiMaxzG9AERpgbNKfJVp0/lfOvjfl9SWj5XpoXfIYVep7R0WTaUAGDj1IkMHy1Oyrfnfq2e37/22fJduLdKpFmVawABglJaFVG03L//M4xA0XurK+5HnLTJeQXpCP4L6DAO1L6jOnPOCx/wVBu4nAIHEgOCbXJbP5R/74hGiwND1iw7BYtTsqM6viJ1aoa14o/kdXwsdo2K6nxravl7al1/t+rUDz4J+IDtW7bbVAX+3gDwiUL8lI//M4xA0Xgq7qVnoO+zaBvGmHeGt1WGsEPh7RWPKQT82FEhiWLGeUlRHjRERFE6UUhhATy9J5Lcv+PM+axpVIkaHDqqvi+yUHdjW3sp2vTv+rav9F/Kt+Lm9QJFdnwrvt7SXHLLMAFKoGoNaO//M4xA4UurLyXkDFT5XYo5iQ9ckoWFh61037WowPpb5NVRWlrUmVVqxmNV/b6q+xuJVfY1VVXfDHvnL7TGOFMb6ifdZf0etaP//lZH6FbyuK5MUAYWLKUvoamjS5tZpdNnrWz2ASUXdsckcS//M4xBoUcVJ4IisMydfHkiAUZzmoyajzSOzOf1T9qlFq+ORkFFeC//HxXOxf/PKPG/CNxYO4+WKbl+Lv4VBQU6KKhP/K/+vK3+WXVv/9SobSZ1b/lb9SshjN9S/Upahjf/LMahjv6qx/DpAR//M4xCcS40IEABDN5DMaqqrVVVjWLGPjH7GpWZ/7dqr47Eq/7HQds4duAxGfzkjUTpoLSIv///qn///YxTAwQIGhyP/u7O/3P2eqNZ2k4so4sp2NFAYhnZ2couBNTEFNRTMuOTkuNVVVVVVV//M4xDoKqz1wDACNy1VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV";
;// CONCATENATED MODULE: ./src/media/sounds/finishedOk.mp3
const finishedOk_namespaceObject = "data:audio/mpeg;base64,//NAxAAQiXIEAUIQAPnfO/OdyAYGehP/U5Gqd+c/8785zoBi3QhCMpCVP+SpwM6AYGODH/8TvB+sPiMP5cMCcPygIAg7/lAff4IAgcBCD6ofD4diQbC0WaISi0SB3EAzA8WZgeALXg3/80LEGBoDGyZfglACgsRODRuWFcnMLm+eQEhRVQz5IePy5Icm/2Yn5GLY58hG3/J0JyAkq54WhVHosmkTmr//OYkIx+aejta5yObVf////fbcgJP/8oP//L/+w6tzSgKyRVuaO6jleQb/80DEDBdLJs4/2FABfMefV3NU1/Pu+MiMj5TGccdZM7mtR9poqDaj269WQ7clU5//OzTSgSRYFoL8eoeaaxhw+u9lq/9jn/NY7/3VPohqW+///////5ELQ+cqSm8F1QfSAHmkZP3Rz//zQsQJFgHCul9ZUACtuzlS2auXefrUxQUkTU+etjYpBz++SrehymLQlDIbPScu+uppsoFMTf/5uSiO7kpKKo1ONQ6/NbKkDv8iJj3OE/xEHRQl1Hv//4UPLBeWtoFTaaAttttstQEAgP/zQMQNF1PXDl+BUAJQhUAPuz0DJsKELcVBuf+NDz79ceCoSE/meeYSBfk6fQt91kZOYYxE3/+2YwtnyQxn////0JHMY+w/H5OSN/////zDGf5+p7///////kjSQxXTFGTyENw7gapG//NCxAoVUeLUAYKYABCegFrFga4BpxsoJJHKbdSSNc9rTRNTiRTtofSWUkUt1o19fWkoiIJAGaRYixFlM4yQ2FK7pDOlX6q0Ty0TFQNc910f521f//sEw5VqWAAa0xN/4IJysXXPUXWj//NAxBAYQc7CX9RQAD7L1moNjonkAxWFww4nWd9JCeciFDR6QsKgKiayKccZU7pWdi9jnzTd7C9HzWNZFE6VNY70udouzEPUInt/WdLG0YKntR5SDn/rBWjQpBIJjCnEADG403RAjmT/80LEChYx1rpfU2gCXkzXRRXSZBTHSfAUM4JVGmSJvr92ZalqJzOtY1C+n3qXd7ojHpJVph9KfTv2QF00S62UsnjyUkk+pbH0Uf+akuloBUN9eziVT/Kbf//1pSuJ/YIvIGDjaERizGT/80DEDRciBtzLgWgAnyaG0C1lwTMAJBpi0QiX27oskt/p2pJGx1aanoWQ9R1FMw1JVmtN1vSNE2ZKcL4kwhTIv+7hPkVpum9/54qQNoCB5od9Wc/WVZltv//9olVqRkBpkMgFbWp6pf/zQsQLFGGq0jfYOAJYZ33eO8O4ay/WUDUrPXKa0BSIWhEPEua1Jvfvd1CxL/0T7nGsppoSEjjaf6tN1ZTTR0SRqRO/+K/Ou/9CwVOnmrcSdMqBpY56yFdrrd+BUSsXF/De07+HriXkC//zQMQVEyIO7l9IOAINDw83zXmx47coMuc54Km6W6HL5VI1dHUoFS9CrJ/FZBL1apo8Bec67a3b/1JDQt4iEv/niXtWlQKNhcSXFrNXq9RoxmJPGjO8N0UWAZDR6hQZVGYs4HkcGtuz//NCxCMcqvMKX4VQAp6GEjERDVO0nICRTDDitdHYkPnkRhZTDzS5o/yvFTPc9GLCuTkX7OXt7fseehISK578TUFArC8lNQ06n//2Gg/Jy48bb9TWcmmH//93/Fyy29rQUkjgEwC74QXH//NAxAwTWb76X8xoAtGYil8Sf13FyrazOOzs66VgJUPYvJbKXWr+myS2SrPPf1KWiiiyOpLSWjRTZFlalf//omqn///Bl/gqd4NSP1sCtUboQAq2KfAZcuompqTyWlosplpidkw4Y4D/80LEGRRiJrZdUqAAgAJMBywG+KiSmxrWtlKfMj6SV386x0gTt/1OtvvS0CizI+umWkl/XUbP1ESayKkktX93dfzztT61SAEkgBQEjccjkciAYAa39zxcaPCYCFY9Q550fgIUwErGSDn/80DEIxwS+tZfhWgDSkw83gvvZTK1Iko2tI9rLpf1mZ+b1tMy4Nm06mXyUQY9ZLXyQUJTs9RmYhzjd0y+bppJEj+8v/+81fqQYzTN1ppIW/////+pA0UgaXaVuC5FVLzhMlMyKAyi3P/zQsQNF/I62AGBiABLhOwsg1FMBUmAa4LK0kU0GslRZGmpJb+3on0EzNJjN/Rt+6CJfdTUtj6KkvV+iRcjyBCdC2XzhNFUvstzFYtImJ1Ff9ZRIj59h0HQICe1It//pYprEApJJFaBDP/zQMQJFHJu5l/GaALvVEYd0Zlq2t/CXLznyPVFYKIeRsUnRSrZNn/r6CnqdQ5i8i3q1bKfpGtS0UV2JMeKP6knf2Nf0VaLGLbf//rR0WRKyF4MhrBplw9IE232uwC4QyFzCiYsW86d//NCxBIT0nLqXgpUxo9sRW7llTyJzaqvmIaPi3VgsG/mt9ykwfCQIU3OOY04ehw7/ppOC+OfQ45TbwRmsdOf9V//3NEgtEX//4aVAAFRFv32vuC0ePWVlkuksMhlhMTeSZcTTa6TL1tX//NAxB4T0m7aXgNUnlF5nDuaJdERvfmX6mCXNcKxO/V1USAU/9yGy3Aqp/1gZFJn/1f/82RAAwvUf/9n/4aVAAEIF91+vwCeBTp6TCmP9INghMQii720i+pAnlzzrUX1IHQtju2swb//80LEKRQCbtJeAJqGnOo/ai6SKYMAWbN+pyk9BZgJk//uSoi1brV+z//mZmmHNKZ13/4fAAEADstllgF/v972towZ0QXK8AA+PC5cN0PRTdbHW9k5M9zgqso/zibfk+1ZC/skJF/61jz/80DENROyfrpeA9qODemqMKr/rUHwRS1Nq9SKD//rZIcRZmT//kUEALSZ3D//6vAmzqOlAm8FwxbwFiX8VRMT/DEsPCqRbOw8Q1mIxxtBkkSi3qAOVm6F2/FRWYSyB/bF4bP/YoK6TP/zQsRBE7JuiRpulMRYCzO1V/Bgm+3///oVNQABURf9/bgBP/8U9MW42GQb/AyP4bURvzzGIYvAhJL0x3ooCTlFLZYWlmfqPt+PdVErEQz3RZKDyTFf60vWSP/2GMeX/qsr/+oxmB0RAP/zQMROEzJqxl4CWpcBmBvv9vwBTX/L98zdfopM4GlbpJtgUn1eHHhe8yxjmqcdp+upQEuTdtU3X9x6VTAMv2qIoiG/VYg/GN7/nhJgfH2Qf0qSKab/9STkueh1IDkmklAH5fflAZLq//NCxFwT8m7CXgPall7BM4igvw7JyAbmlbrY2Zmc95UkokD/dw4U/VNjZq2TcStZukKgZTDVrng8v/mRTZa8Yre35WIl+v9boo3/1pprJU2wFQAyBI5tJABr9/77Z/CdRCLoRWqEYrN6//NAxGgUEnKcfgPaq4nSU+eNbpg1JSTemhOK12Eir1L/WdGRPphACdmzWMj7GIgg/nV/2MkNzYiH1f+MUXviFwhf5ESNESoACMgKy22UAf/oZWmPclPEoiClH5cGwN0IZce9FABAWFr/80LEchQJ8p2+BhqSJMm0Y97b+IcHG7exHP1o1ozptGFJY96zeDFv2jvm5WapBNLZ6npCx39f9//xJxaUAGauYYNH0NxP49ytAzAugiwASDuCaDUpRXKKAro0F7oKjNigqK2bCimismz/80DEfRPCbrJeUYsW2bJs07zhUJE83J52vOGiuPNiokv/+//8tONhddJC82Fk8VX//+//+L/+X8vgX38/zyBLzXnwocMyMyN5mLPJsiIzhs/AZfSMyzTJX/zT7ykZlXbe+/dxn2i68f/zQsSJFBiqZBYAXknZ3GPTCDzzqqXjKRMJwaRC8G6IQU2nG4n4GGmXKsyZrv9S/Pz0LNbNUKz3/+L//YfmT5sn3CfNUKp/vzCv+a/PzXF+sMhBLEGQyJlrOq0Ao4kKJILAayo7MqEZp//zQMSUEvNmFAAIzcjp0sip/9jKz0mW6zFUj/RP6r+xkUjlR2Mj/dbbIrGRyodjWKh2MrGEVYys5TKUSGhweBQ8NIQysZWMrlRxEYLh0SRVTEFNRTMuOTkuNVVVVVVVVVVVVVVVVVVV//NCxKMQi2IeUAhHXVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//NAxLwR22HQAAgKnVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVU=";
;// CONCATENATED MODULE: ./src/media/sounds/finishedError.mp3
const finishedError_namespaceObject = "data:audio/mpeg;base64,/+MgxAAT5BX8AUEoAP///mNkc/////1Oc/6noc/9f///85/0O///r/kI2jf+pCf/Of/6HP/znOc7znPkIQgfFzvIRjhwOChCEIQOB8Ph853yHOc/zvEA4AAAAABF/UgSPmQKhhYBw4f/4yLECxVpXpgBmYgAKgCEXoz6Bj24G4gxlPDKhgAUoFxwtiGufjWFsGbKgF+Fh4noT/8i5uaFcZgLm1i2k0Mbam8ZAiwbYX0nExHIEEx2FBBP9J3S5vA6wAAltAA+pUwHS9e7B4EtiwD/4yDEERexdr1fz2ABlQrFTFPgXqqjQRzMFqGEeDUkEbrrMjtB+lU/tcuj+umyBDN1q/2GlFesgKLdHTqWo7RktruiRwdRlfa8J/BPRN+XHtgb0Y/AzC/2cZdiQgBuTa69W4S8bMAAXP/jIsQNF0k6wVZ5xSYzp4BvjV+T2Udd8R2+On01SiRpX5PGv6QjYpD1nBt8VZ0skMc9QHq1CpqJlnhoqVPKPHZYGqnIypEyWPAo8SPz0OhX//QJmyvHu/o8qM/6CtXSAhKu34FZMGcPy//jIMQLFcmeyX5pRy5R0BZEoNVh/FruKTVBRcR5rUTQpGyFqJx7CzcOcPjqoGcWJjOrcdzfsGXZAsFs2WdUKwcLiEIhWFB7w0GpuTa0XaMGgcqzrQsz/+kNKkIAFLvgP/OonDe+4DCL/+MixA4XgpK9XsKG9sYelKU8J/UGwRrm0l9/tjMjWMAOthrqK45iONNBfxi+hbllz+raE/If6Y91Y8jnb49Kxn0WeTT6ihhKnGOj8LGIiWQHuOogUc/66H/hHf+ZgAISpdgBncq6Fj3n/+MgxAwWYfa9fnqHEiCLPLVweu/9CIz6wGZbXVpry1Kg57ZhtwxXKh82K2giB2guGug/OyF9W1JuQftstdzJ1LPcEKLR5hTreUz/iBxskEVBY+CqAyCgQoz+yuNqlTn/4AmceACjmEH/4yLEDROBjtGfTFACEdnXxxr0lwp2+ghopgB4IjWCiAiL1Fns+pLqPWoKx2ncfG0InzW1JerftHxMpxQ801HHziUMvQeK6+SzxEliW+qFqaEByyhgQELpGQIgqtQ3JzIWch4kp17kEgX/4yDEGxrBdpwBmcgA2HbmH2R4LIKeMtsKwjCc/PT00y9l+qMGDIckAycFqvMfuJz7iPxLEzFQo5sngfD9d/3Lh+njFJYublz8Q5Rf////T2+4Yc+Lz9NurVqf9g+AKTd3AE4qU1E2vP/jIsQLFHFG1N/MMAKBuH8oS/ikp9KqlSqkwegTJgTLjeYlyndKcQSsCSPJJQRk9HC1Mj+l42THqWrK1khp0NFfwKks86SKw6IipGbLX60JBY92Jgpy/gAfjbqATePy62LBPlndI3QLQ//jIMQVEzHK0D5ITaKR7RryvYmOsx1fbM6V2JJnbpavk1iJiS8JPqV6qgWaY6uxhvzoBzN51ktGpofVlW2syZxMO0b3qgp3fgAeIb4DIseOluSeSAlQn7hrzAjZSZuJ1hX4vsT7jPQ//+MixCMTSZ7MPlmQ9/X6VzdY3edjF975aHZclh+kp0dpLevY334aVbI8HpNcncwNu/n4iv+WjdUp78AD9ctNSZuODC31N8HTqGeWmtBbEAMsHqNC8I2hSomoRqXy9S0ceUx3G2Xy1HlX/+MgxDETia7EHnnS35XKZuzIM1elCplWUbSZUyasFtQGBXZtvjOkd7fyKgXdgAP2BBZD9S9RP5NG79jO2pTIwZr7J8G1gzEtzOp2ieBOgOaBuVOqMyrSjT9MjQyjbxO0deP52eZM5EX/4yLEPRPR9rgeeccSHPRatU3MJQt+RHNLSiTFR+5aqgXbiAQBNtgMw1oA6FmGT6BBFIiJwdNzPHg4GwWjwaEZMdZCYHjSgwh4y0x3apZUmcmPvrb6vn+zvD/t5itoX1ejvi2HXytG9Pf/4yDESRRRirQZT1gDn6MGwmcJJfWqPBUiBf4SQhy0VHhgDRhoxv1ZsAhtWpzFYcHZOFihgb4zFC60dOmrlmXJiSomyBZ2YpiZigYKoIYAIGkiMAiwM8MMgCyIACjNhTPqzAnwKNMoKP/jIsRSJSlqhAma0AChCECX2WopEOPhhoiCKtdUFCCgKJA0W01lY2TxupC5HD8td2jhciVYlirC37fwM/kcmq9jHKMSipK977GKSz039KNFCnN8BxNkyKQ7PaifSU06ZWbLXIRrxeNesv/jIMQZFAk6zD/MMAKWQS5DeCUx/Y3lI4WvyH8L5+c/sB9iWul3X4R9zz7SwOgUyMBtTkhABBIUn1CLs///////9YC1KgVL/IbU4pxAdm9RCY22Fl3QDjRdhcbGgh/GwR2i7lo1CmY0/+MixCMT0ZasGMPKX2VNy3/JfvZB7an/a3fEB8Ky4hh6gJUlR8Y0bs8ZsysdHzOS5lQSpSjDL8SjagVdQAPkgaNhAzDy0U7Ny7ewjcdcD9uihn7LI+uRtxwzNFzBvzo+Dh1KUoG4nLxM/+MgxC8TQaK0HnnHLvdpTPyNVqWq8ps87Xc4tp+84odaBg0EhAGhAEm9SAVb+0XZfMCMzNKdBLCfWT9Cl5ZjyQd6VlAraiTVvTti91RulyZBkwXuoV3YXmOkKVn5U0rzPNMp1ltR6t7/4yLEPRQ5lqwYw1ETceczuhocBflPuWRyT5NPfTibxXsKc3HAHohRMAuHFwWYsiboQoSDQaBHij2BTtI1iU2jto6ycFqsuHDPAswsJlcSaDHBypOCRwT6zM81yPX/lTY4KIGgWSGQ4+n/4yDESBLppsg+SYaW///sUgodAxFs3LEahGcMIGORNKMFqJMRseA8gjpVF3QapN5RoQOoQ0DWBwiRkkW4R+n8dpREBICTA00IFzMpEJUo25plEqklOrq6VWSDH6/u3crqCEL0P4bJIP/jIsRXE9ECWADD0lknZeEGlVUAgUCFiDzDzCj4WjRpT2WWWUGKhkz4qKC1QsK/ioqLN9ISFhURmfWKi3//////////QDIVFBIHgZFaTEFNRTMuOTkuNaqqqqqqqqqqqqqqqqqqqqqqqv/jIMRjEaCVZAp5hlCqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq";
;// CONCATENATED MODULE: ./src/media/EventSounds.js
/**
 *  File    : media/EventSounds.js
 *  Created : 01/04/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */





// Use Webpack to import MP3 files







/**
 * The EventSounds objects contains specific sounds to be played when JClic events are fired:
 * - start
 * - click
 * - actionError
 * - actionOk
 * - finishedError
 * - finishedOk
 *
 * The sounds are stored in an array of {@link module:media/EventSoundsElement EventSoundsElement} objects.
 */
class EventSounds {
  /**
   * EventSounds constructor
   * @param {module:media/EventSounds.EventSounds} [parent] - Another EventSounds object that will act as a parent of this one,
   * used to resolve which sound must be played for events when not defined here.
   */
  constructor(parent) {
    if (parent) {
      this.elements = Object.assign({}, this.elements, parent.elements);
      this.enabled = parent.enabled;
    }
  }

  /**
   * Reads the object properties from an XML element
   * @param {external:jQuery} $xml - The XML element to be parsed
   */
  setProperties($xml) {
    this.enabled = getTriState($xml.attr('enabled'), this.enabled);
    $xml.children().each((_n, child) => {
      const id = child.getAttribute('id');
      this.elements[id] = new media_EventSoundsElement(id);
      this.elements[id].setProperties(external_jquery_default()(child));
    });
    return this;
  }

  /**
   * Gets a object with the basic attributes needed to rebuild this instance excluding functions,
   * parent references, constants and also attributes retaining the default value.
   * The resulting object is commonly usued to serialize elements in JSON format.
   * @returns {object} - The resulting object, with minimal attrributes
   */
  getAttributes() {
    return getAttr(this, [
      `enabled|${DEFAULT}`,
      'elements',
    ]);
  }

  /**
   * Reads the properties of this EventSounds from a data object
   * @param {object} data - The data object to be parsed
   * @returns {module:media/EventSounds.EventSounds}
   */
  setAttributes(data) {
    return setAttr(this, data, [
      'enabled',
      { key: 'elements', fn: media_EventSoundsElement, group: 'object' },
    ]);
  }

  /**
   * Instantiates the audio objects needed to play event sounds
   * @param {module:JClicPlayer.JClicPlayer} ps
   * @param {module:bags/MediaBag.MediaBag} mediaBag
   */
  realize(ps, mediaBag) {
    // Values are {EventSoundElement} objects
    external_jquery_default().each(this.elements, (key, value) => value.realize(ps, mediaBag));
  }

  /**
   * Plays a specific event sound
   * @param {string} eventName - The identifier of the event to be played
   */
  play(eventName) {
    if (this.globalEnabled && this.enabled) {
      const sound = this.elements[eventName];
      if (sound && sound.enabled)
        sound.play();
    }
  }
}

/**
 * Audio data for default event sounds
 * @name module:media/EventSounds.EventSounds.MEDIA
 * @type {object} */
EventSounds.MEDIA = {
  start: start_namespaceObject,
  click: click_namespaceObject,
  actionOk: actionOk_namespaceObject,
  actionError: actionError_namespaceObject,
  finishedOk: finishedOk_namespaceObject,
  finishedError: finishedError_namespaceObject,
};

Object.assign(EventSounds.prototype, {
  /**
   * Collection of {@link module:media/EventSoundsElement EventSoundsElement} objects
   * @name module:media/EventSounds.EventSounds#elements
   * @type {object} */
  elements: {
    start: new media_EventSoundsElement('start', EventSounds.MEDIA.start),
    click: new media_EventSoundsElement('click', EventSounds.MEDIA.click),
    actionOk: new media_EventSoundsElement('actionOk', EventSounds.MEDIA.actionOk),
    actionError: new media_EventSoundsElement('actionError', EventSounds.MEDIA.actionError),
    finishedOk: new media_EventSoundsElement('finishedOk', EventSounds.MEDIA.finishedOk),
    finishedError: new media_EventSoundsElement('finishedError', EventSounds.MEDIA.finishedError)
  },
  /**
   * Whether this event sounds are enabled or not
   * @name module:media/EventSounds.EventSounds#enabled
   * @type {number} */
  enabled: DEFAULT,
  /**
   * This attribute is intended to be used at prototype level, to indicate a globally disabled
   * or enabled state.
   * @name module:media/EventSounds.EventSounds#globalEnabled
   * @type {boolean} */
  globalEnabled: true,
});

/* harmony default export */ const media_EventSounds = (EventSounds);

;// CONCATENATED MODULE: ./src/project/ProjectSettings.js
/**
 *  File    : project/ProjectSettings.js
 *  Created : 01/04/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */

/* global window */





/**
 * This class contains miscellaneous settings of JClic projects.
 *
 * In addition to the members of this class, there can be other properties in JClic project files
 * that are not currently loaded:
 * - iconFileName
 * - descriptors
 * - area
 * - level
 * - locale
 * - authors
 * - organizations
 * - revisions
 */
class ProjectSettings {
  /**
   * ProjectSettings constructor
   * @param {module:project/JClicProject.JClicProject} project - The project to which this settings belongs
   */
  constructor(project) {
    this.project = project;
    this.authors = [];
    this.organizations = [];
    this.revisions = [];
    this.languages = [];
    this.locales = [];
    this.description = {};
    this.tags = {};
  }

  /**
   * Reads the ProjectSettings values from a JQuery XML element
   * @param {external:jQuery} $xml - The XML element to parse
   */
  setProperties($xml) {
    let single_description = null;
    const multiple_descriptions = [];

    $xml.children().each((_n, child) => {
      switch (child.nodeName) {
        case 'title':
          this.title = child.textContent;
          break;
        case 'description':
          single_description = getXmlNodeText(child);
          break;
        case 'descriptions':
          external_jquery_default()(child).children().each((_n, desc) => multiple_descriptions.push(parseXmlNode(desc)));
          break;
        case 'author':
          this.authors.push(reduceTextsToStrings(parseXmlNode(child)));
          break;
        case 'organization':
          this.organizations.push(reduceTextsToStrings(parseXmlNode(child)));
          break;
        case 'revision':
          const revision = reduceTextsToStrings(parseXmlNode(child));
          if (revision.date)
            revision.date = parseOldDate(revision.date);
          this.revisions.push(revision);
          break;
        case 'language':
          this.languages.push(cleanOldLanguageTag(child.textContent));
          break;
        case 'eventSounds':
          this.eventSounds = new media_EventSounds();
          this.eventSounds.setProperties(external_jquery_default()(child));
          break;
        case 'skin':
          this.skinFileName = external_jquery_default()(child).attr('file');
          break;
        case 'descriptors':
          this.tags = parseXmlNode(child, true);
          if (this.tags['#text']) {
            this.tags.other = this.tags['#text'].textContent;
            delete this.tags['#text'];
          }
          break;
        case 'license':
          this.license = getXmlNodeText(child);
          break;
        case 'cover':
        case 'thumb':
          const img = getXmlNodeText(child);
          if (img.file)
            this[child.nodeName] = img.file;
          break;
      }
    });

    this.buildLocales();

    multiple_descriptions.forEach(d => {
      if (d.language && d.text)
        this.description[d.language] = d.text;
    });

    if (single_description && this.languages.length > 0 && !this.description[this.languages[0]])
      this.description[this.languages[0]] = single_description;

    return this;
  }

  buildLocales() {
    // Try to find an array of valid locales
    // See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl
    if (this.languages.length > 0 && window.Intl && window.Intl.getCanonicalLocales) {
      this.locales = [];
      this.languages.forEach(lang => {
        // Languages usually are stored in the form: "English (en)"
        const matches = /\(([a-z,A-Z,-]+)\)/.exec(lang);
        if (matches && matches.length > 1) {
          try {
            const canonicals = window.Intl.getCanonicalLocales(matches[1]);
            if (canonicals)
              this.locales = this.locales.concat(canonicals);
          } catch (err) {
            log('error', `Invalid language: ${lang}`);
          }
        }
      });
    }
    return this;
  }

  /**
   * Gets a object with the basic attributes needed to rebuild this instance excluding functions,
   * parent references, constants and also attributes retaining the default value.
   * The resulting object is commonly usued to serialize elements in JSON format.
   * @returns {object} - The resulting object, with minimal attrributes
   */
  getAttributes() {
    return getAttr(this, [
      'title', 'description',
      'tags', 'languages', 'license',
      'authors', 'organizations',
      'revisions',
      'cover', 'thumb',
      'skinFileName', 'eventSounds'
    ]);
  }

  /**
   * Reads the properties of this ProjectSettings from a data object
   * @param {object} data - The data object to be parsed, or just the text content
   * @returns {module:project/ProjectSettings.ProjectSettings}
   */
  setAttributes(data) {
    setAttr(this, data, [
      'title', 'description',
      'tags', 'languages', 'license',
      'authors', 'organizations',
      'revisions',
      'cover', 'thumb',
      'skinFileName', 'eventSounds'
    ]);

    // Build Date objects in revisions
    if (this.revisions)
      this.revisions.forEach(rv => {
        if (rv.date)
          rv.date = new Date(rv.date);
      });

    return this.buildLocales();
  }
}

Object.assign(ProjectSettings.prototype, {
  /**
   * The JClicProject to which this ProjectSettings belongs
   * @name module:project/ProjectSettings.ProjectSettings#project
   * @type {module:project/JClicProject.JClicProject} */
  project: null,
  /**
   * The project title
   * @name module:project/ProjectSettings.ProjectSettings#title
   * @type {string} */
  title: 'Untitled',
  /**
   * The authors of this project.
   * Each author is represented by an object with the following attributes:
   * `name` (mandatory), `mail`, `rol`, `organization` and `url`
   * @name module:project/ProjectSettings.ProjectSettings#authors
   * @type {object[]} */
  authors: null,
  /**
   * Schools, companies and other institutions involved on this project.
   * Each organization is represented by an object with the following attributes:
   * `name` (mandatory), `mail`, `url`, `address`, `pc`, `city`, `state`, `country`, `comments`
   * @name module:project/ProjectSettings.ProjectSettings#organizations
   * @type {object[]} */
  organizations: null,
  /**
   * The history of revisions made to this project.
   * Revisions are represented by objects with the following attributes:
   * `date` (mandatory), `description`, `comments` and `author`
   * @name module:project/ProjectSettings.ProjectSettings#revisions
   * @type {object[]} */
  revisions: null,
  /**
   * Project's description, maybe in multiple languages.
   * @name module:project/ProjectSettings.ProjectSettings#description
   * @type {object} */
  description: null,
  /**
   * JClic projects can use more than one language, so use a string array
   * @name module:project/ProjectSettings.ProjectSettings#languages
   * @type {string[]} */
  languages: null,
  tags: null,
  cover: null,
  thumb: null,
  license: {
    type: 'by-nc-sa',
    url: 'https://creativecommons.org/licenses/by-nc-sa/4.0',
  },
  /**
   * Array of canonical locales, as defined in 
   * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl#Locale_identification_and_negotiation|Intl}
   * @name module:project/ProjectSettings.ProjectSettings#locales
   * @type {string[]} */
  locales: null,
  /**
   * The name of an optional 'skin' (visual aspect) can be set for the whole project, or for each {@link module:Activity.Activity Activity}
   * @name module:project/ProjectSettings.ProjectSettings#skinFileName
   * @type {string} */
  skinFileName: null,
  /**
   * The main {@link module:media/EventSounds.EventSounds EventSounds} object of the project
   * @name module:project/ProjectSettings.ProjectSettings#eventSounds
   * @type {module:media/EventSounds.EventSounds} */
  eventSounds: new media_EventSounds(),
});

/* harmony default export */ const project_ProjectSettings = (ProjectSettings);

;// CONCATENATED MODULE: ./src/bags/JumpInfo.js
/**
 *  File    : bags/JumpInfo.js
 *  Created : 05/04/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Catalan Educational Telematic Network (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */



/**
 * This class contains information about what things JClic sequence manager has to do in certain
 * circumstances, such as:
 * - an activity finishes
 * - the user clicks on the "next" or "prev" buttons
 * - the user clicks or a cell with special "active content"
 *
 * Different kinds of actions are possible for each of these events:
 * - RETURN: to go back to a previous point in the sequence.
 * - EXIT: to exit the program (thus navigating to another URL)
 * - STOP: to do nothing.
 * - JUMP: to jump to a specific point in the sequence of activities, or to another JClic project.
 * @see {@link module:bags/ActivitySequenceJump.ActivitySequenceJump ActivitySequenceJump}
 * @see {@link module:bags/ConditionalJumpInfo.ConditionalJumpInfo ConditionalJumpInfo}
 */
class JumpInfo {
  /**
   * JumpInfo constructor
   * @param {string} action - Must be one of the described actions.
   * @param {number|string} [sq] - Can be the tag of the sequence element to jump to, or its
   * cardinal number in the list.
   */
  constructor(action, sq) {
    this.action = action;
    switch (typeof sq) {
      case 'string':
        this.sequence = sq;
        break;
      case 'number':
        this.actNum = sq;
        break;
    }
  }

  /**
   * Loads the object settings from a specific JQuery XML element
   * @param {external:jQuery} $xml - The XML element to parse
   */
  setProperties($xml) {
    this.id = $xml.attr('id');
    this.action = $xml.attr('action') || 'JUMP';
    if ($xml.attr('tag'))
      this.sequence = nSlash($xml.attr('tag'));
    if ($xml.attr('project'))
      this.projectPath = nSlash($xml.attr('project'));
    return this;
  }

  /**
   * Gets a object with the basic attributes needed to rebuild this instance excluding functions,
   * parent references, constants and also attributes retaining the default value.
   * The resulting object is commonly usued to serialize elements in JSON format.
   * @returns {object} - The resulting object, with minimal attrributes
   */
  getAttributes() {
    return getAttr(this, ['id', 'action', 'actNum', 'sequence', 'projectPath']);
  }

  /**
   * Loads the object settings from a data object
   * @param {object} data - The data object to parse
   */
  setAttributes(data) {
    ['id', 'action', 'actNum', 'sequence', 'projectPath'].forEach(t => {
      if (!isEmpty(data[t]))
        this[t] = data[t];
    });
    return this;
  }
}

Object.assign(JumpInfo.prototype, {
  /**
   * The JumpInfo identifier
   * - For regular jumps: 'forward', 'back'
   * - For conditional jumps: 'upper', 'lower'
   * @name module:bags/JumpInfo.JumpInfo#id
   * @type {string} */
  id: null,
  /**
   * The current action.
   * Possible values are: `JUMP`, `STOP`, `RETURN` and `EXIT`.
   * @name module:bags/JumpInfo.JumpInfo#action
   * @type {string} */
  action: null,
  /**
   * Activity number in the sequence list
   * @name module:bags/JumpInfo.JumpInfo#actNum
   * @type {number} */
  actNum: -1,
  /**
   * Current sequence tag
   * @name module:bags/JumpInfo.JumpInfo#sequence
   * @type {string} */
  sequence: null,
  /**
   * Path of another JClic project to jump to
   * @name module:bags/JumpInfo.JumpInfo#projectPath
   * @type {string} */
  projectPath: null,
});

/* harmony default export */ const bags_JumpInfo = (JumpInfo);

;// CONCATENATED MODULE: ./src/bags/ConditionalJumpInfo.js
/**
 *  File    : bags/ConditionalJumpInfo.js
 *  Created : 05/04/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Catalan Educational Telematic Network (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */




/**
 * This special case of {@link module:bags/JumpInfo.JumpInfo JumpInfo} is used in {@link module:bags/ActivitySequenceJump.ActivitySequenceJump ActivitySequenceJump} objects to decide
 * the type of jump or action to be performed, based on the results obtained by the user when
 * playing previous JClic activities.
 *
 * In addition to the standard {@link module:bags/JumpInfo.JumpInfo JumpInfo} fields and methods, this class has two public
 * members where score and time thresholds are stored.
 *
 * The exact meaning of this members will depend on the type of `ConditionalJumpInfo` in the
 * {@link module:bags/ActivitySequenceJump.ActivitySequenceJump ActivitySequenceJump} (it can be `upperJump` or `lowerJump`).
 * @extends module:bags/JumpInfo.JumpInfo
 */
class ConditionalJumpInfo extends bags_JumpInfo {
  /**
   * ConditionalJumpInfo constructor
   * @param {string} action - Must be one of the described actions.
   * @param {number|string} [sq] - Can be the tag of the sequence element to jump to, or its
   * cardinal number in the list.
   * @param {number} [threshold] - Threshold above or below which the action will be triggered,
   * depending on the type of JumpInfo.
   * @param {number} [time] - Delay to be applied in automatic jumps.
   */
  constructor(action, sq, threshold, time) {
    super(action, sq);
    this.threshold = typeof threshold === 'number' ? threshold : -1;
    this.time = typeof threshold === 'number' ? time : -1;
  }

  /**
   * Loads this object settings from a specific JQuery XML element
   * @param {external:jQuery} $xml - The XML element to parse
   */
  setProperties($xml) {
    super.setProperties($xml);
    if ($xml.attr('threshold') !== undefined)
      this.threshold = $xml.attr('threshold');
    if ($xml.attr('time') !== undefined)
      this.time = $xml.attr('time');
    return this;
  }

  /**
   * Gets a object with the basic attributes needed to rebuild this instance excluding functions,
   * parent references, constants and also attributes retaining the default value.
   * The resulting object is commonly usued to serialize elements in JSON format.
   * @returns {object} - The resulting object, with minimal attrributes
   */
  getAttributes() {
    return Object.assign(super.getAttributes(), getAttr(this, ['threshold', 'time']));
  }

  /**
   * Loads this conditional jump settings from a data object
   * @param {object} data - The data object to parse
   */
  setAttributes(data) {
    super.setAttributes(data);
    ['threshold', 'time'].forEach(t => {
      if (!isEmpty(data[t]))
        this[t] = data[t];
    });
    return this;
  }
}

Object.assign(ConditionalJumpInfo.prototype, {
  /**
   * Threshold above or below which the action will be triggered, depending on the type of JumpInfo.
   * @name module:bags/ConditionalJumpInfo.ConditionalJumpInfo#threshold
   * @type {number} */
  threshold: -1,
  /**
   * Delay to be applied in automatic jumps.
   * @name module:bags/ConditionalJumpInfo.ConditionalJumpInfo#time
   * @type {number} */
  time: -1,
});

/* harmony default export */ const bags_ConditionalJumpInfo = (ConditionalJumpInfo);

;// CONCATENATED MODULE: ./src/bags/ActivitySequenceJump.js
/**
 *  File    : bags/ActivitySequenceJump.js
 *  Created : 05/04/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Catalan Educational Telematic Network (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */






/**
 * This is a special case of {@link module:bags/JumpInfo.JumpInfo JumpInfo}, used only in {@link module:bags/ActivitySequenceElement.ActivitySequenceElement ActivitySequenceElement} objects.
 * Sequence elements can contain up to two ActivitySequenceJump objects: one to be processed
 * when the user clicks on the "next" button (or when the activity finishes, if in automatic mode),
 * and the other used with the "prev" button. ActivitySequenceJump objects define a default jump
 * or action to be performed, but can also have up to two {@link module:bags/ConditionalJumpInfo.ConditionalJumpInfo ConditionalJumpInfo} objects. These
 * define alternative jumps that are performed only when score or time are below or over a specific
 * threshold.
 * @extends module:bags/JumpInfo.JumpInfo
 */
class ActivitySequenceJump extends bags_JumpInfo {
  /**
   * ActivitySequenceJump constructor
   * @param {string} action - Must be one of the described actions.
   * @param {number|string} [sq] - Can be the tag of the sequence element to jump to, or its
   * cardinal number in the list.
   */
  constructor(action, sq) {
    super(action, sq);
  }

  /**
   * Loads the object settings from a specific JQuery XML element.
   * @param {external:jQuery} $xml - The XML element to parse
   */
  setProperties($xml) {
    super.setProperties($xml);

    // Read conditional jumps
    $xml.children('jump').each((_n, child) => {
      const condJmp = new bags_ConditionalJumpInfo().setProperties(external_jquery_default()(child));
      if (condJmp.id === 'upper')
        this.upperJump = condJmp;
      else if (condJmp.id === 'lower')
        this.lowerJump = condJmp;
    });
    return this;
  }

  /**
   * Gets a object with the basic attributes needed to rebuild this instance excluding functions,
   * parent references, constants and also attributes retaining the default value.
   * The resulting object is commonly usued to serialize elements in JSON format.
   * @returns {object} - The resulting object, with minimal attrributes
   */
  getAttributes() {
    return Object.assign(super.getAttributes(), getAttr(this, ['upperJump', 'lowerJump']));
  }

  /**
    * Loads the jump settings from a data object
    * @param {object} data - The data object to parse
    */
  setAttributes(data) {
    super.setAttributes(data);

    ['upperJump', 'lowerJump'].forEach(cj => {
      if (data[cj])
        this[cj] = new bags_ConditionalJumpInfo().setAttributes(data[cj]);
    });

    return this;
  }


  /**
   * Resolves what {@link module:bags/JumpInfo.JumpInfo JumpInfo} must be taken, based on a done time and average rating obtained
   * in activities.
   * @param {number} rating - Average rating obtained by the user in the activities done during the
   * last sequence stretch.
   * @param {number} time - Total time spend doing the activities.
   * @returns {module:bags/JumpInfo.JumpInfo}
   */
  resolveJump(rating, time) {
    let result = this;
    if (rating >= 0 && time >= 0) {
      if (this.upperJump !== null &&
        rating > this.upperJump.threshold &&
        (this.upperJump.time <= 0 || time < this.upperJump.time)) {
        result = this.upperJump;
      } else if (this.lowerJump !== null &&
        (rating < this.lowerJump.threshold ||
          this.lowerJump.time > 0 && time > this.lowerJump.time)) {
        result = this.lowerJump;
      }
    }
    return result;
  }
}

Object.assign(ActivitySequenceJump.prototype, {
  /**
   * Optional jump to be performed when the results (score and time) are above a specific threshold.
   * @name module:bags/ActivitySequenceJump.ActivitySequenceJump#upperJump
   * @type {module:bags/ConditionalJumpInfo.ConditionalJumpInfo} */
  upperJump: null,
  /**
   * Optional jump to be performed when the results (score or time) are below a specific threshold.
   * @name module:bags/ActivitySequenceJump.ActivitySequenceJump#lowerJump
   * @type {module:bags/ConditionalJumpInfo.ConditionalJumpInfo} */
  lowerJump: null,
});

/* harmony default export */ const bags_ActivitySequenceJump = (ActivitySequenceJump);

;// CONCATENATED MODULE: ./src/bags/ActivitySequenceElement.js
/**
 *  File    : bags/ActivitySequenceElement.js
 *  Created : 05/04/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */





/**
 *
 * This class is the basic component of {@link module:bags/ActivitySequence.ActivitySequence ActivitySequence} objects. It represents a specific
 * point in the project's sequence of JClic activities.
 *
 * For each point of the sequence, some options can be set:
 * - What activity must run at this point
 * - What to do or where to jump when the activity finishes
 * - The behavior of the "next" button
 * - The behavior of the  "prev" button
 *
 * Sequence points can also have a "tag", used to refer to them with a unique name.
 */
class ActivitySequenceElement {
  constructor() {
  }

  /**
   * Loads the object settings from a specific JQuery XML element
   * @param {external:jQuery} $xml
   */
  setProperties($xml) {

    // Iterate on all provided attributes
    attrForEach($xml.get(0).attributes, (name, val) => {
      switch (name) {
        case 'id':
          this['tag'] = nSlash(val);
          break;
        case 'name':
          this['activity'] = val;
          break;
        case 'description':
        // possible navButtons values are: `none`, `fwd`, `back` or `both`
        case 'navButtons':
          this[name] = val;
          break;
        case 'delay':
          this[name] = Number(val);
          break;
      }
    });

    // Iterate on 'jump' elements to load fwdJump and/or backJump
    $xml.children('jump').each((_n, data) => {
      const jmp = new bags_ActivitySequenceJump().setProperties(external_jquery_default()(data));
      if (jmp.id === 'forward')
        this.fwdJump = jmp;
      else if (jmp.id === 'back')
        this.backJump = jmp;
    });
    return this;
  }

  /**
   * Gets a object with the basic attributes needed to rebuild this instance excluding functions,
   * parent references, constants and also attributes retaining the default value.
   * The resulting object is commonly usued to serialize elements in JSON format.
   * @returns {object} - The resulting object, with minimal attrributes
   */
  getAttributes() {
    return getAttr(this, ['tag', 'description', 'activity', 'fwdJump', 'backJump', 'navButtons', 'delay']);
  }

  /**
   * Loads sequence element settings from a data object
   * @param {object} data
   */
  setAttributes(data) {
    ['tag', 'description', 'activity', 'navButtons', 'delay'].forEach(t => {
      if (!isEmpty(data[t]))
        this[t] = data[t];
    });

    ['fwdJump', 'backJump'].forEach(jmp => {
      if (data[jmp]) {
        this[jmp] = new bags_ActivitySequenceJump().setAttributes(data[jmp]);
      }
    });
    return this;
  }
}

Object.assign(ActivitySequenceElement.prototype, {
  /**
   * Optional unique identifier of this element in the {@link module:bags/ActivitySequence.ActivitySequence ActivitySequence}.
   * @name module:bags/ActivitySequenceElement.ActivitySequenceElement#tag
   * @type {string} */
  tag: null,
  /**
   * Optional description of this sequence element.
   * @name module:bags/ActivitySequenceElement.ActivitySequenceElement#description
   * @type {string} */
  description: null,
  /**
   * Name of the {@link module:Activity.Activity Activity} pointed by this element.
   * @name module:bags/ActivitySequenceElement.ActivitySequenceElement#activity
   * @type {string} */
  activity: '',
  /**
   * Jump to be processed by the 'next' button action
   * @name module:bags/ActivitySequenceElement.ActivitySequenceElement#fwdJump
   * @type {module:bags/ActivitySequenceJump.ActivitySequenceJump} */
  fwdJump: null,
  /**
   * Jump to be processed by the 'prev' button action.
   * @name module:bags/ActivitySequenceElement.ActivitySequenceElement#backJump
   * @type {module:bags/ActivitySequenceJump.ActivitySequenceJump} */
  backJump: null,
  /**
   * What buttons should be active at this point of the sequence. Valid values are:
   * - 'none'
   * - 'fwd'
   * - 'back'
   * - 'both'
   * @name module:bags/ActivitySequenceElement.ActivitySequenceElement#navButtons
   * @type {string} */
  navButtons: 'both',
  /**
   * Time delay (in seconds) before passing to the next/prev activity
   * @name module:bags/ActivitySequenceElement.ActivitySequenceElement#delay
   * @type {number} */
  delay: 0,
});

/* harmony default export */ const bags_ActivitySequenceElement = (ActivitySequenceElement);

;// CONCATENATED MODULE: ./src/bags/ActivitySequence.js
/**
 *  File    : bags/ActivitySequence.js
 *  Created : 05/04/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */







/**
 * This class stores the definition of the sequence to follow to show the activities of a
 * {@link module:project/JClicProject.JClicProject JClicProject}. The sequence are formed by an ordered list of objects of type
 * {@link module:bags/ActivitySequenceElement.ActivitySequenceElement ActivitySequenceElement}.
 * It stores also a transient pointer to the current sequence element.
 */
class ActivitySequence {
  /**
   * ActivitySequence constructor
   * @param {module:project/JClicProject.JClicProject} project - The JClic project to which this ActivitySequence belongs
   */
  constructor(project) {
    this.project = project;
    this.elements = [];
  }

  /**
   * Loads the object settings from a specific JQuery XML element
   * @param {external:jQuery} $xml - The XML element to parse
   */
  setProperties($xml) {
    $xml.children('item').each((_i, data) => this.elements.push(new bags_ActivitySequenceElement().setProperties(external_jquery_default()(data))));
    return this;
  }

  /**
   * Gets a object with the basic attributes needed to rebuild this instance excluding functions,
   * parent references, constants and also attributes retaining the default value.
   * The resulting object is commonly usued to serialize elements in JSON format.
   * @returns {object} - The resulting object, with minimal attrributes
   */
  getAttributes() {
    return this.elements.map(el => el.getAttributes());
  }

  /**
   * Loads the object settings from a data object
   * @param {object} data - The data object to parse
   */
  setAttributes(data) {
    data.forEach(el => this.elements.push(new bags_ActivitySequenceElement().setAttributes(el)));
    return this;
  }

  /**
   * Returns the index of the specified element in the sequence.
   * @param {module:bags/ActivitySequenceElement.ActivitySequenceElement} ase - The element to search.
   * @returns {number} - The requested index, or `null` if not found.
   */
  getElementIndex(ase) {
    return ase === null ? -1 : this.elements.indexOf(ase);
  }

  /**
   * Returns the nth element of the sequence.
   * @param {number} n - Index of the requested element
   * @param {boolean} updateCurrentAct - when `true`, the `currentAct` index will be updated.
   * @returns {module:bags/ActivitySequenceElement.ActivitySequenceElement} - The requested element, or `null` if out of range.
   */
  getElement(n, updateCurrentAct) {
    let result = null;
    if (n >= 0 && n < this.elements.length) {
      result = this.elements[n];
      if (updateCurrentAct)
        this.currentAct = n;
    }
    return result;
  }

  /**
   * Search into the sequence for a element with the provided tag
   * @param {string} tag - The tag to search
   * @param {boolean} updateCurrentAct - when `true`, the `currentAct` index will be updated.
   * @returns {module:bags/ActivitySequenceElement.ActivitySequenceElement} - The requested element, or `null` if not found.
   */
  getElementByTag(tag, updateCurrentAct) {
    let
      result = null,
      resultIndex = -1;
    if (tag) {
      tag = nSlash(tag);
      this.elements.some((el, index) => {
        if (el.tag === tag) {
          result = el;
          resultIndex = index;
        }
        return resultIndex !== -1;
      });
      if (resultIndex !== -1 && updateCurrentAct)
        this.currentAct = resultIndex;
    }
    return result;
  }

  /**
   * Gets the sequence element pointed by the `currentAct` member.
   * @returns {module:bags/ActivitySequenceElement.ActivitySequenceElement} - The current sequence element, or `null` if not set.
   */
  getCurrentAct() {
    return this.getElement(this.currentAct, false);
  }

  /**
   * Checks if it's possible to go forward from the current position in the sequence.
   * @param {boolean} hasReturn - Indicates whether the history of jumps done since the beginning
   * of the JClic session is empty or not. When not empty, a `RETURN` action is still possible.
   * @returns {boolean} - `true` when the user is allowed to go ahead to a next activity,
   * `false` otherwise. */
  hasNextAct(hasReturn) {
    let result = false;
    const ase = this.getCurrentAct();
    if (ase) {
      if (ase.fwdJump === null)
        result = true;
      else
        switch (ase.fwdJump.action) {
          case 'STOP':
            break;
          case 'RETURN':
            result = hasReturn;
            break;
          default:
            result = true;
        }
    }
    return result;
  }

  /**
   * Checks if it's possible to go back from the current position in the sequence.
   * @param {boolean} hasReturn - Indicates whether the history of jumps done since the beginning
   * of the JClic session is empty or not. When not empty, a `RETURN` action is still possible.
   * @returns {boolean} - `true` when the user is allowed to go back to a previous activity,
   * `false` otherwise. */
  hasPrevAct(hasReturn) {
    let result = false;
    const ase = this.getCurrentAct();
    if (ase) {
      if (ase.backJump === null)
        result = true;
      else
        switch (ase.backJump.action) {
          case 'STOP':
            break;
          case 'RETURN':
            result = hasReturn;
            break;
          default:
            result = true;
        }
    }
    return result;
  }

  /**
   * Gets the current state for the 'next' and 'prev' buttons.
   * @returns {string} - One of the possible values of {@link module:bags/ActivitySequenceElement.ActivitySequenceElement#navButtons navButtons},
   * thus: `none`, `fwd`, `back` or `both`
   */
  getNavButtonsFlag() {
    let flag = 'none';
    const ase = this.getCurrentAct();
    if (ase)
      flag = ase.navButtons;
    return flag;
  }

  /**
   * Computes the jump to perform from the current position on the sequence
   * @param {boolean} back - When `true`, the request is for the 'go back' button. Otherwise, is
   * for the 'next' one.
   * @param {module:report/Reporter.Reporter} reporter - The reporting engine that will provide values about score average
   * and time spend on the activities, used only to compute conditional jumps.
   * @returns {module:bags/JumpInfo.JumpInfo} - The jump info if a valid jump is possible, `null` otherwise.
   */
  getJump(back, reporter) {
    const ase = this.getCurrentAct();
    let result = null;
    if (ase) {
      const asj = back ? ase.backJump : ase.fwdJump;
      if (asj === null) {
        let i = this.currentAct + (back ? -1 : 1);
        if (i >= this.elements.length || i < 0)
          i = 0;
        result = new bags_JumpInfo('JUMP', i);
      } else {
        let
          rating = -1,
          time = -1;
        if (reporter !== null) {
          const seqRegInfo = reporter.getCurrentSequenceInfo();
          if (seqRegInfo !== null) {
            rating = Math.round(seqRegInfo.tScore);
            time = Math.round(seqRegInfo.tTime / 1000);
          }
        }
        result = asj.resolveJump(rating, time);
      }
    }
    return result;
  }

  /**
   * Finds the nearest sequence element with a valid 'tag', looking back in the `elements` list.
   * @param {number} num - The point of the sequence from which to start looking back.
   * @returns {string} - The nearest 'tag', or `null` if not found.
   */
  getSequenceForElement(num) {
    let tag = null;
    if (num >= 0 && num < this.elements.length)
      for (let i = num; tag === null && i >= 0; i--) {
        tag = this.getElement(i, false).tag;
      }
    return tag;
  }

  /**
   * Gets the first {@link module:bags/ActivitySequenceElement.ActivitySequenceElement ActivitySequenceElement} in the `elements` list pointing to the
   * specified activity name.
   * The search is always case-insensitive.
   * @param {string} activity - The name of the activity to search for.
   * @returns {module:bags/ActivitySequenceElement.ActivitySequenceElement} The requested element or `null` if not found.
   */
  getElementByActivityName(activity) {
    let result = null;
    if (activity !== null) {
      for (let i = 0; result === null && i < this.elements.length; i++) {
        const ase = this.getElement(i, false);
        if (ase.activity.toLowerCase() === activity.toLowerCase())
          result = ase;
      }
    }
    return result;
  }

  /**
   * Utility function to check if the current sequence element corresponds to the specified
   * activity. If negative, the `currentAct` will be accordingly set.
   * @param {string} activity - The name of the activity to check
   */
  checkCurrentActivity(activity) {
    let ase = this.getCurrentAct();
    if (ase === null || ase.activity.toUpperCase() !== activity.toUpperCase()) {
      for (let i = 0; i < this.elements.length; i++) {
        if (this.getElement(i, false).activity.toUpperCase() === activity.toUpperCase()) {
          this.currentAct = i;
          return false;
        }
      }
      ase = new bags_ActivitySequenceElement();
      ase.activity = activity;
      ase.fwdJump = new bags_ActivitySequenceJump('STOP');
      ase.backJump = new bags_ActivitySequenceJump('STOP');
      this.elements.push(ase);
      this.currentAct = this.elements.length - 1;
      return false;
    }
    return true;
  }
}

Object.assign(ActivitySequence.prototype, {
  /**
   * The ordered list of {@link module:bags/ActivitySequenceElement.ActivitySequenceElement ActivitySequenceElement} objects
   * @name module:bags/ActivitySequence.ActivitySequence#elements
   * @type {module:bags/ActivitySequenceElement.ActivitySequenceElement[]} */
  elements: null,
  /**
   * The JClic project to which this ActivitySequence belongs.
   * @name module:bags/ActivitySequence.ActivitySequence#project
   * @type {module:project/JClicProject.JClicProject} */
  project: null,
  /**
   * Pointer to the {@link module:bags/ActivitySequenceElement.ActivitySequenceElement ActivitySequenceElement} currently running (points inside
   * the `elements` array).
   * @name module:bags/ActivitySequence.ActivitySequence#currentAct
   * @type {number} */
  currentAct: -1,
});

/* harmony default export */ const bags_ActivitySequence = (ActivitySequence);

;// CONCATENATED MODULE: external "@francesc/basic-midi-player-js"
const basic_midi_player_js_namespaceObject = require("@francesc/basic-midi-player-js");
var basic_midi_player_js_default = /*#__PURE__*/__webpack_require__.n(basic_midi_player_js_namespaceObject);
;// CONCATENATED MODULE: ./src/media/MidiAudioPlayer.js
/**
 *  File    : media/MidiAudioPlayer.js
 *  Created : 11/10/2018
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */

/* global window */




// TODO: Use multiple instruments, at least one for each track
// TODO: Use multiple midi channels (currently flattened to a single channel)
// TODO: Use of channel 10 for percussion instruments
// TODO: ... build a real MIDI player!!

/**
 * A simple MIDI player based on MidiPlayerJS
 * https://github.com/grimmdude/MidiPlayerJS
 * See also: http://www.midijs.net (https://github.com/babelsberg/babelsberg-js/tree/master/midijs)
 */
class MidiAudioPlayer {
  /**
   * MidiAudioPlayer constructor
   * @param {external:ArrayBuffer} data - The MIDI file content, in ArrayBuffer format
   * @param {object} [options={}] - Optional params related to the type of soundfont used. Valid options inside this object are:<br>
   * - `MIDISoundFontObject`: An object containing the full soundfont data. When this param is provided, no other one will be used.
   * - `MIDISoundFontBase`: The URL used as base for the current collection of MIDI soundfonts. Defaults to `https://clic.xtec.cat/dist/jclic.js/soundfonts/MusyngKite`
   * - `MIDISoundFontName`: The MIDI instrument name. Defaults to `acoustic_grand_piano`. See [MIDI.js Soundfonts](https://github.com/gleitz/midi-js-soundfonts) for full lists of MIDI instrument names.
   * - `MIDISoundFontExtension`: An extension to be added to `MIDISoundFontName` in order to build the full file name of the soundfont JS file. Defaults to `-mp3.js`
   */
  constructor(data, options = {}) {
    const AudioContext = window && (window.AudioContext || window.webkitAudioContext);
    if (AudioContext) {
      // Build instrument on first call to constructor
      MidiAudioPlayer.prepareInstrument(options, new AudioContext());
      this.data = data;
      this.player = new (basic_midi_player_js_default()).Player(ev => this.playEvent(ev));
      if (this.player)
        this.player.loadArrayBuffer(data);
    }
  }

  /**
   * Initializes the soundfont instrument, loading data from GitHub
   * NOTE: This will not work when off-line!
   * TODO: Provided a basic, simple, static soundfont
   * @param {object} options - Optional param with options related to the MIDI soundfont. See details in `constructor` description.
   * @param {external:AudioContext} audioContext - The AudioContext object (see: https://developer.mozilla.org/en-US/docs/Web/API/AudioContext)
   */
  static prepareInstrument(options = {}, audioContext) {
    if (MidiAudioPlayer.loadingInstrument === false) {
      MidiAudioPlayer.loadingInstrument = true;
      MidiAudioPlayer.audioContext = audioContext;
      basic_midi_player_js_default().Soundfont.instrument(
        MidiAudioPlayer.audioContext,
        options.MIDISoundFontObject || MidiAudioPlayer.MIDISoundFontObject ||
        `${options.MIDISoundFontBase || MidiAudioPlayer.MIDISoundFontBase}/${options.MIDISoundFontName || MidiAudioPlayer.MIDISoundFontName}${options.MIDISoundFontExtension || MidiAudioPlayer.MIDISoundFontExtension}`)
        .then(instrument => {
          log('info', 'MIDI soundfont instrument loaded');
          MidiAudioPlayer.instrument = instrument;
        })
        .catch(err => {
          log('error', `Error loading soundfont base instrument: ${err}`);
        });
    }
  }

  /**
   * Pauses the player
   */
  pause() {
    if (this.player) {
      this.player.pause();
      this.startedNotes = [];
    }
  }

  /**
   * Starts or resumes playing
   */
  play() {
    if (this.player) {
      this.startedNotes = [];
      this.player.play();
    }
  }

  /**
   * Gets the ' paused'  state of the current player
   * @returns boolean
   */
  get paused() {
    return this.player && !this.player.isPlaying();
  }

  /**
   * Checks if the current player has ended or is already playing
   * @returns boolean
   */
  get ended() {
    return this.player && this.player.getSongTimeRemaining() <= 0;
  }

  /**
   * Gets the current time
   * @returns number
   */
  get currentTime() {
    return this.player && (this.player.getSongTime() * 1000) || 0;
  }

  /**
   * Sets the current time of this player (in milliseconds)
   * @param {number} time - The time position where the player pointer must be placed
   */
  set currentTime(time) {
    if (this.player)
      this.player.skipToSeconds(time / 1000);
  }

  /**
   * Plays a MIDI event
   * @param {object} ev - The event data. See http://grimmdude.com/MidiPlayerJS/docs/index.html for details
   */
  playEvent(ev) {
    if (this.player && MidiAudioPlayer.instrument) {
      // Check for specific interval
      if (this.playTo > 0 && this.currentTime >= this.playTo)
        this.pause();
      // Set main volume
      else if (ev.name === 'Controller Change' && ev.number === 7)
        this.mainVolume = ev.value / 127;
      // Process 'Note on' messages. Max gain set to 2.0 for better results with the used soundfont
      else if (ev.name === 'Note on' && ev.velocity > 0)
        this.startedNotes[ev.noteNumber] = MidiAudioPlayer.instrument.play(ev.noteName, MidiAudioPlayer.audioContext.currentTime, { gain: 2 * (this.mainVolume * ev.velocity / 100) });
      // Process 'Note off' messages
      else if (ev.name === 'Note off' && ev.noteNumber && this.startedNotes[ev.noteNumber]) {
        this.startedNotes[ev.noteNumber].stop();
        delete (this.startedNotes[ev.noteNumber]);
      }
    }
  }
}

Object.assign(MidiAudioPlayer.prototype, {
  /**
   * The MIDI file data used by this MIDI player
   * @name module:media/MidiAudioPlayer.MidiAudioPlayer#data
   * @type {external:ArrayBuffer} */
  data: null,
  /**
   * The grimmdude's MidiPlayer used by this player
   * @name module:media/MidiAudioPlayer.MidiAudioPlayer#player
   * @type {external:MidiPlayerJS} */
  player: null,
  /**
   * When >0, time position at which the music must end
   * @name module:media/MidiAudioPlayer.MidiAudioPlayer#playTo
   * @type {number} */
  playTo: 0,
  /**
   * Main volume of this track (set with a MIDI message of type `Controller Change` #7)
   * @name module:media/MidiAudioPlayer.MidiAudioPlayer#mainVolume
   * @type {number} */
  mainVolume: 1.0,
  /**
   * This array is used when processing 'Note off' events to stop notes that are currently playing.
   * It contains a collection of 'instrument.play' instances, one for each active note
   * @name module:media/MidiAudioPlayer.MidiAudioPlayer#startedNotes
   * @type {function[]} */
  startedNotes: [],
});

/**
 * The {@link external:AudioContext} used by this MIDI player.
 * @type {external:AudioContext}
 */
MidiAudioPlayer.audioContext = null;

/**
 * The "Instrument" object used by this MIDI player.
 * See: https://github.com/danigb/soundfont-player
 * @type {external:Instrument}
 */
MidiAudioPlayer.instrument = null;

/**
 * A flag used to avoid re-entrant calls to {@link module:media/MidiAudioPlayer.MidiAudioPlayer#prepareInstrument prepareInstrument}
 * @type {boolean}
 */
MidiAudioPlayer.loadingInstrument = false;

/**
 * An object containing the full soundfont data used by {@link module:media/MidiAudioPlayer.MidiAudioPlayer#instrument instrument}
 * When this member is set, no other settings related to the sounfFont will be used.
 * This value can be overwritten by the global parameter `MIDISoundFontObject`
 * @type {object}
 */
MidiAudioPlayer.MIDISoundFontObject = null;

/**
 * The URL used as base for the current collection of MIDI soundfonts.
 * This value can be overwritten by the global parameter `MIDISoundFontBase`
 * @type {string}
 */
MidiAudioPlayer.MIDISoundFontBase = 'https://clic.xtec.cat/dist/jclic.js/soundfonts/MusyngKite';
// Alternative sites are:
// 'https://clic.xtec.cat/dist/jclic.js/soundfonts/FluidR3_GM'
// 'https://raw.githubusercontent.com/gleitz/midi-js-soundfonts/gh-pages/FluidR3_GM'
// 'https://raw.githubusercontent.com/gleitz/midi-js-soundfonts/gh-pages/MusyngKite'

/**
 * The MIDI instrument name.
 * This value can be overwritten by the global parameter `MIDISoundFontName`
 * See [MIDI.js Soundfonts](https://github.com/gleitz/midi-js-soundfonts) for full lists of MIDI instrument names.
 * @type {string}
 */
MidiAudioPlayer.MIDISoundFontName = 'acoustic_grand_piano';

/**
 * An extension to be added to `MIDISoundFontName` in order to build the full file name of the soundfont JS file.
 * Current valid options are `-mp3.js` and `-ogg.js`
 * This value can be overwritten by the global parameter `MIDISoundFontExtension`
 * @type {string}
 */
MidiAudioPlayer.MIDISoundFontExtension = '-mp3.js';

/* harmony default export */ const media_MidiAudioPlayer = (MidiAudioPlayer);

;// CONCATENATED MODULE: ./src/bags/MediaBagElement.js
/**
 *  File    : bags/MediaBagElement.js
 *  Created : 07/04/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */

/* global URL, Uint8Array, XMLHttpRequest, Image, document */






/**
 * This kind of objects are the components of {@link module:bags/MediaBag.MediaBag MediaBag}.
 *
 * Media elements have a name, a reference to a file (the `file` field) and, when initialized,
 * a `data` field pointing to a object containing the real media. They have also a flag indicating
 * if the data must be saved on the {@link module:project/JClicProject.JClicProject JClicProject} zip file or just maintained as a reference
 * to an external file.
 */
class MediaBagElement {
  /**
   * MediaBagElement constructor
   * @param {string} basePath - Path to be used as a prefix of the file name
   * @param {string} file - The media file name
   * @param {external:JSZip} [zip] - An optional JSZip object from which the file must be extracted.
   */
  constructor(basePath, file, zip) {
    if (basePath)
      this.basePath = basePath;
    if (file) {
      this.file = nSlash(file);
      this.name = nSlash(file);
      this.ext = this.file.toLowerCase().split('.').pop();
      this.type = this.getFileType(this.ext);
      if (this.ext === 'gif')
        this.checkAnimatedGif();
    }
    if (zip)
      this.zip = zip;
    this.timeout = Date.now() + settings.LOAD_TIMEOUT;
  }


  /**
   * Private static array of {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLAudioElement HTMLAudioElements},
   * to be reused between all media elements of type 'audio'. One for each priority level
   * @name module:bags/MediaBagElement#_audioPlayers
   * @type {external:HTMLAudioElement[]}
   */
  static _audioPlayers = [];

  /**
   * Gets the static {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLAudioElement HTMLAudioElement}
   * associated to the requested priority level.
   * @param {number} level=1 - The priority level
   * @returns {external:HTMLAudioElement}
   */
  static getAudioPlayer(level = 1) {
    if (!MediaBagElement._audioPlayers[level])
      MediaBagElement._audioPlayers[level] = document.createElement('audio');
    return MediaBagElement._audioPlayers[level];
  }

  /**
   * Private static array of {@link bags/MediaBagElement MediaBagElements},
   * used to store a reference to the element using each `audioPlayer`
   * @name module:bags/MediaBagElement#_currentAudioElements
   * @type {bags/MediaBagElement[]}
   */
  static _currentAudioElements = [];

  /**
   * Clear all references to audio players and audio elements
   * To be called when a new activity starts
   */
  static resetAudioElements() {
    MediaBagElement._audioPlayers.fill(null);
    MediaBagElement._currentAudioElements.fill(null);
  }

  /**
   * Loads this object settings from a specific JQuery XML element
   * @param {external:jQuery} $xml - The XML element to parse
   */
  setProperties($xml) {
    this.name = nSlash($xml.attr('name'));
    this.file = nSlash($xml.attr('file'));
    this.ext = this.file.toLowerCase().split('.').pop();
    this.type = this.getFileType(this.ext);
    // Check if it's an animated GIF
    if (this.ext === 'gif') {
      const anim = $xml.attr('animated');
      if (typeof anim === 'undefined')
        this.checkAnimatedGif();
      else
        this.animated = anim === 'true';
    }
    if (this.type === 'font') {
      this.fontName = this.name === this.file && this.name.lastIndexOf('.') > 0 ?
        this.name.substring(0, this.name.lastIndexOf('.')) :
        this.name;
    }
    return this;
  }

  /**
   * Gets a object with the basic attributes needed to rebuild this instance excluding functions,
   * parent references, constants and also attributes retaining the default value.
   * The resulting object is commonly usued to serialize elements in JSON format.
   * @returns {object} - The resulting object, with minimal attrributes
   */
  getAttributes() {
    return getAttr(this, ['name', 'file', 'animated']);
  }

  /**
   * Loads the element properties from a data object
   * @param {object} data - The data object to parse
   */
  setAttributes(data) {
    ['name', 'file', 'animated'].forEach(attr => {
      if (!isEmpty(data[attr]))
        this[attr] = data[attr];
    });

    this.ext = this.file.toLowerCase().split('.').pop();
    this.type = this.getFileType(this.ext);

    // Check if it's an animated GIF
    if (this.ext === 'gif' && this.animated === 'undefined')
      this.checkAnimatedGif();

    if (this.type === 'font') {
      this.fontName = this.name === this.file && this.name.lastIndexOf('.') > 0 ?
        this.name.substring(0, this.name.lastIndexOf('.')) :
        this.name;
    }
    return this;
  }

  /**
   * Checks if the image associated with this MediaBagElement is an animated GIF
   *
   * Based on: {@link https://gist.github.com/marckubischta/261ad8427a214022890b}
   * Thanks to `@lakenen` and `@marckubischta`
   */
  checkAnimatedGif() {
    const request = new XMLHttpRequest();
    // Set `responseType` moved after calling `open`
    // see: https://stackoverflow.com/questions/20760635/why-does-setting-xmlhttprequest-responsetype-before-calling-open-throw
    // request.responseType = 'arraybuffer'
    request.addEventListener('load', () => {
      const
        arr = new Uint8Array(request.response),
        length = arr.length;

      // make sure it's a gif (GIF8)
      if (arr[0] !== 0x47 || arr[1] !== 0x49 ||
        arr[2] !== 0x46 || arr[3] !== 0x38) {
        this.animated = false;
        return;
      }

      // Ported from PHP [http://www.php.net/manual/en/function.imagecreatefromgif.php#104473]
      // an animated gif contains multiple "frames", with each frame having a
      // header made up of:
      // * a static 3-byte sequence (\x00\x21\xF9
      // * one byte indicating the length of the header (usually \x04)
      // * variable length header (usually 4 bytes)
      // * a static 2-byte sequence (\x00\x2C) (some variants may use \x00\x21 ?)
      // We read through the file as long as we haven't reached the end of the file
      // and we haven't yet found at least 2 frame headers
      for (let i = 0, len = length - 3, frames = 0; i < len && frames < 2; ++i) {
        if (arr[i] === 0x00 && arr[i + 1] === 0x21 && arr[i + 2] === 0xF9) {
          const
            blocklength = arr[i + 3],
            afterblock = i + 4 + blocklength;
          if (afterblock + 1 < length &&
            arr[afterblock] === 0x00 &&
            (arr[afterblock + 1] === 0x2C || arr[afterblock + 1] === 0x21)) {
            if (++frames > 1) {
              this.animated = true;
              log('debug', `Animated GIF detected: ${this.file}`);
              break;
            }
          }
        }
      }
    });

    this.getFullPathPromise()
      .then(fullPath => {
        request.open('GET', fullPath, true);
        request.responseType = 'arraybuffer';
        request.send();
      });
  }

  /**
   * Checks if the MediaBagElement has been initiated
   * @returns {boolean}
   */
  isEmpty() {
    return this.data === null;
  }

  /**
   * Determines the type of a file from its extension
   * @param {string} ext - The file name extension
   * @returns {string}
   */
  getFileType(ext) {
    let result = null;
    for (let type in settings.FILE_TYPES) {
      if (settings.FILE_TYPES[type].indexOf(ext) >= 0) {
        result = type;
        break;
      }
    }
    return result;
  }

  /**
   * Instantiates the media content
   * @param {function} callback - Callback method called when the referred resource is ready
   * @param {module:JClicPlayer.JClicPlayer} ps=null - An optional `PlayStation` (currently a {@link module:JClicPlayer.JClicPlayer JClicPlayer}) used to dynamically load fonts
   * @param {boolean} force=false - Used only in media of type 'audio'. When `true`, a static {@link MediaBagElement._audioPlayers audioPlayer element} will be loaded with this media source
   * @param {number} level=1 - Priority level of the media content to be built. Used only n audio elements.
   */
  build(callback, ps = null, force = false, level = 1) {
    // Mock data when running in NodeJS
    if (settings.NODEJS) {
      this.data = [];
      this.ready = true;
    }

    if (callback) {
      if (!this._whenReady)
        this._whenReady = [];
      this._whenReady.push(callback);
    }

    if (!this.data)
      this.getFullPathPromise()
        .then(fullPath => {
          switch (this.type) {
            case 'font':
              const
                format = this.ext === 'ttf' ? 'truetype' : this.ext === 'otf' ? 'embedded-opentype' : this.ext,
                css = `@font-face{font-family:"${this.fontName}";src:url(${fullPath}) format("${format}");}`;

              appendStyleAtHead(css, ps);
              this.data = new Font(this.name);
              this.ready = true;
              break;

            case 'image':
              this.data = new Image();
              this.data.addEventListener('load', () => { this._onReady.call(this); }, { once: true });
              this.data.src = fullPath;
              break;

            case 'video':
              this.data = document.createElement(this.type);
              this.data.addEventListener('canplay', () => { this._onReady.call(this); }, { once: true });
              this.data.src = fullPath;
              this.data.load();
              this.data.pause();
              break;

            case 'audio':
              // HTML Audio objects will be created on demand, when the param 'force' is set to true
              if (force) {
                // Clean up state in current audio element, if any
                const currentAudioElement = MediaBagElement._currentAudioElements[level];
                if (currentAudioElement && currentAudioElement !== this) {
                  currentAudioElement.data = null;
                  currentAudioElement.ready = false;
                }
                // Register as a current audio element
                MediaBagElement._currentAudioElements[level] = this;
                // Configure the audio player
                const audioPlayer = MediaBagElement.getAudioPlayer(level);
                if (audioPlayer.src !== fullPath) {
                  log('trace', `Loading static player #${level} with new audio: ${fullPath}`);
                  this.data = audioPlayer;
                  this.ready = false;
                  audioPlayer.addEventListener('canplay', () => { this._onReady.call(this); }, { once: true });
                  audioPlayer.src = fullPath;
                  audioPlayer.load();
                  audioPlayer.pause();
                }
                else
                  log('trace', `Reusing existing audio in player #${level}: ${fullPath}`);
              }
              else
                this.ready = true;
              break;

            case 'anim':
              // TODO: Use [Ruffle](https://ruffle.rs/) to play Flash movies
              this.data = external_jquery_default()(`<object type"application/x-shockwave-flash" width="300" height="200" data="${fullPath}"/>`).get(-1);
              // Unable to check the loading progress in elements of type `object`. so we mark it always as `ready`:
              this.ready = true;
              break;

            case 'xml':
              external_jquery_default().get(fullPath, null, null, 'xml').done(xmlData => {
                const children = xmlData ? xmlData.children || xmlData.childNodes : null;
                this.data = children && children.length > 0 ? parseXmlNode(children[0]) : null;
                this._onReady();
              }).fail(err => {
                log('error', `Error loading ${this.name}: ${err}`);
                this._onReady();
              });
              break;

            case 'midi':
              const request = new XMLHttpRequest();
              request.onreadystatechange = () => {
                if (request.readyState === 4) {
                  if (request.status === 200)
                    this.data = new media_MidiAudioPlayer(request.response, ps && ps.options);
                  else
                    log('error', `Error loading ${this.name}: ${request.statusText}`);
                  this._onReady();
                }
              };
              request.open('GET', fullPath, true);
              request.responseType = 'arraybuffer';
              request.send();
              break;

            default:
              log('trace', `Media currently not supported: ${this.name}`);
              this.ready = true;
          }

          if (this.ready)
            this._onReady();
        });
    else if (this.ready)
      this._onReady();

    return this;
  }

  /**
   * Checks if this media element is ready to start
   * @returns {boolean} - `true` if ready, `false` otherwise
   */
  checkReady() {
    if (this.data && !this.ready) {
      switch (this.type) {
        case 'image':
          this.ready = this.data.complete === true;
          break;
        case 'audio':
        case 'video':
        case 'anim':
          this.ready = this.data.readyState >= 1;
          break;
        default:
          this.ready = true;
      }
    }
    return this.ready;
  }

  /**
   * Checks if this resource has timed out.
   * @returns {boolean} - `true` if the resource has exhausted the allowed time to load, `false` otherwise
   */
  checkTimeout() {
    const result = Date.now() > this.timeout;
    if (result)
      log('warn', `Timeout while loading: ${this.name}`);
    return result;
  }

  /**
   * Notify listeners that the resource is ready
   */
  _onReady() {
    this.ready = true;
    if (this._whenReady) {
      this._whenReady.forEach(fn => fn.call(this, this));
      this._whenReady = null;
    }
  }

  /**
   * Gets the full path of the file associated to this element.
   * WARNING: This function should be called only after a successful call to `getFullPathPromise`
   * @returns {string}
   */
  getFullPath() {
    return this._fullPath;
  }

  /**
   * Gets a promise with the full path of the file associated to this element.
   * @returns {external:Promise}
   */
  getFullPathPromise() {
    return getPathPromise(this.basePath, this.file, this.zip)
      .then(fullPath => {
        // Process full URL only when running in a browser
        this._fullPath = settings.NODEJS
          ? fullPath
          : (new URL(fullPath, document.location.href)).toString();
        return this._fullPath;
      });
  }
}

Object.assign(MediaBagElement.prototype, {
  /**
   * The name of this element. Usually is the same as `file`
   * @name module:bags/MediaBagElement.MediaBagElement#name
   * @type {string} */
  name: '',
  /**
   * The name of the file where this element is stored
   * @name module:bags/MediaBagElement.MediaBagElement#file
   * @type {string} */
  file: '',
  /**
   * The font family name, used only in elements of type 'font'
   * @name module:bags/MediaBagElement.MediaBagElement#fontName
   * @type {string} */
  fontName: '',
  /**
   * The path to be used as base to access this media element
   * @name module:bags/MediaBagElement.MediaBagElement#basePath
   * @type {string} */
  basePath: '',
  /**
   * An optional JSZip object that can act as a container of this media
   * @name module:bags/MediaBagElement.MediaBagElement#zip
   * @type {external:JSZip} */
  zip: null,
  /**
   * When loaded, this field will store the realized media object
   * @name module:bags/MediaBagElement.MediaBagElement#data
   * @type {object} */
  data: null,
  /**
   * Flag indicating that `data` is ready to be used
   * @name module:bags/MediaBagElement.MediaBagElement#ready
   * @type {boolean} */
  ready: false,
  /**
   * Array of callback methods to be called when the resource becomes ready
   * @name module:bags/MediaBagElement.MediaBagElement#_whenReady
   * @private
   * @type {function[]} */
  _whenReady: null,
  /**
   * Normalized extension of `file`, useful to guess the media type
   * @name module:bags/MediaBagElement.MediaBagElement#ext
   * @type {string} */
  ext: '',
  /**
   * The resource type ('audio', 'image', 'midi', 'video', 'font')
   * @name module:bags/MediaBagElement.MediaBagElement#type
   * @type {string} */
  type: null,
  /**
   * Time set to load the resource before leaving
   * @name module:bags/MediaBagElement.MediaBagElement#timeout
   * @type {number} */
  timeout: 0,
  //
  /**
   * Flag used for animated GIFs
   * @name module:bags/MediaBagElement.MediaBagElement#animated
   * @type {boolean} */
  animated: false,
  /**
   * Full path obtained after a successful call to getFullPathPromise
   * @name module:bags/MediaBagElement.MediaBagElement#_fullPath
   * @private
   * @type {string}
   */
  _fullPath: null,
});

/* harmony default export */ const bags_MediaBagElement = (MediaBagElement);

;// CONCATENATED MODULE: ./src/bags/MediaBag.js
/**
 *  File    : bags/MediaBag.js
 *  Created : 07/04/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */






/**
 * This class stores and manages all the media components (images, sounds, animations, video,
 * MIDI files, etc.) needed to run the activities of a {@link module:project/JClicProject.JClicProject JClicProject}. The main member of
 * the class is `elements`. This is where {@link module:bads/MediaBagElement.MediaBagElement} objects are stored.
 */
class MediaBag {
  /**
   * MediaBag constructor
   * @param {module:project/JClicProject.JClicProject} project - The JClic project to which this media bag belongs
   */
  constructor(project) {
    this.project = project;
    this.elements = {};
  }

  /**
   * Loads this object settings from a specific JQuery XML element
   * @param {external:jQuery} $xml - The XML element to parse
   */
  setProperties($xml) {
    $xml.children('media').each((_n, child) => {
      const mbe = new bags_MediaBagElement(this.project.basePath, null, this.project.zip);
      mbe.setProperties(external_jquery_default()(child));
      this.elements[mbe.name] = mbe;
    });
    return this;
  }

  /**
   * Gets a object with the basic attributes needed to rebuild this instance excluding functions,
   * parent references, constants and also attributes retaining the default value.
   * The resulting object is commonly usued to serialize elements in JSON format.
   * @returns {object} - The resulting object, with minimal attrributes
   */
  getAttributes() {
    return Object.keys(this.elements).map(k => this.elements[k].getAttributes());
  }

  /**
   * Loads the MediaBag content from a data object
   * @param {object} data - The data object to parse
   */
  setAttributes(data) {
    data.forEach(el => {
      const mbe = new bags_MediaBagElement(this.project.basePath, null, this.project.zip);
      mbe.setAttributes(el);
      this.elements[mbe.name] = mbe;
    });
    return this;
  }

  /**
   * Finds a {@link module:bads/MediaBagElement.MediaBagElement} by its name, creating a new one if not found and requested.
   * @param {string} name - The name of the element
   * @param {boolean} [create] - When `true`, a new MediaBagElement will be created if not found,
   * using 'name' as its file name.
   * @returns {module:bags/MediaBagElement.MediaBagElement}
   */
  getElement(name, create) {
    name = nSlash(name);
    let result = this.elements[name];
    if (create && !result)
      result = this.getElementByFileName(name, create);
    return result;
  }

  /**
   * Gets a {@link module:bads/MediaBagElement.MediaBagElement} by its file name.
   * @param {string} file - The requested file name
   * @param {boolean} [create] - When `true`, a new {@link module:bads/MediaBagElement.MediaBagElement} will be created if not
   * found.
   * @returns {module:bags/MediaBagElement.MediaBagElement}
   */
  getElementByFileName(file, create) {
    let result = null;
    if (file) {
      file = nSlash(file);
      for (let name in this.elements) {
        if (this.elements[name].file === file) {
          result = this.elements[name];
          break;
        }
      }
      if (!result && create) {
        result = new bags_MediaBagElement(this.project.basePath, null, this.project.zip);
        result.name = file;
        result.file = file;
        result.ext = file.toLowerCase().split('#')[0].split('.').pop();
        result.type = result.getFileType(result.ext);
        this.elements[result.name] = result;
      }
    }
    return result;
  }

  /**
   * Get the names of the media elements that are of the given type.
   * When the search type is `font`, the `fontName` property is used instead of `name`
   * @param {string} type - The type of elements to search
   * @returns {string[]}
   */
  getElementsOfType(type) {
    const result = [];
    external_jquery_default().each(this.elements, (name, element) => {
      if (element.type === type)
        result.push(type === 'font' ? element.fontName : name);
    });
    return result;
  }

  /**
   * Preloads all resources.
   *
   * __Use with care!__ Calling this method will start loading all the resources defined in the
   * MediaBag, whether used or not in the current activity.
   * @param {string} type - The type of media to be build. When `null` or `undefined`, all
   * resources will be build.
   * @param {function} [callback] - Function to be called when each element is ready.
   * @param {module:JClicPlayer.JClicPlayer} [ps] - An optional `PlayStation` (currently a {@link module:JClicPlayer.JClicPlayer JClicPlayer}) used to dynamically load fonts
   * @returns {number} - The total number of elements that will be built
   */
  buildAll(type, callback, ps) {
    let count = 0;
    external_jquery_default().each(this.elements, (name, element) => {
      if (!type || element.type === type) {
        element.build(callback, ps, false);
        count++;
      }
    });
    return count;
  }

  /**
   * Checks if there are media waiting to be loaded
   * @returns {number} - The amount of media elements already loaded, or -1 if all elements are ready
   */
  countWaitingElements() {
    let
      ready = 0,
      allReady = true;

    // Only for debug purposes: return always 'false'
    // TODO: Check loading process!
    external_jquery_default().each(this.elements, (name, element) => {
      if (element.data && !element.ready && !element.checkReady() && !element.checkTimeout()) {
        log('debug', '... waiting for: %s', name);
        allReady = false;
      } else
        ready++;
    });
    return allReady ? -1 : ready;
  }

  /**
   * Loads a {@link module:skins/Skin.Skin Skin} object
   * @param {string} name - The skin name to be loaded
   * @param {string} ps - The {@link module:JClicPlayer.JClicPlayer JClicPlayer} linked to the skin
   * @returns {module:skins/Skin.Skin}
   */
  getSkinElement(name, ps) {
    return skins_Skin.getSkin(name, ps);
  }
}

Object.assign(MediaBag.prototype, {
  /**
   * The collection of {@link module:bads/MediaBagElement.MediaBagElement} objects
   * @name module:bags/MediaBag.MediaBag#elements
   * @type {object} */
  elements: null,
  /**
   * The JClic project to which this MediaBag belongs
   * @name module:bags/MediaBag.MediaBag#project
   * @type {module:project/JClicProject.JClicProject} */
  project: null,
});

/* harmony default export */ const bags_MediaBag = (MediaBag);

;// CONCATENATED MODULE: ./src/boxes/BoxBase.js
/**
 *  File    : boxes/BoxBase.js
 *  Created : 12/04/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Catalan Educational Telematic Network (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */





const defaultValues = settings.BoxBase;

/**
 * This class contains all the main visual attributes needed to draw {@link module:boxes/AbstractBox.AbstractBox AbstractBox} objects:
 * background and foreground colors, gradients, colors for special states (inactive, alternative,
 * disabled...), margins, fonts, border strokes, etc.
 *
 * Objects derived from {@link module:boxes/AbstractBox.AbstractBox AbstractBox} can have inheritance: boxes that act as "containers"
 * of other boxes (like {@link module:boxes/BoxBag.BoxBag BoxBag}). Most of the attributes of `BoxBase` can be `null`,
 * meaning that the value of the ancestor -or the default value if the box has no ancestors- must
 * be used.
 */
class BoxBase {
  /**
   * BoxBase constructor
   * @param {module:boxes/BoxBase.BoxBase} [parent] - Another BoxBase object used to determine the value of properties not
   * locally set.
   */
  constructor(parent) {
    this.parent = parent || null;
  }

  /**
   * Loads the BoxBase settings from a specific JQuery XML element
   * @param {external:jQuery} $xml - The XML element to parse
   */
  setProperties($xml) {
    //
    // Read attributes
    attrForEach($xml.get(0).attributes, (name, val) => {
      switch (name) {
        case 'shadow':
        case 'transparent':
          this[name] = getBoolean(val, false);
          break;
        case 'margin':
          this[name] = Number(val);
          break;
        case 'borderStroke':
          this.borderStroke = new Stroke(Number(val));
          break;
        case 'markerStroke':
          this.markerStroke = new Stroke(Number(val));
          break;
      }
    });
    //
    // Read inner elements
    $xml.children().each((_n, child) => {
      const $node = external_jquery_default()(child);
      switch (child.nodeName) {
        case 'font':
          this.font = (new Font()).setProperties($node);
          break;

        case 'gradient':
          this.bgGradient = new Gradient().setProperties($node);
          break;

        case 'color':
          this.textColor = checkColor($node.attr('foreground'), this.textColor);
          this.backColor = checkColor($node.attr('background'), this.backColor);
          this.shadowColor = checkColor($node.attr('shadow'), this.shadowColor);
          this.inactiveColor = checkColor($node.attr('inactive'), this.inactiveColor);
          this.alternativeColor = checkColor($node.attr('alternative'), this.alternativeColor);
          this.borderColor = checkColor($node.attr('border'), this.borderColor);
          break;
      }
    });
    return this;
  }

  /**
   * Gets a object with the basic attributes needed to rebuild this instance excluding functions,
   * parent references, constants and also attributes retaining the default value.
   * The resulting object is commonly usued to serialize elements in JSON format.
   * @returns {object} - The resulting object, with minimal attrributes
   */
  getAttributes() {
    return getAttr(this, [
      'shadow', 'transparent', 'margin',
      'borderStroke', 'markerStroke', // AWT.Stroke
      'font', // AWT.Font
      'bgGradient', // AWT.Gradient
      `textColor|${BoxBase.prototype.textColor}`,
      `backColor|${BoxBase.prototype.backColor}`,
      `shadowColor|${BoxBase.prototype.shadowColor}`,
      `inactiveColor|${BoxBase.prototype.inactiveColor}`,
      `alternativeColor|${BoxBase.prototype.alternativeColor}`,
      `borderColor|${BoxBase.prototype.borderColor}`,
    ]);
  }

  /**
   * Reads the properties of this BoxBase from a data object
   * @param {object} data - The data object to be parsed
   * @returns {module:boxes/BoxBase.BoxBase}
   */
  setAttributes(data) {
    return setAttr(this, data, [
      'shadow', 'transparent', 'margin',
      { key: 'borderStroke', fn: Stroke },
      { key: 'markerStroke', fn: Stroke },
      { key: 'font', fn: Font },
      { key: 'bgGradient', fn: Gradient },
      'textColor',
      'backColor',
      'shadowColor',
      'inactiveColor',
      'alternativeColor',
      'borderColor',
    ]);
  }

  /**
   * Gets the value of the specified property, scanning down to parents and prototype if not defined.
   * @param {string} property - The property to retrieve
   * @returns {any} - The object or value associated to this property
   */
  get(property) {
    if (this.hasOwnProperty(property) || this.parent === null)
      return this[property];
    else
      return this.parent.get(property);
  }

  /**
   * Sets the value of a specific property.
   * @param {string} property - The property name.
   * @param {any} value - Depends on the type of property
   */
  set(property, value) {
    this[property] = value;
    return this;
  }

  /**
   * Gets the value of the specified property, scanning down to parents if not defined, and returning
   * always an own property (not from prototype)
   * @param {string} property - The property to retrieve
   * @returns {any} - The object or value associated to this property
   */
  getOwn(property) {
    if (this.hasOwnProperty(property))
      return this[property];
    else if (this.parent !== null)
      return this.parent.getOwn(property);
    else {
      if (typeof this[property] === 'object')
        this[property] = cloneObject(BoxBase.prototype[property]);
      else
        this[property] = BoxBase.prototype[property];
    }
    return this[property];
  }

  /**
   * Gets the properties defined in this BoxBase as a collection of CSS attributes
   * @param {object} [css] - An optional set of initial CSS properties
   * @param {boolean} [inactive=false] - When `true`, get CSS attributes for an inactive cell
   * @param {boolean} [inverse=false] - When `true`, get CSS attributes for an inverse cell
   * @param {boolean} [alternative=false] - When `true`, get CSS attributes for an alternative cell
   * @returns {object}
   */
  getCSS(css, inactive = false, inverse = false, alternative = false) {
    // (css will be created by [AWT.Font.toCss](AWT.html) if null or undefined)
    const font = this.get('font');
    css = font.toCss(css);

    css['color'] = inverse ? this.get('backColor')
      : alternative ? this.get('alternativeColor')
        : this.get('textColor');

    const transparent = this.get('transparent');
    css['background-color'] = transparent ? 'transparent'
      : inactive ? this.get('inactiveColor')
        : inverse ? this.get('textColor') : this.get('backColor');

    const bgGradient = this.get('bgGradient');
    if (bgGradient && !transparent)
      css['background-image'] = bgGradient.getCss();

    if (this.shadow === 1) {
      const delta = Math.max(1, Math.round(font.size / 10));
      const color = this.get('shadowColor');
      css['text-shadow'] = `${delta}px ${delta}px 3px ${color}`;
    }
    return css;
  }

  /**
   * This utility method computes the width and height of text lines rendered on an HTML
   * __canvas__ element, reducing the font size of the BoxBase as needed when they exceed the maximum
   * width and/or height.
   * @param {external:CanvasRenderingContext2D} ctx - The canvas rendering context used to draw the text.
   * @param {string} text - The text to drawn.
   * @param {number} maxWidth - Maximum width
   * @param {number} maxHeight - Maximum height
   * @returns {object[]} - An array of objects representing lines of text. Each object has a `text`
   * member with the text displayed in the line, and a `size` member with the line {@link module:AWT.Dimension}
   */
  prepareText(ctx, text, maxWidth, maxHeight) {
    const
      result = [],
      font = this.get('font'),
      height = font.getHeight();
    let totalHeight = 0;

    // divide the text in lines
    const lines = text.trim().split('\n');
    ctx.font = font.cssFont();
    for (let l = 0; l < lines.length; l++) {
      let line = lines[l].trim();
      let width = ctx.measureText(line).width;
      if (width > maxWidth) {
        // retain the last string offset that was inside maxWidth
        let
          lastOK = 0,
          lastOKWidth = 0;
        for (let p = 0; p < line.length; p++) {
          // Find next separator
          if (isSeparator(line[p])) {
            const w = ctx.measureText(line.substr(0, p).trim()).width;
            if (w > maxWidth)
              break;
            lastOK = p;
            lastOKWidth = w;
          }
        }
        if (lastOK > 0) {
          // Add a new line with the tail of the line
          lines.splice(l + 1, 0, line.substr(lastOK + 1).trim());
          // Adjust the current line
          line = lines[l] = line.substr(0, lastOK).trim();
          width = lastOKWidth;
        }
        else {
          // No solution found. Try resizing down the font.
          if (font.size > defaultValues.MIN_FONT_SIZE) {
            this.getOwn('font').zoom(-1);
            return this.prepareText(ctx, text, maxWidth, maxHeight);
          }
        }
      }

      // Add the line and the calculated dimension to `result`
      result.push({
        text: line,
        size: new Dimension(width, height)
      });

      totalHeight += height;

      if (totalHeight > maxHeight && font.size > defaultValues.MIN_FONT_SIZE) {
        // Max height exceeded. Try resizing down the font
        this.getOwn('font').zoom(-1);
        return this.prepareText(ctx, text, maxWidth, maxHeight);
      }
    }
    return result;
  }
}

Object.assign(BoxBase.prototype, {
  /**
   * The parent BoxBase object
   * @name module:boxes/BoxBase.BoxBase#parent
   * @type {module:boxes/BoxBase.BoxBase} */
  parent: null,
  /**
   * Default values
   * @name module:boxes/BoxBase.BoxBase#defaultValues
   * @type {object} */
  default: defaultValues,
  /**
   * Font size can be dynamically reduced to fit the available space if any element using this
   * `BoxBase` requests it. When this happen, this field contains the real font currently used
   * to draw text.
   * @name module:boxes/BoxBase.BoxBase#font
   * @type {module:AWT.Font} */
  font: new Font(),
  /**
   * The current font size of this BoxBase. Can be dynamically adjusted when drawing.
   * @name module:boxes/BoxBase.BoxBase#dynFontSize
   * @type {number} */
  dynFontSize: 0,
  /**
   * Counts the number of times the `dynFontSize` has been reset. This is useful to avoid excessive
   * recursive loops searching the optimal font size.
   * @name module:boxes/BoxBase.BoxBase#resetFontCounter
   * @type {number} */
  resetFontCounter: 0,
  /**
   * The background color
   * @name module:boxes/BoxBase.BoxBase#backColor
   * @type {string} */
  backColor: defaultValues.BACK_COLOR,
  /**
   * The background gradient. Default is `null`.
   * @name module:boxes/BoxBase.BoxBase#bgGradient
   * @type {module:AWT.Gradient} */
  bgGradient: null,
  /**
   * The color used to write text.
   * @name module:boxes/BoxBase.BoxBase#textColor
   * @type {string} */
  textColor: defaultValues.TEXT_COLOR,
  /**
   * The color used to draw a shadow below regular text.
   * @name module:boxes/BoxBase.BoxBase#shadowColor
   * @type {string} */
  shadowColor: defaultValues.SHADOW_COLOR,
  /**
   * The color of the border.
   * @name module:boxes/BoxBase.BoxBase#borderColor
   * @type {string} */
  borderColor: defaultValues.BORDER_COLOR,
  /**
   * The color used to draw text when a cell is in `inactive` state.
   * @name module:boxes/BoxBase.BoxBase#inactiveColor
   * @type {string} */
  inactiveColor: defaultValues.INACTIVE_COLOR,
  /**
   * The color used to draw text when a cell is in `alternative` state.
   * @name module:boxes/BoxBase.BoxBase#alternativeColor
   * @type {string} */
  alternativeColor: defaultValues.ALTERNATIVE_COLOR,
  /**
   * Whether the text should have a shadow or not
   * @name module:boxes/BoxBase.BoxBase#shadow
   * @type {boolean} */
  shadow: false,
  /**
   * Whether the cell's background (and its hosted component, if any) should be transparent
   * @name module:boxes/BoxBase.BoxBase#transparent
   * @type {boolean} */
  transparent: false,
  /**
   * Wheter the cell's background should be painted or not. This property has no effect on
   * hosted components.
   * @name module:boxes/BoxBase.BoxBase#dontFill
   * @type {boolean} */
  dontFill: false,
  /**
   * The margin to respect between text elements and the limits of the cell or other elements.
   * @name module:boxes/BoxBase.BoxBase#textMargin
   * @type {number} */
  textMargin: defaultValues.AC_MARGIN,
  /**
   * The stroke used to draw the border.
   * @name module:boxes/BoxBase.BoxBase#borderStroke
   * @type {module:AWT.Stroke} */
  borderStroke: new Stroke(defaultValues.BORDER_STROKE_WIDTH),
  /**
   * The stroke used to draw a border around marked cells.
   * @name module:boxes/BoxBase.BoxBase#markerStroke
   * @type {module:AWT.Stroke} */
  markerStroke: new Stroke(defaultValues.MARKER_STROKE_WIDTH),
});

BoxBase.DEFAULT_BOX_BASE = new BoxBase();

/* harmony default export */ const boxes_BoxBase = (BoxBase);

;// CONCATENATED MODULE: ./src/boxes/ActiveBoxContent.js
/**
 *  File    : boxes/ActiveBoxContent.js
 *  Created : 13/04/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Catalan Educational Telematic Network (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */







/**
 * This class is used as a container for horizontal and vertical alignments of content inside a cell.
 */
class AlignType {
  /**
   * AlignType constructor
   * @param {string} [h] - Horizontal alignment. Possible values are `left`, `center` and `right`
   * @param {string} [v] - Vertical alignment. Possible values are `top`, `center` and `bottom`
   */
  constructor(h, v) {
    if (h)
      this.h = h;
    if (v)
      this.v = v;
  }

  /**
   * Gets a object with the basic attributes needed to rebuild this instance excluding functions,
   * parent references, constants and also attributes retaining the default value.
   * The resulting object is commonly usued to serialize elements in JSON format.
   * @returns {object} - The resulting object, with minimal attrributes
   */
  getAttributes() {
    return getAttr(this, ['h|center', 'v|center']);
  }

  /**
   * Reads the properties of this AlignType from a data object
   * @param {object} data - The data object to be parsed
   * @returns {module:boxes/ActiveBoxContent.AlignType}
   */
  setAttributes(data) {
    return setAttr(this, data, ['h', 'v']);
  }
}

Object.assign(AlignType.prototype, {
  h: 'center',
  v: 'center',
});

/**
 * This class defines a content that can be displayed by {@link module:boxes/ActiveBox.ActiveBox ActiveBox} objects. This content
 * can be a text, an image, a fragment of an image or a combination of text and images. The style
 * (colors, font and size, borders, shadows, margins, etc.) are specified in the `style` attribute,
 * always pointing to a {@link module:boxes/BoxBase.BoxBase BoxBase} object.
 */
class ActiveBoxContent {
  /**
   * ActiveBoxContent constructor
   * @param {string} [id] - An optional identifier.
   */
  constructor(id) {
    if (typeof id !== 'undefined')
      this.id = id;
    this.imgAlign = new AlignType();
    this.txtAlign = new AlignType();
  }

  /**
   *
   * Loads settings from a specific JQuery XML element
   * @param {external:jQuery} $xml - The XML element to be parsed
   * @param {module:bags/MediaBag.MediaBag} mediaBag - The media bag used to retrieve images and other media
   */
  setProperties($xml, mediaBag) {
    //
    // Read attributes
    attrForEach($xml.get(0).attributes, (name, val) => {
      switch (name) {
        case 'id':
        case 'item':
          this[name] = Number(val);
          break;

        case 'width':
        case 'height':
          if (this.dimension === null)
            this.dimension = new Dimension(0, 0);
          this.dimension[name] = Number(val);
          break;

        case 'txtAlign':
        case 'imgAlign':
          this[name] = this.readAlign(val);
          break;

        case 'hAlign':
          // Old style
          this['txtAlign'] = this.readAlign(val + ',center');
          this['imgAlign'] = this.readAlign(val + ',center');
          break;

        case 'border':
        case 'avoidOverlapping':
          this[name] = getBoolean(val);
          break;

        case 'image':
          this.image = nSlash(val);
          break;
      }
    });

    //
    // Read inner elements
    $xml.children().each((_n, child) => {
      const $node = external_jquery_default()(child);
      switch (child.nodeName) {
        case 'style':
          this.style = new boxes_BoxBase(null).setProperties($node);
          break;
        case 'media':
          this.mediaContent = new media_MediaContent().setProperties($node);
          break;
        case 'p':
          if (this.text === null)
            this.text = '';
          else
            this.text += '\n';
          this.text += child.textContent;
          break;
      }
    });

    if (mediaBag)
      this.realizeContent(mediaBag);

    return this;
  }

  /**
   * Gets a object with the basic attributes needed to rebuild this instance excluding functions,
   * parent references, constants and also attributes retaining the default value.
   * The resulting object is commonly usued to serialize elements in JSON format.
   * @returns {object} - The resulting object, with minimal attrributes
   */
  getAttributes() {
    return getAttr(this, [
      'id', 'item', 'dimension', 'border', 'avoidOverlapping', 'image', 'text',
      'objectType', // Used in TextActivityDocument
      'txtAlign', 'imgAlign', // AlignType
      'style', // BoxBase
      'mediaContent', // MediaContent
    ]);
  }

  /**
   * Reads the properties of this ActiveBoxContent from a data object
   * @param {object|string} data - The data object to be parsed, or just the text content
   * @param {module:bags/MediaBag.MediaBag} mediaBag - The media bag used to retrieve images and other media
   * @returns {module:boxes/ActiveBoxContent.ActiveBoxContent}
   */
  setAttributes(data, mediaBag) {

    if (typeof data === 'string')
      this.text = data;
    else
      setAttr(this, data, [
        'id', 'item', 'border', 'avoidOverlapping', 'image', 'text',
        'objectType',
        { key: 'dimension', fn: Dimension },
        { key: 'txtAlign', fn: AlignType },
        { key: 'imgAlign', fn: AlignType },
        { key: 'style', fn: boxes_BoxBase },
        { key: 'mediaContent', fn: media_MediaContent },
      ]);

    if (mediaBag)
      this.realizeContent(mediaBag);

    return this;
  }

  /**
   * Decode expressions with combined values of horizontal and vertical alignments in the form:
   * "(left|middle|right),(top|middle|bottom)"
   * @param {string} str - The string to parse
   * @returns {module:boxes/ActiveBoxContent.ActiveBoxContent~alignType}
   */
  readAlign(str) {
    const align = new AlignType();
    if (str) {
      const v = str.split(',');
      align.h = v[0].replace('middle', 'center');
      align.v = v[1].replace('middle', 'center');
    }
    return align;
  }

  /**
   * Checks if this is an empty content (`text` and `img` are _null_)
   */
  isEmpty() {
    return this.text === null && this.img === null;
  }

  /**
   * Checks if two contents are equivalent
   * @param {module:boxes/ActiveBoxContent.ActiveBoxContent} abc - The content to compare with this.
   * @param {boolean} checkCase - When `true` the comparing will be case-sensitive.
   * @returns {boolean}
   */
  isEquivalent(abc, checkCase) {
    if (abc === this)
      return true;
    let result = false;
    if (abc !== null) {
      if (this.isEmpty() && abc.isEmpty())
        result = this.id === abc.id;
      else
        result = (this.text === null ? abc.text === null
          : checkCase ? this.text === abc.text
            : this.text.toLocaleLowerCase() === abc.text.toLocaleLowerCase()
        ) &&
          (this.mediaContent === null ? abc.mediaContent === null
            : this.mediaContent.isEquivalent(abc.mediaContent)
          ) &&
          this.img === abc.img &&
          (this.imgClip === null ? abc.imgClip === null
            : this.imgClip.equals(abc.imgClip));
    }
    return result;
  }

  /**
   * Sets the text content of this ActiveBox
   * @param {string} tx
   */
  setTextContent(tx) {
    // only plain text allowed!
    if (tx !== null) {
      this.text = tx;
      this.checkHtmlText();
    } else {
      this.text = null;
      this.innerHtmlText = null;
    }
  }

  /**
   * Checks if cell's text uses HTML, initializing the `innerHtmlText` member as needed.
   */
  checkHtmlText() {
    this.innerHtmlText = null;
    if (startsWith(this.text, '<html>', true)) {
      const htmlText = this.text.trim();
      const s = htmlText.toLocaleLowerCase();
      if (s.indexOf('<body') === -1) {
        const s2 = s.indexOf('</html>');
        if (s2 >= 0)
          this.innerHtmlText = htmlText.substr(6, s2);
      }
    }
  }

  /**
   * Sets a fragment of a main image as a graphic content of this cell.
   * Cells cannot have two graphic contents, so `image` (the specific image of this cell) should
   * be cleared with this setting.
   * @param {external:HTMLImageElement} img - The image data
   * @param {module:AWT.Shape} imgClip - A shape that clips the portion of image assigned to this content.
   * @param {string} [animatedGifFile] - When `img` is an animated GIF, its file name
   */
  setImgContent(img, imgClip, animatedGifFile) {
    this.img = img;
    this.image = null;
    this.imgClip = imgClip;
    if (animatedGifFile)
      this.animatedGifFile = animatedGifFile;
  }

  /**
   * Prepares the media content
   * @param {module:JClicPlayer.JClicPlayer} playStation - Usually a {@link module:JClicPlayer.JClicPlayer JClicPlayer}
   */
  prepareMedia(playStation) {
    if (!this.amp && this.mediaContent && this.mediaContent.type === 'PLAY_VIDEO') {
      this.amp = playStation.getActiveMediaPlayer(this.mediaContent);
      this.amp.realize();
    }
  }

  /**
   * Reads and initializes the image associated to this content
   * @param {module:bags/MediaBag.MediaBag} mediaBag - The media bag of the current project.
   */
  realizeContent(mediaBag, ps = null) {
    if (this.image !== null && this.image.length > 0) {
      this.mbe = mediaBag.getElement(this.image, true);
      if (this.mbe) {
        this.mbe.build(() => {
          this.img = this.mbe.data;
          this.animatedGifFile = this.mbe.animated ? this.mbe.getFullPath() : null;
        }, ps, true);
      }
    }
    if (this.mediaContent !== null) {
      if (this.image === null && (this.text === null || this.text.length === 0)) {
        this.img = this.mediaContent.getIcon();
        this.animatedGifFile = null;
      }
    }
    this.checkHtmlText(mediaBag);
  }

  /**
   * Gets a string representing this content, useful for checking if two different contents are
   * equivalent.
   * @returns {string}
   */
  getDescription() {
    const result = [];
    if (this.text && this.text.length)
      result.push(this.text);
    if (this.image)
      result.push(`${getMsg('image')} ${this.image}`);
    if (this.imgClip)
      result.push(this.imgClip.toString());
    if (this.mediaContent)
      result.push(this.mediaContent.getDescription());
    return result.join(' ');
  }

  /**
   *
   * Overwrites the original `Object.toString` method, returning `getDescription` instead
   * @returns {string}
   */
  toString() {
    const result = [];
    if (this.text && this.text.length)
      result.push(this.text);
    if (this.image)
      result.push(`${getMsg('image')} ${this.image}`);
    if (this.imgClip)
      result.push(`${getMsg('image fragment')} ${(this.id >= 0 ? this.id : this.item) + 1}`);
    return result.join(' ') || getMsg('cell');
  }
}

Object.assign(ActiveBoxContent.prototype, {
  /**
   * The {@link module:boxes/BoxBase.BoxBase BoxBase} attribute of this content. Can be `null`, meaning {@link module:boxes/ActiveBox.ActiveBox ActiveBox} will
   * try to find a suitable style scanning down through its own BoxBase, their parent's and, finally,
   * the default values defined in `BoxBase.prototype`.
   * @name module:boxes/ActiveBoxContent.ActiveBoxContent#style
   * @type {module:boxes/BoxBase.BoxBase} */
  style: null,
  /**
   * Optimal dimension of any {@link module:boxes/ActiveBox.ActiveBox ActiveBox} taking this content.
   * @name module:boxes/ActiveBoxContent.ActiveBoxContent#dimension
   * @type {module:AWT.Dimension} */
  dimension: null,
  /**
   * The {@link module:boxes/ActiveBox.ActiveBox ActiveBox} can have or not a border despite the settings of {@link module:boxes/BoxBase.BoxBase BoxBase}.
   * The default value `null` means not to take in consideration this setting.
   * @name module:boxes/ActiveBoxContent.ActiveBoxContent#border
   * @type {boolean|null} */
  border: null,
  /**
   * The text to display on the {@link module:boxes/ActiveBox.ActiveBox ActiveBox}. It can have up to two paragraphs.
   * @name module:boxes/ActiveBoxContent.ActiveBoxContent#text
   * @type {string} */
  text: null,
  /**
   * The name of the image file to display on the {@link module:boxes/ActiveBox.ActiveBox ActiveBox}.
   * @name module:boxes/ActiveBoxContent.ActiveBoxContent#image
   * @type {string} */
  image: null,
  /**
   * An optional shape used to clip the image.
   * @name module:boxes/ActiveBoxContent.ActiveBoxContent#imgClip
   * @type {module:AWT.Shape} */
  imgClip: null,
  /**
   * The media content associated with this object.
   * @name module:boxes/ActiveBoxContent.ActiveBoxContent#mediaContent
   * @type {module:media/MediaContent.MediaContent} */
  mediaContent: null,
  /**
   * @typedef ActiveBoxContent~alignType
   * @type {object}
   * @property {string} h - Valid values are: `left`, `middle`, `right`
   * @property {string} v - Valud values are: `top`, `middle`, `bottom` */
  /**
   * The horizontal and vertical alignment of the image inside the cell.
   * @name module:boxes/ActiveBoxContent.ActiveBoxContent#imgAlign
   * @type {module:boxes/ActiveBoxContent.AlignType} */
  imgAlign: null,
  /**
   * The horizontal and vertical alignment of the text inside the cell.
   * Valid values are: `left`, `middle`, `right`, `top` and `bottom`.
   * @name module:boxes/ActiveBoxContent.ActiveBoxContent#txtAlign
   * @type {module:boxes/ActiveBoxContent.AlignType} */
  txtAlign: null,
  /**
   * Whether to avoid overlapping of image and text inside the cell when both are present.
   * @name module:boxes/ActiveBoxContent.ActiveBoxContent#avoidOverlapping
   * @type {boolean} */
  avoidOverlapping: false,
  /**
   * Numeric identifier used in activities to resolve relationships between cells
   * @name module:boxes/ActiveBoxContent.ActiveBoxContent#id
   * @type {number} */
  id: -1,
  /**
   * Numeric identifier used in activities to resolve relationships between cells
   * @name module:boxes/ActiveBoxContent.ActiveBoxContent#item
   * @type {number} */
  item: -1,
  //
  // Transient properties build and modified at run-time
  /**
   * The realized image used by this box content.
   * @name module:boxes/ActiveBoxContent.ActiveBoxContent#img
   * @type {external:HTMLImageElement} */
  img: null,
  /**
   * When `img` is an animated GIF file, this field should contain its file name
   * @name module:boxes/ActiveBoxContent.ActiveBoxContent#animatedGifFile
   * @type {string} */
  animatedGifFile: null,
  /**
   * When not null, this content should be treated as an HTML element
   * @name module:boxes/ActiveBoxContent.ActiveBoxContent#innerHtmlText
   * @type {string} */
  innerHtmlText: null,
  /**
   * The {@link module:media/ActiveMediaPlayer.ActiveMediaPlayer ActiveMediaPlayer} associated with this content. Updated at run-time.
   * @name module:boxes/ActiveBoxContent.ActiveBoxContent#amp
   * @type {module:media/ActiveMediaPlayer.ActiveMediaPlayer} */
  amp: null,
  /**
   * The {@link module:bads/MediaBagElement.MediaBagElement} associated with this content, if any. Updated at run-time.
   * @name module:boxes/ActiveBoxContent.ActiveBoxContent#mbe
   * @type {module:bags/MediaBagElement.MediaBagElement} */
  mbe: null,
});

/**
 * An empty ActiveBoxContent
 * @type {module:boxes/ActiveBoxContent.ActiveBoxContent}
 */
ActiveBoxContent.EMPTY_CONTENT = new ActiveBoxContent();

/* harmony default export */ const boxes_ActiveBoxContent = (ActiveBoxContent);

;// CONCATENATED MODULE: ./src/shapers/Shaper.js
/**
 *  File    : shapers/Shaper.js
 *  Created : 13/04/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */





/**
 * The function of this class and its subclasses is to draw a set of "shapes" that will be used to
 * place {@link module:boxes/ActiveBox.ActiveBox ActiveBox} objects at a specific position, and to determine its dimension and
 * appearance.
 */
class Shaper {
  /**
   * Shaper constructor
   * @param {number} nx - Number of columns (in grid-based shapers)
   * @param {number} ny - Number of rows (in grid-based shapers)
   */
  constructor(nx, ny) {
    this.reset(nx, ny);
  }

  /**
   * Registers a new type of shaper
   * @param {string} shaperName - The name used to identify this shaper
   * @param {function} shaperClass - The shaper class, usually extending Shaper
   * @returns {module:shapers/Shaper.Shaper} - The provided shaper class
   */
  static registerClass(shaperName, shaperClass) {
    Shaper.CLASSES[shaperName] = shaperClass;
    return shaperClass;
  }

  /**
   * Factory constructor that returns a Shaper of the requested class.
   * @param {string} className - The class name of the requested Shaper.
   * @param {number} nx - Number of columns (in grid-based shapers)
   * @param {number} ny - Number of rows (in grid-based shapers)
   * @returns {module:shapers/Shaper.Shaper}
   */
  static getShaper(className, nx, ny) {
    const cl = Shaper.CLASSES[(className || '').replace(/^edu\.xtec\.jclic\.shapers\./, '@')];
    if (!cl)
      log('error', `Unknown shaper: ${className}`);
    return cl ? new cl(nx, ny) : null;
  }

  /**
   * Initializes this Shaper to default values
   * @param {number} nCols - Number of columns
   * @param {number} nRows - Number of rows
   */
  reset(nCols, nRows) {
    this.nCols = nCols;
    this.nRows = nRows;
    this.nCells = nRows * nCols;
    this.initiated = false;
    this.shapeData = [];
    for (let i = 0; i < this.nCells; i++)
      this.shapeData[i] = new Shape();
  }

  /**
   * Loads this shaper settings from a specific JQuery XML element
   * @param {external:jQuery} $xml - The XML element with the shaper data
   */
  setProperties($xml) {
    attrForEach($xml.get(0).attributes, (name, value) => {
      switch (name) {
        case 'class':
          this.className = value;
          break;
        case 'cols':
          this.nCols = Number(value);
          break;
        case 'rows':
          this.nRows = Number(value);
          break;
        case 'baseWidthFactor':
        case 'toothHeightFactor':
        case 'scaleX':
        case 'scaleY':
          this[name] = Number(value);
          break;
        case 'randomLines':
        case 'showEnclosure':
          this[name] = getBoolean(value, true);
          break;
      }
    });

    // Reads the 'enclosing'
    // (main shape area where the other shape elements are placed)
    $xml.children('enclosing:first').each((_n, child) => {
      external_jquery_default()(child).children('shape:first').each((_n, child2) => {
        let sh = Shaper.readShapeData(child2, this.scaleX, this.scaleY);
        this.enclosing = sh;
        this.showEnclosure = true;
        this.hasRemainder = true;
      });
    });

    // Read the shape elements
    $xml.children('shape').each((n, child) => {
      this.shapeData[n] = Shaper.readShapeData(child, this.scaleX, this.scaleY);
    });

    // Correction needed for '@Holes' shaper
    if (this.shapeData.length > 0 /* && this.shapeData.length !== this.nRows * this.nCols */) {
      //this.nRows = this.shapeData.length
      //this.nCols = 1
      //this.nCells = this.nCols * this.nRows
      this.nCells = this.shapeData.length;
    }
    return this;
  }

  /**
   * Reads an individual shape from an XML element.
   * Shapes are arrays of `stroke` objects.
   * Each `stroke` has an `action` (_move to_, _line to_, _quad to_...) and associated `data`.
   * @param {external:jQuery} $xml - The XML element with the shape data
   * @param {number} scaleX
   * @param {number} scaleY
   * @returns {module:AWT.Shape}
   */
  static readShapeData(xml, scaleX, scaleY) {
    const shd = [];
    let result = null;
    external_jquery_default().each(xml.textContent.split('|'), (_n, txt) => {
      const sd = txt.split(':');
      // Possible strokes are: `rectangle`, `ellipse`, `M`, `L`, `Q`, `B`, `X`
      // Also possible, but not currently used in JClic: `roundRectangle` and `pie`
      let data = sd.length > 1 ? sd[1].split(',') : null;
      //
      // Data should be always divided by the scale (X or Y)
      if (data)
        data = data.map((d, n) => d / (n % 2 ? scaleY : scaleX));

      switch (sd[0]) {
        case 'rectangle':
          result = new Rectangle(data[0], data[1], data[2], data[3]);
          break;
        case 'ellipse':
          result = new Ellipse(data[0], data[1], data[2], data[3]);
          break;
        default:
          // It's an `AWT.PathStroke`
          shd.push(new PathStroke(sd[0], data));
          break;
      }
    });

    return !result && shd.length > 0 ? new Path(shd) : result;
  }

  /**
   * Gets a object with the basic attributes needed to rebuild this instance excluding functions,
   * parent references, constants and also attributes retaining the default value.
   * The resulting object is commonly usued to serialize elements in JSON format.
   * @returns {object} - The resulting object, with minimal attrributes
   */
  getAttributes() {
    const fields = [
      'className', 'nCols', 'nRows',
      'baseWidthFactor', 'toothHeightFactor',
      'scaleX', 'scaleY',
      'randomLines',
    ];

    if (this.customShapes) {
      ['showEnclosure', 'hasRemainder',
        'enclosing', 'shapeData', // Array of AWT.Rectangle, AWT.Ellipse or (AWT.Path -> AWT.PathStroke)
      ].forEach(f => fields.push(f));
    }

    return getAttr(this, fields);
  }

  /**
   * Builds a new shaper, based on the properties specified in a data object
   * @param {object} data - The data object to be parsed
   * @returns {module:shapers/Shaper.Shaper}
   */
  static factory(data) {
    const result = Shaper.getShaper(data.className, data.nCols, data.nRows);
    setAttr(result, data, [
      'className', 'nCols', 'nRows',
      'baseWidthFactor', 'toothHeightFactor',
      'scaleX', 'scaleY',
      'randomLines',
      'showEnclosure', 'hasRemainder',
      { key: 'enclosing', fn: Shape },
      { key: 'shapeData', fn: Shape, group: 'array' },
    ]);

    result.nCells = result.shapeData.length || result.nCols * result.nRows;

    return result;
  }

  /**
   * Builds the individual shapes that will form this Shaper
   */
  buildShapes() {
  }

  /**
   * Gets a clone of the nth Shape object, scaled and located inside a Rectangle
   * @param {number} n
   * @param {module:AWT.Rectangle} rect
   * @returns {module:AWT.Shape}
   */
  getShape(n, rect) {
    if (!this.initiated)
      this.buildShapes();
    if (n >= this.nCells || this.shapeData[n] === null)
      return null;
    return this.shapeData[n].getShape(rect);
  }

  /**
   * Gets the nth Shape data object
   * @param {number} n
   * @returns {object}
   */
  getShapeData(n) {
    return n >= 0 && n < this.shapeData.length ? this.shapeData[n] : null;
  }

  /**
   * Gets the AWT.Rectangle that contains all shapes of this Shaper.
   * @returns {module:AWT.Rectangle}
   */
  getEnclosingShapeData() {
    return new Rectangle(0, 0, 1, 1);
  }

  /**
   * When `hasRemainder` is true, this method gets the rectangle containing the full surface where
   * the Shaper develops.
   * @param {module:AWT.Rectangle} rect - The frame where to move and scale all the shapes
   * @returns {module:AWT.Rectangle}
   */
  getRemainderShape(rect) {
    if (!this.hasRemainder)
      return null;

    if (!this.initiated)
      this.buildShapes();

    const sh = this.getEnclosingShapeData();
    const r = sh ? sh.getShape(rect) : new Rectangle();
    for (let i = 0; i < this.nCells; i++) {
      if (this.shapeData[i])
        r.add(this.shapeData[i].getShape(rect), false);
    }
    return r;
  }
}

Object.assign(Shaper.prototype, {
  /**
   * This shaper class name
   * @name module:shapers/Shaper.Shaper#className
   * @type {string} */
  className: 'Shaper',
  /**
   * Number of columns (useful in grid-based shapers)
   * @name module:shapers/Shaper.Shaper#nCols
   * @type {number} */
  nCols: 0,
  /**
   * Number of rows (useful in grid-based shapers)
   * @name module:shapers/Shaper.Shaper#nRows
   * @type {number} */
  nRows: 0,
  /**
   * Number of cells managed by this shaper
   * @name module:shapers/Shaper.Shaper#nCells
   * @type {number} */
  nCells: 0,
  /**
   * Contains the specific definition of each shape
   * @name module:shapers/Shaper.Shaper#shapeData
   * @type {object} */
  shapeData: null,
  /**
   * Flag used to check if the `Shaper` has been initialized against a real surface
   * @name module:shapers/Shaper.Shaper#initiated
   * @type {boolean} */
  initiated: false,
  //
  // Fields used only in JigSaw shapers
  /**
   * In {@link module:shapers/JigSaw.JigSaw JigSaw}, ratio between the base width of the tooth and the total length of the side.
   * @name module:shapers/Shaper.Shaper#baseWidthFactor
   * @type {number} */
  baseWidthFactor: 1.0 / 3,
  /**
   * In {@link module:shapers/JigSaw.JigSaw JigSaw}, ratio between the tooth height and the total length of the side.
   * @name module:shapers/Shaper.Shaper#toothHeightFactor
   * @type {number} */
  toothHeightFactor: 1.0 / 6,
  /**
   * In {@link module:shapers/JigSaw.JigSaw JigSaw}, whether the tooths take random directions or not
   * @name module:shapers/Shaper.Shaper#randomLines
   * @type {boolean} */
  randomLines: false,
  //
  // Fields used only in the `Holes` shaper
  /**
   * In {@link module:shapers/Holes.Holes Holes}, scale to be applied to horizontal positions and lengths to achieve the real
   * value of the shape placed on a real surface.
   * @name module:shapers/Shaper.Shaper#scaleX
   * @type {number} */
  scaleX: 1.0,
  /**
   * In {@link module:shapers/Holes.Holes Holes}, scale to be applied to vertical positions and lengths to achieve the real
   * value of the shape placed on a real surface.
   * @name module:shapers/Shaper.Shaper#scaleY
   * @type {number} */
  scaleY: 1.0,
  /**
   * In {@link module:shapers/Holes.Holes Holes}, the enclosing area where all shapes are placed.
   * @name module:shapers/Shaper.Shaper#enclosing
   * @type {module:AWT.Shape} */
  enclosing: null,
  /**
   * In {@link module:shapers/Holes.Holes Holes}, when `true`, the enclosing area will be drawn
   * @name module:shapers/Shaper.Shaper#showEnclosure
   * @type {boolean} */
  showEnclosure: false,
  /**
   * Flag indicating if this shaper organizes its cells in rows and columns
   * @name module:shapers/Shaper.Shaper#rectangularShapes
   * @type {boolean} */
  rectangularShapes: false,
  /**
   * Flag indicating if this Shaper deploys over a surface biggest than the rectangle enclosing
   * all its shapes
   * @name module:shapers/Shaper.Shaper#hasRemainder
   * @type {boolean} */
  hasRemainder: false,
  /**
   * Only the `Holes` shaper has this flag activated
   * @name module:shapers/Shaper.Shaper#customShapes
   * @type {boolean} */
  customShapes: false,
});

/**
 * List of known classes derived from Shaper. It should be filled by real shaper classes at
 * declaration time.
 * @type {object} */
Shaper.CLASSES = {};

/* harmony default export */ const shapers_Shaper = (Shaper);

;// CONCATENATED MODULE: ./src/boxes/ActiveBagContent.js
/**
 *  File    : boxes/ActiveBagContent.js
 *  Created : 13/04/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */








/**
 * This class packs a collection of {@link module:boxes/ActiveBoxContent.ActiveBoxContent ActiveBoxContent} objects and provides methods to access
 * and manage it. The two main members of `ActiveBagContent` are the {@link module:shapers/Shaper.Shaper Shaper}, responsible for
 * determining the position and shape of each {@link module:boxes/ActiveBox.ActiveBox ActiveBox}, and the {@link module:boxes/BoxBase.BoxBase BoxBase} (field `style`),
 * provider of a common visual style.
 */
class ActiveBagContent {
  /**
   * ActiveBagContent constructor
   * @param {string} [id] - An optional text tag identifying this ActiveBagContent
   * @param {number} ncw - In grid-based distributions, number of columns.
   * @param {number} nch - In grid-based distributions, number of rows.
   */
  constructor(id, ncw, nch) {
    if (id)
      this.id = id;
    this.cells = [];
    this.ncw = Math.max(1, ncw);
    this.nch = Math.max(1, nch);
  }

  /**
   * Loads the object settings from a specific JQuery XML element
   * @param {external:jQuery} $xml - The XML element to parse
   * @param {module:bags/MediaBag.MediaBag} mediaBag - The project's MediaBag
   */
  setProperties($xml, mediaBag) {
    let bug = false;
    attrForEach($xml.get(0).attributes, (name, val) => {
      switch (name) {
        case 'id':
          this.id = val;
          break;
        case 'image':
          this.image = nSlash(val);
          break;
        // Bug in JClic beta 1: "columns" is number of rows, and "rows" is number of columns.
        // Was corrected in beta 2: If "cols" is specified, "rows" are rows and "cols" are columns.
        case 'rows':
          this.nch = Number(val);
          break;
        case 'columns':
          bug = true;
        /* falls through */
        case 'cols':
          this.ncw = Number(val);
          break;
        case 'cellWidth':
          this.w = Number(val);
          break;
        case 'cellHeight':
          this.h = Number(val);
          break;
        case 'border':
          this.border = getBoolean(val);
          break;
      }
    });

    if (bug) {
      let n = this.ncw;
      this.ncw = this.nch;
      this.nch = n;
    }

    $xml.children().each((_n, child) => {
      const $node = external_jquery_default()(child);
      switch (child.nodeName) {
        case 'style':
          this.style = new boxes_BoxBase(null).setProperties($node);
          break;
        case 'shaper':
          const shaperClassName = $node.attr('class'),
            nCols = Math.max(1, $node.attr('cols')),
            nRows = Math.max(1, $node.attr('rows'));
          this.shaper = shapers_Shaper.getShaper(shaperClassName, nCols, nRows);
          this.shaper.setProperties($node);
          break;
        case 'ids':
          // Used in special cases where all cells have empty content with only 'ids'
          this.ids = child.textContent;
          this.ids.split(' ').forEach((id, i) => { this.cells[i] = new boxes_ActiveBoxContent(Number(id)); });
          break;
        case 'cell':
          this.cells.push(new boxes_ActiveBoxContent().setProperties($node, mediaBag));
          break;
      }
    });

    let n = this.cells.length;

    // Create cells when `cells` is empty
    if (n === 0 && this.shaper && this.shaper.nCells > 0) {
      this.initiallyEmptyCells = true;
      n = this.shaper.nCells;
      this.getActiveBoxContent(n - 1);
    }

    // Assign ids when cells have empty content (they are just shapes)
    if (n > 0) {
      let empty = true;
      for (let i = 0; i < n; i++) {
        const bxc = this.getActiveBoxContent(i);
        if (bxc.id !== -1 || bxc.item !== -1 || !bxc.isEmpty()) {
          empty = false;
          break;
        }
      }
      if (empty) {
        for (let i = 0; i < n; i++)
          this.getActiveBoxContent(i).id = i;
      }
    }

    // Link [BoxBase](BoxBase.html) objects of `cells` elements to `style`
    if (this.style)
      this.cells.forEach((abc) => { if (abc.style) abc.style.parent = this.style; });

    return this;
  }

  /**
   * Gets a object with the basic attributes needed to rebuild this instance excluding functions,
   * parent references, constants and also attributes retaining the default value.
   * The resulting object is commonly usued to serialize elements in JSON format.
   * @returns {object} - The resulting object, with minimal attrributes
   */
  getAttributes() {
    const fields = [
      'id', 'image',
      'ncw', 'nch',
      'w', 'h', 'border',
      'style', // BoxBase
      'shaper', // Shaper
    ];
    if (!this.initiallyEmptyCells)
      fields.push(this.ids ? 'ids' : 'cells'); // ActiveBoxContent
    return getAttr(this, fields);
  }

  /**
   * Reads the properties of this ActiveBagContent from a data object
   * @param {object} data - The data object to be parsed
   * @param {module:bags/MediaBag.MediaBag} mediaBag - The project's MediaBag
   * @returns {module:boxes/ActiveBagContent.ActiveBagContent}
   */
  setAttributes(data, mediaBag) {
    setAttr(this, data, [
      'id', 'image',
      'ncw', 'nch',
      'w', 'h', 'border',
      { key: 'style', fn: boxes_BoxBase },
      { key: 'shaper', fn: shapers_Shaper },
      'ids',
      { key: 'cells', fn: boxes_ActiveBoxContent, group: 'array', params: [mediaBag] },
    ]);

    let n = this.cells.length;

    // Create cells when `cells` is empty
    if (n === 0 && this.shaper && this.shaper.nCells > 0) {
      this.initiallyEmptyCells = true;
      n = this.shaper.nCells;
      this.getActiveBoxContent(n - 1);
      if (this.ids)
        this.ids.split(' ').forEach((id, i) => { this.getActiveBoxContent(i).id = Number(id); });
    }

    // Assign ids when cells have empty content (they are just shapes)
    if (n > 0) {
      let empty = true;
      for (let i = 0; i < n; i++) {
        const bxc = this.getActiveBoxContent(i);
        if (bxc.id !== -1 || bxc.item !== -1 || !bxc.isEmpty()) {
          empty = false;
          break;
        }
      }
      if (empty) {
        for (let i = 0; i < n; i++)
          this.getActiveBoxContent(i).id = i;
      }
    }

    // Link [BoxBase](BoxBase.html) objects of `cells` elements to `style`
    if (this.style)
      this.cells.forEach(abc => { if (abc.style) abc.style.parent = this.style; });

    if (mediaBag)
      this.cells.forEach(abc => abc.realizeContent(mediaBag));

    return this;
  }

  /**
   * Prepares the media content of all elements
   * @param {module:JClicPlayer.JClicPlayer} playStation - The {@link module:JClicPlayer.JClicPlayer JClicPlayer}
   */
  prepareMedia(playStation) {
    this.cells.forEach(abc => abc.prepareMedia(playStation));
  }

  /**
   * Gets the estimated total width of this content bag
   * @returns {number}
   */
  getTotalWidth() {
    return this.w * this.ncw;
  }

  /**
   * Gets the estimated total height of this bag
   * @returns {number}
   */
  getTotalHeight() {
    return this.h * this.nch;
  }

  /**
   * Gets the total number of cells of this bag
   * @returns {number}
   */
  getNumCells() {
    return this.cells.length;
  }

  /**
   * Checks if the bag is empty
   * @returns {boolean}
   */
  isEmpty() {
    return this.cells.length === 0;
  }

  /**
   * Retrieves the {@link module:shapers/Shaper.Shaper Shaper} of this bag, creating a new one if it was _null_
   * @returns {module:shapers/Shaper.Shaper}
   */
  getShaper() {
    if (this.shaper === null)
      this.shaper = shapers_Shaper.getShaper('@Rectangular', this.ncw, this.nch);
    return this.shaper;
  }

  /**
   * Retrieves the {@link module:boxes/BoxBase.BoxBase BoxBase} of this bag, creating a new one if it was _null_
   * @returns {module:boxes/BoxBase.BoxBase}
   */
  getBoxBase() {
    if (this.style === null)
      this.style = new boxes_BoxBase();
    return this.style;
  }

  /**
   * Adds a new {@link module:boxes/ActiveBoxContent.ActiveBoxContent ActiveBoxContent} to this bag
   * @param {module:boxes/ActiveBoxContent.ActiveBoxContent} ab - The ActiveBoxContent to add
   */
  addActiveBoxContent(ab) {
    this.cells.push(ab);
    if (this.ncw === 0 || this.nch === 0) {
      this.ncw = this.nch = 1;
    }
  }

  /**
   * Gets the nth {@link module:boxes/ActiveBoxContent.ActiveBoxContent ActiveBoxContent} in `cells`
   * @param {number} i - The index of the content to be retrieved
   * @returns {module:boxes/ActiveBoxContent.ActiveBoxContent}
   */
  getActiveBoxContent(i) {
    if (i >= this.cells.length) {
      for (let j = this.cells.length; j <= i; j++)
        this.cells.push(new boxes_ActiveBoxContent());
    }
    return this.cells[i];
  }

  /**
   * Finds the ActiveBoxContent with specific `id` and `item` values
   * @param {number} id
   * @param {number} item
   * @returns {module:boxes/ActiveBoxContent.ActiveBoxContent}
   */
  getActiveBoxContentWith(id, item) {
    return this.cells.find(bxc => bxc.id === id && bxc.item === item);
  }

  /**
   * Sets the content of the cells based on a image spliced by a shaper
   * @param {module:bags/MediaBag.MediaBag} mb - The MediaBag used to retrieve the image
   * @param {module:shapers/Shaper.Shaper} sh - The Shaper used to splice the image
   * @param {boolean} roundSizes - When `true`, the size and coordinates of cells will be rounded
   * to the nearest integer values.
   */
  setImgContent(mb, sh, roundSizes) {
    if (sh)
      this.setShaper(sh);

    if (this.shaper.className === '@Holes')
      this.shaper.hasRemainder = true;

    this.ncw = this.shaper.nCols;
    this.nch = this.shaper.nRows;
    const mbe = mb.elements[this.image];
    if (mb && this.image && mbe && mbe.ready) {
      this.img = mbe.data;
      if (mbe.animated)
        this.animatedGifFile = mbe.getFullPath();
      this.w = this.img.width / this.ncw;
      this.h = this.img.height / this.nch;
      if (roundSizes) {
        this.w = Math.round(this.w);
        this.h = Math.round(this.h);
      }
    } else {
      this.img = null;
      this.w = Math.max(this.w, 10);
      this.h = Math.max(this.h, 10);
    }

    const r = new Rectangle(0, 0, this.w * this.ncw, this.h * this.nch);
    for (let i = 0; i < this.shaper.nCells; i++)
      this.getActiveBoxContent(i).setImgContent(this.img, this.shaper.getShape(i, r), this.animatedGifFile);

    if (this.shaper.hasRemainder) {
      this.backgroundContent = new boxes_ActiveBoxContent();
      this.backgroundContent.setImgContent(this.img, this.shaper.getRemainderShape(r));
    }
  }

  /**
   * Sets the content of this bag based on an array of strings
   * @param {string[]} txt - The array of strings to be used as content.
   * @param {number} setNcw - Number of columns
   * @param {number} setNch - Number of rows
   */
  setTextContent(txt, setNcw, setNch) {
    this.ncw = Math.max(1, setNcw);
    this.nch = Math.max(1, setNch);
    const n = this.ncw * this.nch;
    for (let i = 0; i < n; i++)
      this.getActiveBoxContent(i).setTextContent(i >= txt.length || txt[i] === null ? '' : txt[i]);
  }

  /**
   * Sets `id` values to a all the {@link module:boxes/ActiveBoxContent.ActiveBoxContent ActiveBoxContent} elements of his bag.
   * @param {number[]} ids -Array of numeric identifiers
   */
  setIds(ids) {
    for (let i = 0; i < ids.length && i < this.cells.length; i++)
      this.getActiveBoxContent(i).id = ids[i];
  }

  /**
   * Sets `value` to the `key` attribute of all cells
   * @param {string} key - The key where the value will be stored
   * @param {any} value - The supplied value. Can be of any type.
   */
  setCellsAttribute(key, value) {
    this.cells.forEach(abc => abc[key] = value);
  }

  /**
   *
   * Cheks if the `id` values of all {@link module:boxes/ActiveBoxContent.ActiveBoxContent ActiveBoxContent} objects are -1 and, if true,
   * sets new ids to them, with values between 0 and `maxId`
   * @param {number} maxId - The maximum value of identifiers
   */
  avoidAllIdsNull(maxId) {
    if (this.cells.every(abc => abc.id === -1)) {
      maxId = Math.max(1, maxId);
      this.cells.forEach((abc, n) => { abc.id = n % maxId; });
    }
  }
}

Object.assign(ActiveBagContent.prototype, {
  /**
   * The global identifier of this object: `primary`, `secondary`...
   * @name module:boxes/ActiveBagContent.ActiveBagContent#id
   * @type {string} */
  id: 'primary',
  /**
   * The name of the image file used as a common image of this bag
   * @name module:boxes/ActiveBagContent.ActiveBagContent#image
   * @type {string} */
  image: null,
  /**
   * The built image object
   * @name module:boxes/ActiveBagContent.ActiveBagContent#img
   * @type {external:HTMLImageElement} */
  img: null,
  /**
   * Name of the img source when is an animated GIF
   * @name module:boxes/ActiveBagContent.ActiveBagContent#animatedGifFile
   * @type {string} */
  animatedGifFile: null,
  /**
   * Number of columns when cells are distributed in a grid
   * @name module:boxes/ActiveBagContent.ActiveBagContent#ncw
   * @type {number} */
  ncw: 1,
  /**
   * Number of rows when cells are distributed in a grid
   * @name module:boxes/ActiveBagContent.ActiveBagContent#nch
   * @type {number} */
  nch: 1,
  /**
   * Optimal cell width
   * @name module:boxes/ActiveBagContent.ActiveBagContent#w
   * @type {number} */
  w: settings.DEFAULT_GRID_ELEMENT_SIZE,
  /**
   * Optimal cell height
   * @name module:boxes/ActiveBagContent.ActiveBagContent#h
   * @type {number} */
  h: settings.DEFAULT_GRID_ELEMENT_SIZE,
  /**
   * Whether the cells must have a border or not
   * @name module:boxes/ActiveBagContent.ActiveBagContent#border
   * @type {boolean} */
  border: true,
  /**
   * The BoxBase used for this bag of cell contents
   * @name module:boxes/ActiveBagContent.ActiveBagContent#style
   * @type {module:boxes/BoxBase.BoxBase} */
  style: null,
  /**
   * The Shaper used to define the specific shape of each cell
   * @name module:boxes/ActiveBagContent.ActiveBagContent#shaper
   * @type {module:shapers/Shaper.Shaper} */
  shaper: null,
  /**
   * An optional ActiveBoxContent object with background settings.
   * @name module:boxes/ActiveBagContent.ActiveBagContent#backgroundContent
   * @type {module:boxes/ActiveBoxContent.ActiveBoxContent} */
  backgroundContent: null,
  /**
   * The main Array of {@link module:boxes/ActiveBoxContent.ActiveBoxContent ActiveBoxContent} objects
   * @name module:boxes/ActiveBagContent.ActiveBagContent#cells
   * @type {module:boxes/ActiveBoxContent.ActiveBoxContent[]} */
  cells: null,
  /**
   * The default value to be assigned at the 'id' field of children
   * @name module:boxes/ActiveBagContent.ActiveBagContent#defaultIdValue
   * @type {number} */
  defaultIdValue: -1,
  /**
   * Used in special cases where all cells have empty content with only numeric identifiers
   * @name module:boxes/ActiveBagContent.ActiveBagContent#ids
   * @type {string} */
  ids: null,
});

/* harmony default export */ const boxes_ActiveBagContent = (ActiveBagContent);

;// CONCATENATED MODULE: ./src/automation/AutoContentProvider.js
/**
 *  File    : automation/AutoContentProvider.js
 *  Created : 13/04/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */



/**
 * This abstract class is the base for classes that create on-time automatic content for JClic
 * activities, usually using random parameters to assure different content in each session.
 *
 * Activities with `AutoContentProvider` objects rely on them to build new content on every start.
 */
class AutoContentProvider {
  /**
   * AutoContentProvider constructor
   */
  constructor() {
  }

  /**
   * Dynamic constructor that returns a specific type of AutoContentProvider based on the `class`
   * attribute declared on an $xml element.
   * It should be called only from {@link module:Activity.Activity#setProperties Activity.setProperties}
   * @param {external.jQuery} $xml - The XML element to parse
   * @returns {module:automation/AutoContentProvider.AutoContentProvider}
   */
  static getProvider($xml) {
    let automation = null;
    if ($xml) {
      const
        className = ($xml.attr('class') || '').replace(/^edu\.xtec\.jclic\.automation\./, '@'),
        cl = AutoContentProvider.CLASSES[className];
      if (cl) {
        automation = new cl();
        automation.setProperties($xml);
      } else
        log('error', `Unknown AutoContentProvider class: ${className}`);
    }
    return automation;
  }

  /**
   * Loads the object settings from a specific jQuery XML element
   * @param {external:jQuery} $xml - The XML element to parse
   */
  setProperties($xml) {
    this.className = ($xml.attr('class') || '').replace(/^edu\.xtec\.jclic\.automation\./, '@');
    return this;
  }

  /**
   * Gets a object with the basic attributes needed to rebuild this instance excluding functions,
   * parent references, constants and also attributes retaining the default value.
   * The resulting object is commonly usued to serialize elements in JSON format.
   * @returns {object} - The resulting object, with minimal attrributes
   */
  getAttributes() {
    // To be overrided!
    return getAttr(this, ['className']);
  }

  /**
   * Builds a new AutoContentProvider, based on the properties specified in a data object
   * @param {object} data - The data object to be parsed
   * @param {object[]} params - Optional parameters to be passed to `setAttributes`
   * @returns {module:shapers/Shaper.Shaper}
   */
  static factory(data, params = []) {
    const cl = AutoContentProvider.CLASSES[data.className];
    return (new cl()).setAttributes(data, ...params);
  }

  /**
   * Initializes the content provider
   */
  init() {
    // To be implemented in real content providers
  }

  /**
   * Builds an {@link module:automation/AutoContentProvider/ActiveBagContentKit ActiveBagContentKit} and generates the automatized content.
   * @param {number} nRows - Number of rows to be processed
   * @param {number} nCols - Number of columns to be processed
   * @param {module:boxes/ActiveBagContent.ActiveBagContent[]} content - Array with one or more containers of {@link module:boxes/ActiveBoxContent.ActiveBoxContent ActiveBoxContent}
   * objects to be filled with new content.
   * @param {boolean} useIds - When `true`, the `id` field of {@link module:boxes/ActiveBoxContent.ActiveBoxContent ActiveBoxContent} objects is significant
   * @returns {boolean} - `true` if the process was OK. `false` otherwise.
   */
  generateContent(nRows, nCols, content, useIds) {
    return this.process(new AutoContentProvider.ActiveBagContentKit(nRows, nCols, content, useIds));
  }

  /**
   * Generates the automatized content
   * @param {module:automation/AutoContentProvider.ActiveBagContentKit} _kit - The objects to be filled with content
   * @returns {boolean} - `true` if the process was OK. `false` otherwise.
   */
  process(_kit) {
    // To be implemented in subclasses
    return false;
  }

  /**
   * Registers a new type of AutoContentProvider
   * @param {string} providerName - The name used to identify this AutoContentProvider
   * @param {function} providerClass - The activity class, usually extending AutoContentProvider
   * @returns {module:automation/AutoContentProvider.AutoContentProvider} - The provider class
   */
  static registerClass(providerName, providerClass) {
    AutoContentProvider.CLASSES[providerName] = providerClass;
    return providerClass;
  }
}

Object.assign(AutoContentProvider.prototype, {
  /**
   * This AutoContentProvider manages numeric expressions, so text literals should be
   * converted to numbers for comparisions, taking in account the
   * number format of the current locale (dot or comma as decimal separator)
   * @name module:automation/AutoContentProvider.AutoContentProvider#numericContent
   * @type {boolean} */
  numericContent: false,
});

/**
 * Utility class used to encapsulate multiple sets of box contents
 * @param {number} nRows - Number of rows to be processed
 * @param {number} nCols - Number of columns to be processed
 * @param {module:boxes/ActiveBagContent.ActiveBagContent[]} content - Array with one or more containers of {@link module:boxes/ActiveBoxContent.ActiveBoxContent ActiveBoxContent}
 * objects to be filled with new content.
 * @param {boolean} useIds - `true` when the `id` field of {@link module:boxes/ActiveBoxContent.ActiveBoxContent ActiveBoxContent} objects is significant.
 */
AutoContentProvider.ActiveBagContentKit = class {
  constructor(nRows, nCols, content, useIds) {
    this.nRows = nRows;
    this.nCols = nCols;
    this.content = content;
    this.useIds = useIds;
  }
};

/**
 * Contains the current list of classes derived from AutoContentProvider.
 * This object should be updated by real automation classes at declaration time.
 * Currently, only two types of "AutoContentProvider" are defined: {@link module:automation/arith/Arith.Arith Arith} and TagReplace.
 * @type {object} */
AutoContentProvider.CLASSES = {
  // TODO: Implement TagReplace
  '@tagreplace.TagReplace': AutoContentProvider
};

// TODO: Implement TagReplace
AutoContentProvider.registerClass('@tagreplace.TagReplace', AutoContentProvider);

/* harmony default export */ const automation_AutoContentProvider = (AutoContentProvider);

;// CONCATENATED MODULE: ./src/boxes/TextGridContent.js
/**
 *  File    : boxes/TextGridContent.js
 *  Created : 14/04/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */





/**
 * This class encapsulates the content of {@link module:boxes/TextGrid.TextGrid TextGrid} objects.
 *
 * It implements methods to set and retrieve individual characters on the grid, and parsing of
 * XML objects. It also contains information about the optimal size and other graphic properties
 * (fonts, colors, etc.) of the grid.
 */
class TextGridContent {
  /**
   * TextGridContent constructor
   */
  constructor() {
    this.style = new boxes_BoxBase(null);
    this.text = [];
  }

  /**
   * Loads the object settings from a specific JQuery XML element
   * @param {external:jQuery} $xml
   */
  setProperties($xml) {
    // Read attributes
    attrForEach($xml.get(0).attributes, (name, val) => {
      switch (name) {
        case 'rows':
          // WARNING: Due to a bug in JClic, the meaning of "rows" and "columns" must be
          // interchanged:
          this.ncw = Number(val);
          break;
        case 'columns':
          this.nch = Number(val);
          break;
        case 'cellWidth':
          this.w = Number(val);
          break;
        case 'cellHeight':
          this.h = Number(val);
          break;
        case 'border':
          this.border = getBoolean(val);
          break;
        case 'wild':
        case 'randomChars':
          this[name] = val;
          break;
      }
    });

    // Read inner elements
    $xml.children('style:first').each((_n, child) => {
      this.style = new boxes_BoxBase().setProperties(external_jquery_default()(child));
    });

    $xml.find('text:first > row').each((_n, el) => this.text.push(el.textContent));

    for (let i = this.text.length; i < this.nch; i++)
      this.text[i] = '';

    return this;
  }

  /**
   * Gets a object with the basic attributes needed to rebuild this instance excluding functions,
   * parent references, constants and also attributes retaining the default value.
   * The resulting object is commonly usued to serialize elements in JSON format.
   * @returns {object} - The resulting object, with minimal attrributes
   */
  getAttributes() {
    return getAttr(this, [
      'ncw', 'nch',
      'w', 'h',
      'text',
      'style', // BoxBase
      'border',
      'wild|*',
      `randomChars|${settings.RANDOM_CHARS}`,
    ]);
  }

  /**
   * Reads the properties of this TextGridContent from a data object
   * @param {object|string} data - The data object to be parsed, or just the text content
   * @returns {module:boxes/TextGridContent.TextGridContent}
   */
  setAttributes(data) {
    return setAttr(this, data, [
      'ncw', 'nch',
      'w', 'h',
      'text',
      { key: 'style', fn: boxes_BoxBase },
      'border',
      'wild',
      `randomChars`,
    ]);
  }

  /**
   * Counts the number of wildcard characters present in this TextGrid
   * @returns {number}
   */
  countWildChars() {
    let result = 0;
    if (this.text)
      for (let y = 0; y < this.nch; y++)
        for (let x = 0; x < this.ncw; x++)
          if (this.text[y].charAt(x) === this.wild)
            result++;
    return result;
  }

  /**
   * Counts the total number of characters, including wildcard characters.
   * @returns {number}
   */
  getNumChars() {
    return this.ncw * this.nch;
  }

  /**
   * Sets the specified character as a content of the cell located at specific coordinates
   * @param {number} x - The X coordinate of the cell
   * @param {number} y - The X coordinate of the cell
   * @param {string} ch - The character to be placed on the specified cell
   */
  setCharAt(x, y, ch) {
    if (x >= 0 && x < this.ncw && y >= 0 && y < this.nch)
      this.text[y] = this.text[y].substring(0, x) + ch + this.text[y].substring(x + 1);
  }
}

Object.assign(TextGridContent.prototype, {
  /**
   * Grid columns
   * @name module:boxes/TextGridContent.TextGridContent#ncw
   * @type {number} */
  ncw: 1,
  /**
   * Grid rows
   * @name module:boxes/TextGridContent.TextGridContent#nch
   * @type {number} */
  nch: 1,
  /**
   * Width of cells
   * @name module:boxes/TextGridContent.TextGridContent#w
   * @type {number} */
  w: 20,
  /**
   * Height of cells
   * @name module:boxes/TextGridContent.TextGridContent#h
   * @type {number} */
  h: 20,
  /**
   * Whether the cells must be surrounded by a border or not
   * @name module:boxes/TextGridContent.TextGridContent#border
   * @type {boolean} */
  border: false,
  /**
   * The {@link module:boxes/BoxBase.BoxBase BoxBase} object with visual settings of the text grid
   * @name module:boxes/TextGridContent.TextGridContent#style
   * @type {module:boxes/BoxBase.BoxBase} */
  style: null,
  /**
   * An array of String objects textning the chars of cells. One string per row, one character of
   * this string per cell.
   * @name module:boxes/TextGridContent.TextGridContent#text
   * @type {string[]} */
  text: null,
  /**
   * The letter used as wildcardtext
   * @name module:boxes/TextGridContent.TextGridContent#wild
   * @type {string} */
  wild: '*',
  /**
   * A String with the chars to take as source when randomly filling empty cells
   * @name module:boxes/TextGridContent.TextGridContent#randomChars
   * @type {string} */
  randomChars: settings.RANDOM_CHARS,
});

/* harmony default export */ const boxes_TextGridContent = (TextGridContent);

;// CONCATENATED MODULE: ./src/activities/text/Evaluator.js
/**
 *  File    : activities/text/Evaluator.js
 *  Created : 14/04/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */

/* global window */



/**
 * This class and its derivatives {@link module:activities/text/Evaluator.BasicEvaluator BasicEvaluator} and
 * {@link module:activities/text/Evaluator.ComplexEvaluator ComplexEvaluator} are used to evaluate the answers written by the final users
 * in text activities.
 */
class Evaluator {
  /**
   * Evaluator constructor
   * @param {string} className - The class name of this evaluator.
   */
  constructor(className) {
    this.className = className;
    this.collator = (window.Intl && window.Intl.Collator) ?
      new window.Intl.Collator() :
      { compare: (a, b) => this.checkCase ? a === b : a.toUpperCase() === b.toUpperCase() };
  }

  /**
   * Factory constructor that returns a specific type of {@link module:activities/text/Evaluator.Evaluator Evaluator} based on the `class`
   * attribute declared in the $xml element.
   * @param {external:jQuery} $xml - The XML element to be parsed.
   * @returns {module:activities/text/Evaluator.Evaluator}
   */
  static getEvaluator($xml) {
    let ev = null;
    if ($xml) {
      const className = $xml.attr('class');
      const cl = Evaluator.CLASSES[className];
      if (cl) {
        ev = new cl(className);
        ev.setProperties($xml);
      } else
        log('error', `Unknown evaluator class: "${className}"`);
    }
    return ev;
  }

  /**
   * Loads the object settings from a specific JQuery XML element
   * @param {external:jQuery} $xml - The jQuery XML element to parse
   */
  setProperties($xml) {
    attrForEach($xml.get(0).attributes, (name, value) => {
      switch (name) {
        case 'class':
          this.className = value;
          break;
        case 'checkCase':
        case 'checkAccents':
        case 'checkPunctuation':
        case 'checkDoubleSpaces':
        case 'detail':
          this[name] = getBoolean(value);
          break;
        case 'checkSteps':
        case 'checkScope':
          this[name] = Number(value);
          break;
      }
    });
    return this;
  }

  /**
   * Builds a new Evaluator, based on the properties specified in a data object
   * @param {object} data - The data object to be parsed
   * @returns {module:activities/text/Evaluator.Evaluator}
   */
  static factory(data) {
    const cl = Evaluator.CLASSES[data.className];
    if (cl) {
      const result = new cl(data.className);
      return setAttr(result, data, [
        'className',
        'checkCase', 'checkAccents', 'checkPunctuation', 'checkDoubleSpaces', 'detail',
        'checkSteps', 'checkScope',
      ]);
    }
    return null;
  }

  /**
   * Gets a object with the basic attributes needed to rebuild this instance excluding functions,
   * parent references, constants and also attributes retaining the default value.
   * The resulting object is commonly usued to serialize elements in JSON format.
   * @returns {object} - The resulting object, with minimal attrributes
   */
  getAttributes() {
    return getAttr(this, [
      'className',
      'checkCase', 'checkAccents', 'checkPunctuation', 'checkDoubleSpaces', 'detail',
      'checkSteps', 'checkScope',
    ]);
  }

  /**
   * Initializes this evaluator
   * @param {string[]} _locales - An array of valid locales, to be used by Intl.Collator
   */
  init(_locales) {
    this.initiated = true;
  }

  /**
   * Checks the given text against a set of valid matches
   * @param {string} text - The text to be checked
   * @param {string|string[]} match - The valid expression or expressions with which to compare.
   * @returns {boolean} - `true` if the checked expression is valid, `false` otherwise.
   */
  checkText(text, match) {
    if (match instanceof Array)
      return match.some(m => this._checkText(text, m));
    else if (match)
      return this._checkText(text, match);
    else
      return false;
  }

  /**
   * Abstract method to be implemented in subclasses.
   * Performs the validation of a string against a single match.
   * @param {string} _text - The text to be checked
   * @param {string} _match - A valid expression with which to compare.
   * @returns {boolean} - `true` when the two expressions can be considered equivalent.
   */
  _checkText(_text, _match) {
    return false;
  }

  /**
   * Evaluates the given text against a set of valid matches, returning an array of flags useful
   * to indicate where the mistakes are located.
   * @param {string} text - The text to be checked
   * @param {string|string[]} match - The valid expression or expressions with which to compare.
   * @returns {number[]} - An array of flags (one number for character) indicating whether each
   * position is erroneous or ok.
   */
  evalText(text, match) {
    if (!(match instanceof Array))
      match = [match];
    return this._evalText(text, match);
  }

  /**
   * Abstract method to be implemented in subclasses.
   * Performs the evaluation of a string against an array of valid matches, returning an array of
   * flags useful to indicate where the mistakes are located.
   * @param {string} _text - The text to be checked
   * @param {string} _match - A valid expression with which to compare.
   * @returns {number[]} - An array of flags (one number for character) indicating whether each
   * position is erroneous or OK.
   */
  _evalText(_text, _match) {
    return [];
  }

  /**
   * Checks if the given array of flags (usually returned by `evalText`) can be considered as a
   * valid or erroneous answer.
   * @param {number[]} flags
   * @returns {boolean} - `true` when there is at least one flag and all flags are 0 (meaning no error).
   */
  isOk(flags) {
    return flags && flags.length > 0 && !flags.some(f => f !== 0);
  }
}

Object.assign(Evaluator.prototype, {
  /**
   * The type of evaluator.
   * @name module:activities/text/Evaluator.Evaluator#className
   * @type {string} */
  className: null,
  /**
   * Whether this evaluator has been initialized or not.
   * @name module:activities/text/Evaluator.Evaluator#initiated
   * @type {boolean} */
  initiated: false,
  /**
   * The Intl.Collator object used to compare strings, when available.
   * @name module:activities/text/Evaluator.Evaluator#collator
   * @type {external:Collator} */
  collator: null,
  /**
   * Whether uppercase and lowercase expressions must be considered equivalent or not.
   * @name module:activities/text/Evaluator.Evaluator#checkcase
   * @type {boolean} */
  checkCase: false,
});

/**
 * A basic evaluator that just compares texts, without looking for possible coincidences of text
 * fragments once erroneous characters removed.
 * @extends module:activities/text/Evaluator.Evaluator
 */
class BasicEvaluator extends Evaluator {
  /**
   * BasicEvaluator constructor
   * @param {string} className - The class name of this evaluator.
   */
  constructor(className) {
    super(className);
  }

  /**
   * Initializes the {@link module:activities/text/Evaluator.Evaluator#collator collator}.
   * @override
   * @param {string[]} locales - An array of valid locales to be used by the Inlt.Collator object
   */
  init(locales) {
    // Call `init` method on ancestor
    super.init([locales]);

    // Get canonical locales
    if (window.Intl && window.Intl.Collator) {
      this.collator = new window.Intl.Collator(locales, {
        sensitivity: this.checkAccents ? this.checkCase ? 'case' : 'accent' : 'base',
        ignorePunctuation: !this.checkPunctuation
      });
    }
  }

  /**
   * Performs the validation of a string against a single match.
   * @override
   * @param {string} text - The text to be checked
   * @param {string} match - A valid expression with which to compare.
   * @returns {boolean} - `true` when the two expressions can be considered equivalent.
   */
  _checkText(text, match) {
    return this.collator.compare(this.getClearedText(text), this.getClearedText(match)) === 0;
  }

  /**
   * Performs the evaluation of a string against an array of valid matches, returning an array of
   * flags useful to indicate where the mistakes are located.
   * In BasicEvaluator, all characters are just marked as 1 (error) or 0 (OK). See
   * {@link module:activities/text/Evaluator.ComplexEvaluator ComplexEvaluator} for more detailed analysis of answers.
   * @override
   * @param {string} text - The text to be checked
   * @param {string} match - A valid expression with which to compare.
   * @returns {number[]} - An array of flags (one number for character) indicating whether each
   * position is erroneous or OK.
   */
  _evalText(text, match) {
    return Array(text.length).fill(this._checkText(text, match[0]) ? 0 : 1);
  }

  /**
   * Removes double spaces and erroneous characters from a given text expression.
   * @param {string} src - The text to be processed.
   * @param {boolean[]} skipped - An array of boolean indicating which characters should be removed
   * from the string.
   * @returns {string}
   */
  getClearedText(src, skipped) {
    if (this.checkPunctuation && this.checkDoubleSpaces)
      return src;

    if (!skipped)
      skipped = Array(src.length).fill(false);

    let sb = '';
    for (let i = 0, wasSpace = false; i < src.length; i++) {
      const ch = src.charAt(i);
      if (this.PUNCTUATION.indexOf(ch) >= 0 && !this.checkPunctuation) {
        if (!wasSpace)
          sb += ' ';
        else
          skipped[i] = true;
        wasSpace = true;
      } else if (ch === ' ') {
        if (this.checkDoubleSpaces || !wasSpace)
          sb += ch;
        else
          skipped[i] = true;
        wasSpace = true;
      } else {
        wasSpace = false;
        sb += ch;
      }
    }
    return sb;
  }
}

Object.assign(BasicEvaluator.prototype, {
  /**
   * Whether accented letters must be considered equivalent or not.
   * @name module:activities/text/Evaluator.BasicEvaluator#checkAccents
   * @type {boolean} */
  checkAccents: true,
  /**
   * Whether to check or not dots, commas and other punctuation marks when comparing texts.
   * @name module:activities/text/Evaluator.BasicEvaluator#checkPunctuation
   * @type {boolean} */
  checkPunctuation: true,
  /**
   * Whether to check or not the extra spaces added between words.
   * @name module:activities/text/Evaluator.BasicEvaluator#checkDoubleSpaces
   * @type {boolean} */
  checkDoubleSpaces: false,
  /**
   * String containing all the characters considered as punctuation marks (currently ".,;:")
   * @name module:activities/text/Evaluator.BasicEvaluator#PUNCTUATION
   * @type {string} */
  PUNCTUATION: '.,;:',
});

/**
 * ComplexEvaluator acts like {@link module:activities/text/Evaluator.BasicEvaluator BasicEvaluator}, but providing feedback about
 * the location of mistakes on the user's answer.
 * @extends module:activities/text/Evaluator.BasicEvaluator
 */
class ComplexEvaluator extends BasicEvaluator {
  /**
   * ComplexEvaluator constructor
   * @param {string} className - The class name of this evaluator.
   */
  constructor(className) {
    super(className);
  }

  /**
   * Performs the evaluation of a string against an array of valid matches, returning an array of
   * flags useful to indicate where the mistakes are located.
   * In BasicEvaluator, all characters are just marked as 1 (error) or 0 (OK). See
   * {@link module:activities/text/Evaluator.ComplexEvaluator ComplexEvaluator} for more detailed analysis of answers.
   * @override
   * @param {string} text - The text to be checked
   * @param {string} match - A valid expression with which to compare.
   * @returns {number[]} - An array of flags (one number for character) indicating whether each
   * position is erroneous or OK.
   */
  _evalText(text, match) {

    if (!this.detail)
      return super._evalText(text, match);

    const
      skipped = Array(text.length).fill(false),
      sText = this.getClearedText(text, skipped),
      numChecks = Array(match.length),
      flags = Array(match.length),
      returnFlags = Array(text.length);
    let
      maxCheck = -1,
      maxCheckIndex = -1;

    for (let i = 0; i < match.length; i++) {
      flags[i] = Array(text.length).fill(0);
      const ok = this.compareSegment(sText, sText.length, match[i], match[i].length, flags[i], false);
      numChecks[i] = this.countFlagsOk(flags[i]);
      if (ok) {
        maxCheckIndex = i;
        maxCheck = numChecks[i];
      }
    }

    if (maxCheckIndex === -1) {
      for (let i = 0; i < match.length; i++) {
        if (numChecks[i] > maxCheck) {
          maxCheck = numChecks[i];
          maxCheckIndex = i;
        }
      }
    }

    for (let i = 0, k = 0; i < text.length; i++)
      returnFlags[i] = skipped[i] ? 0 : flags[maxCheckIndex][k++];

    return returnFlags;
  }

  /**
   * Counts the number of flags on the provided array that are zero.
   * @param {number[]} flags
   * @returns {number}
   */
  countFlagsOk(flags) {
    return flags.reduce((n, v) => v == 0 ? ++n : n, 0);
  }

  /**
   * Compares two segments of text.
   * This function should make recursive calls.
   * @param {string} src - Text to be compared
   * @param {number} ls - Offset in `src` where to start the comparison
   * @param {string} ok - Text to match against.
   * @param {number} lok - Offset in `ok` where to start the comparison.
   * @param {number[]} attr - Array of integers that will be filled with information about the
   * validity or error of each character in `src`.
   * @param {boolean} iterate - When `true`, the segment will be iterated looking for other
   * coincident fragments.
   * @returns {boolean} - `true` if the comparison was valid.
   */
  compareSegment(src, ls, ok, lok, attr, iterate) {
    let
      is = 0,
      iok = 0,
      lastIs = 0,
      lastiok = true,
      result = true,
      chs = '',
      chok = '';

    if (ls === 0 || lok === 0 || src === null || ok === null)
      return false;

    for (; is < ls; is++, iok++) {
      chs = src.charAt(is);
      lastIs = is;
      if (iok >= 0 && iok < lok)
        chok = ok.charAt(iok);
      else
        chok = 0;
      if (this.collator.compare(chs, chok) === 0) {
        attr[is] = 0;
        lastiok = true;
      } else {
        result = false;
        attr[is] = 1;
        if (!iterate && lastiok && chok !== 0 && this.checkSteps > 0 && this.checkScope > 0) {
          const
            lbloc = 2 * this.checkSteps + 1,
            itcoinc = [];
          let i = 0, j = 0;
          for (; j < lbloc; j++) {
            itcoinc[j] = 0;
            i = iok + Math.floor((j + 1) / 2) * ((j & 1) !== 0 ? 1 : -1);
            if (i >= lok)
              continue;
            const is2 = i < 0 ? is - i : is;
            if (is2 >= ls)
              continue;
            const
              ls2 = Math.min(ls - is2, this.checkScope),
              iok2 = i < 0 ? 0 : i,
              lok2 = Math.min(lok - iok2, this.checkScope),
              flags2 = Array(src.length - is2).fill(0),
              result2 = this.compareSegment(src.substring(is2), ls2, ok.substring(iok2), lok2, flags2, true);
            itcoinc[j] = this.countFlagsOk(flags2);
            if (result2)
              break;
          }
          if (j === lbloc) {
            let jmax = this.checkSteps;
            for (j = 0; j < lbloc; j++)
              if (itcoinc[j] > itcoinc[jmax])
                jmax = j;
            i = iok + Math.floor((jmax + 1) / 2) * ((jmax & 1) !== 0 ? 1 : -1);
          }
          iok = i;
          lastiok = false;
        }
      }
    }
    if (iok !== lok) {
      result = false;
      attr[lastIs] = 1;
    }
    return result;
  }
}

Object.assign(ComplexEvaluator.prototype, {
  /**
   * Whether to detail or not the location of errors found on the analyzed text.
   * @name module:activities/text/Evaluator.ComplexEvaluator#detail
   * @type {boolean} */
  detail: true,
  /**
   * Number of times to repeat the evaluation process if an error is found, eliminating in each
   * cycle the extra characters that caused the error.
   * @name module:activities/text/Evaluator.ComplexEvaluator#checkSteps
   * @type {number} */
  checkSteps: 3,
  /**
   * When an eror is detected in the analyzed expression, this variable indicates the number of
   * characters the checking pointer will be moved forward and back looking for a coincident
   * expression.
   *
   * For example, comparing the answer "_one lardzy dog_" with the correct answer "_one lazy dog_"
   * will detect an error at position 6 (an "r" instead of "z"). If `checkSteps` is set to 2 or
   * greater, the "_zy dog_" expression at position 8 will be found and evaluated as valid, while
   * a value of 1 or less will not found any coincident expression beyond the error position, thus
   * evaluating all the remaining sentence as erroneous.
   * @name module:activities/text/Evaluator.ComplexEvaluator#checkScope
   * @type {number} */
  checkScope: 6,
});

// List of known Evaluator classes
Evaluator.CLASSES = {
  '@BasicEvaluator': BasicEvaluator,
  '@ComplexEvaluator': ComplexEvaluator
};

/* harmony default export */ const text_Evaluator = (Evaluator);

;// CONCATENATED MODULE: ./src/activities/text/TextActivityDocument.js
/**
 *  File    : activities/text/TextActivityDocument.js
 *  Created : 14/04/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */






/**
 * This is the HTML DOM element used in text activities like {@link module:activities/text/FillInBlanks.FillInBlanks FillInBlanks},
 * {@link module:activities/text/IdentifyText.IdentifyText IdentifyText}, {@link module:activities/text/OrderText.OrderText OrderText} and {@link module:activities/text/Complete.Complete Complete}. It contains the main document of
 * the activity, usually with some elements marked as "targets". In {@link module:activities/text/FillInBlanks.FillInBlanks FillInBlanks}, this
 * targets are encapsulated in {@link module:activities/text/TextActivityDocument.TextTarget TextTarget} objects.
 */
class TextActivityDocument {
  /**
   * TextActivityDocument constructor
   */
  constructor() {
    // Make a deep clone of the default style
    this.style = { 'default': { ...TextActivityDocument.DEFAULT_DOC_STYLE } };
    this.p = [];
  }

  /**
   * Loads the document settings from a specific JQuery XML element
   * @param {external:jQuery} $xml - The XML element to parse
   * @param {module:bags/MediaBag.MediaBag} mediaBag - The media bag used to load images and media content
   */
  setProperties($xml, mediaBag) {
    // Read named styles
    // Sort styles according to its "base" dependencies
    const styles = $xml.children('style').toArray().sort((a, b) => {
      var aName = a.getAttribute('name'), aBase = a.getAttribute('base') || null;
      var bName = b.getAttribute('name'), bBase = b.getAttribute('base') || null;
      // Put 'default' always first, then each style below their base (if any)
      return aName === 'default' ? -1 : bName === 'default' ? 1
        : aBase === bName ? 1 : bBase === aName ? -1
          : !aBase ? -1 : !bBase ? 1 : 0;
    });

    // Process the ordered list of styles
    styles.forEach(style => {
      const attr = this.readDocAttributes(external_jquery_default()(style));
      // Grant always that basic attributes are defined
      this.style[attr.name] = attr.name === 'default' ? external_jquery_default().extend(true, this.style.default, attr) : attr;
    });

    // Read paragraphs
    $xml.find('section > p').each((_n, par) => {

      const p = { elements: [] };

      // Read paragraph attributes
      attrForEach(par.attributes, (name, value) => {
        switch (name) {
          case 'style':
            p[name] = value;
            break;
          case 'bidiLevel':
          case 'Alignment':
            p[name] = Number(value);
            break;
        }
      });

      // Read paragraph objects
      external_jquery_default()(par).children().each((_n, child) => {
        let obj;
        const $child = external_jquery_default()(child);
        switch (child.nodeName) {

          case 'cell':
            obj = new boxes_ActiveBoxContent().setProperties($child, mediaBag);
            break;

          case 'text':
            obj = { text: child.textContent.replace(/\t/g, '&#9;') };
            const attr = this.readDocAttributes($child);
            if (!external_jquery_default().isEmptyObject(attr)) {
              obj.attr = attr;
            }
            break;

          case 'target':
            obj = new TextTarget(this, child.textContent.replace(/\t/g, '&#9;'));
            obj.setProperties($child, mediaBag);
            this.numTargets++;
            break;

          default:
            log('error', `Unknown object in activity document: "${child.nodeName}"`);
        }
        if (obj) {
          obj.objectType = child.nodeName;
          p.elements.push(obj);
        }
      });

      this.p.push(p);
    });
    return this;
  }

  /**
   * Reads sets of text attributes, sometimes in form of named styles
   * @param {external:jQuery} $xml - The XML element to parse
   * @returns {object}
   */
  readDocAttributes($xml) {
    let
      attr = {},
      css = {};
    attrForEach($xml.get(0).attributes, (name, val) => {
      switch (name) {
        case 'background':
          val = checkColor(val, 'white');
          attr[name] = val;
          css['background-color'] = val;
          break;
        case 'foreground':
          val = checkColor(val, 'black');
          attr[name] = val;
          css['color'] = val;
          break;
        case 'family':
          css['font-family'] = val;
        /* falls through */
        case 'name':
        case 'style':
          // Attributes specific to named styles:
          attr[name] = val;
          break;
        case 'base':
          attr[name] = val;
          // If base style exists, merge it with current settings
          if (this.style[val]) {
            //attr = Object.apply({}, this.style[val], attr)
            attr = external_jquery_default().extend(true, {}, this.style[val], attr);
            if (this.style[val].css)
              //css = Object.apply({}, this.style[val].css, css)
              css = external_jquery_default().extend({}, this.style[val].css, css);
          }
          break;
        case 'bold':
          val = getBoolean(val);
          attr[name] = val;
          css['font-weight'] = val ? 'bold' : 'normal';
          break;
        case 'italic':
          val = getBoolean(val);
          attr[name] = val;
          css['font-style'] = val ? 'italic' : 'normal';
          break;
        case 'target':
          attr[name] = getBoolean(val);
          break;
        case 'size':
          attr[name] = Number(val);
          css['font-size'] = `${val}px`;
          break;
        case 'tabWidth':
          // `tab-size` CSS attribute is only set when the document has a specific `tabWidth`
          // setting. It must be accompanied of `white-space:pre` to successfully work.
          this.tabSpc = val;
          css['tab-size'] = this.tabSpc;
          css['white-space'] = 'pre-wrap';
          break;
        default:
          log('warn', `Unknown text attribute: "${name}" = "${val}"`);
          attr[name] = val;
          break;
      }
    });

    if (!external_jquery_default().isEmptyObject(css))
      attr['css'] = css;

    return attr;
  }

  /**
   * Gets a object with the basic attributes needed to rebuild this instance excluding functions,
   * parent references, constants and also attributes retaining the default value.
   * The resulting object is commonly usued to serialize elements in JSON format.
   * @returns {object} - The resulting object, with minimal attrributes
   */
  getAttributes() {
    // TODO: simplify the serialization of styles (now too verbose!)
    return getAttr(this, ['style', 'tabSpc', 'targetType', 'p']);
  }

  /**
   * Reads the properties of this TextActivityDocument from a data object
   * @param {object} data - The data object to be parsed, or just the text content
   * @returns {module:activities/text/TextActivityDocument.TextActivityDocument}
   */
  setAttributes(data, mediaBag) {

    setAttr(this, data, ['style', 'tabSpc', 'targetType', 'p']);

    // Build paragraphs:
    this.p.forEach(p => {
      if (p.elements)
        p.elements = p.elements.map(el => {
          if (el.objectType === 'cell')
            return (new boxes_ActiveBoxContent()).setAttributes(el, mediaBag);
          else if (el.objectType === 'target')
            return (new TextTarget(this)).setAttributes(el, mediaBag);
          else
            return el;
        });
      else
        p.elements = [];
    });
    return this;
  }

  /**
   * Gets the full text of this document in raw format
   * @returns {string} - The text of the document.
   */
  getRawText() {
    const $html = external_jquery_default()('<div/>');
    // Process paragraphs
    this.p.forEach(p => {
      // Creates a new DOM paragraph
      const $p = external_jquery_default()('<p/>');
      let empty = true;
      // Process the paragraph elements
      p.elements.forEach(element => {
        switch (element.objectType) {
          case 'text':
          case 'target':
            $p.append(element.text);
            break;
          case 'cell':
            // cells are not considered raw text of the document
            break;
          default:
            break;
        }
        empty = false;
      });
      if (empty) {
        // Don't leave paragraphs empty
        $p.html('&nbsp;');
      }
      // Adds the paragraph to the DOM element
      $html.append($p);
    });
    return $html.text().trim();
  }

  /**
   * Gets a `style` object filled with default attributes plus attributes present in the
   * requested style name.
   * @param {string} name - The requested style name
   * @returns {object} - The result of combining `default` with the requested style
   */
  getFullStyle(name) {
    const st = external_jquery_default().extend(true, {}, this.style.default);
    return external_jquery_default().extend(true, st, this.style[name] ? this.style[name] : {});
    //return Object.assign({}, this.style.default, this.style[name] ? this.style[name] : {})
  }
}

/**
 * Default style
 */
TextActivityDocument.DEFAULT_DOC_STYLE = {
  background: '0xFFFFFF',
  foreground: '0x000000',
  family: 'Arial',
  bold: false,
  italic: false,
  size: 17,
  css: {
    'background-color': '#FFFFFF',
    'color': '#000000',
    'font-family': 'Arial',
    'font-weight': 'normal',
    'font-style': 'normal',
    'font-size': '17px',
  },
};

Object.assign(TextActivityDocument.prototype, {
  /**
   * Number of blank spaces between tabulators.
   * @name module:activities/text/TextActivityDocument.TextActivityDocument#tabSpc
   * @type {number} */
  tabSpc: 12,
  /**
   * Index of the last {@link module:boxes/ActiveBox.ActiveBox ActiveBox} activated.
   * @name module:activities/text/TextActivityDocument.TextActivityDocument#lastBoxId
   * @type {number} */
  lastBoxId: 0,
  /**
   * A bag of {@link module:activities/text/TextActivityDocument.TargetMarker TargetMarker} objects
   * @name module:activities/text/TextActivityDocument.TextActivityDocument#tmb
   * @type {object} */
  tmb: null,
  /**
   * Number of targets
   * @name module:activities/text/TextActivityDocument.TextActivityDocument#numTargets
   * @type {number} */
  numTargets: 0,
  /**
   * Type of targets used in this activity. Possible values are: `TT_FREE`, `TT_CHAR`, `TT_WORD`
   * and `TT_PARAGRAPH`.
   * @name module:activities/text/TextActivityDocument.TextActivityDocument#targetType
   * @type {string} */
  targetType: 'TT_FREE',
  /**
   * Collection of named styles of the document
   * @name module:activities/text/TextActivityDocument.TextActivityDocument#style
   * @type {object} */
  style: null,
  /**
   * The main document, represented as a collection of DOM objects
   * @name module:activities/text/TextActivityDocument.TextActivityDocument#p
   * @type {object} */
  p: null,
});

/**
 * This class contains the properties and methods of the document elements that are the real
 * targets of user actions in text activities.
 */
class TextTarget {
  /**
   * TextTarget constructor
   * @param {module:activities/text/TextActivityDocument.TextActivityDocument} doc - The document to which this target belongs.
   * @param {string} text - Main text of this target.
   */
  constructor(doc, text = '') {
    this.doc = doc;
    this.text = text;
    this.numIniChars = text.length;
    this.answers = [text];
    this.maxLenResp = this.numIniChars;
  }

  /**
   * Resets the TextTarget status
   * @param {string} [status] - The `targetStatus` to be established. Default is `NOT_EDITED`
   */
  reset(status) {
    this.targetStatus = status ? status : 'NOT_EDITED';
    this.flagModified = false;
  }

  /**
   * Loads the text target settings from a specific JQuery XML element
   * @param {external:jQuery} $xml - The XML element to parse
   * @param {module:bags/MediaBag.MediaBag} mediaBag - The media bag used to load images and media content
   */
  setProperties($xml, mediaBag) {
    let firstAnswer = true;
    // Read specific nodes
    $xml.children().each((_n, child) => {
      const $node = external_jquery_default()(child);
      switch (child.nodeName) {
        case 'answer':
          if (firstAnswer) {
            firstAnswer = false;
            this.answers = [];
          }
          if (this.answers === null)
            this.answers = [];
          this.answers.push(child.textContent);
          break;

        case 'optionList':
          $node.children('option').each((_n, opChild) => {
            this.isList = true;
            if (this.options === null)
              this.options = [];
            this.options.push(opChild.textContent);
          });
          break;

        case 'response':
          this.iniChar = getVal($node.attr('fill'), this.iniChar).charAt(0);
          // Use underscores instead of whitespace chars
          if (settings.WHITESPACES.indexOf(this.iniChar) >= 0)
            this.iniChar = '_';
          this.numIniChars = getNumber($node.attr('length'), this.numIniChars);
          this.maxLenResp = getNumber($node.attr('maxLength'), this.maxLenResp);
          this.iniText = getVal($node.attr('show'), this.iniText);
          break;

        case 'info':
          this.infoMode = getVal($node.attr('mode'), 'always');
          this.popupDelay = getNumber($node.attr('delay'), this.popupDelay);
          this.popupMaxTime = getNumber($node.attr('maxTime'), this.popupMaxTime);
          $node.children('media').each((_n, media) => {
            this.onlyPlay = true;
            this.popupContent = new boxes_ActiveBoxContent();
            this.popupContent.mediaContent = new media_MediaContent().setProperties(external_jquery_default()(media));
          });
          if (!this.popupContent) {
            $node.children('cell').each((_n, cell) => {
              this.popupContent = new boxes_ActiveBoxContent().setProperties(external_jquery_default()(cell), mediaBag);
            });
          }
          break;

        case 'text':
          this.text = child.textContent.replace(/\t/g, '&#9;');
          const attr = this.doc.readDocAttributes(external_jquery_default()(child));
          if (!external_jquery_default().isEmptyObject(attr))
            this.attr = attr;
          break;

        default:
          break;
      }
    });
  }

  /**
   * Gets a object with the basic attributes needed to rebuild this instance excluding functions,
   * parent references, constants and also attributes retaining the default value.
   * The resulting object is commonly usued to serialize elements in JSON format.
   * @returns {object} - The resulting object, with minimal attrributes
   */
  getAttributes() {
    return getAttr(this, [
      'objectType', 'text', 'attr', 'isList',
      'answers', 'options', 'iniChar', 'numIniChars', 'maxLenResp', 'iniText',
      'infoMode', 'popupDelay', 'popupKey', 'popupMaxTime', 'onlyPlay',
      'popupContent',
    ]);
  }

  /**
   * Reads the properties of this TextTarget from a data object
   * @param {object} data - The data object to be parsed, or just the text content
   * @returns {module:activities/text/TextActivityDocument.TextTarget}
   */
  setAttributes(data, mediaBag) {
    return setAttr(this, data, [
      'objectType', 'text', 'attr', 'isList',
      'answers', 'options', 'iniChar', 'numIniChars', 'maxLenResp', 'iniText',
      'infoMode', 'popupDelay', 'popupKey', 'popupMaxTime', 'onlyPlay',
      { key: 'popupContent', fn: boxes_ActiveBoxContent, params: [mediaBag] },
    ]);
  }

  /**
   * Gets a string with all valid answers of this TextTarget. Useful for reporting users' activity.
   * @returns {string}
   */
  getAnswers() {
    return this.answers ? this.answers.join('|') : '';
  }

  /**
   * Sets specific colors to the target jQuery element, based on its `targetStatus` value. Red
   * color usually means error.
   */
  checkColors() {
    const $element = this.$comboList || this.$span;
    if ($element) {
      const style = this.doc.style[
        this.targetStatus === 'WITH_ERROR' ? 'targetError' :
          this.targetStatus === 'HIDDEN' ? 'default' : 'target'];
      if (style && style.css) {
        $element.css(style.css);
      }
    }
  }

  /**
   * Fills the `currentText` member with the text currently hosted in $span or selected in $comboList
   * @returns {string} - The current text of this target
   */
  readCurrentText() {
    if (this.$span)
      this.currentText = this.$span.text();
    else if (this.$comboList)
      this.currentText = this.$comboList.val();
    return this.currentText;
  }
}

Object.assign(TextTarget.prototype, {
  /**
   * The {@link module:activities/text/TextActivityDocument.TextActivityDocument TextActivityDocument} to which this target belongs
   * @name module:activities/text/TextActivityDocument.TextTarget#doc
   * @type {module:activities/text/TextActivityDocument.TextActivityDocument} */
  doc: null,
  /**
   * The current text displayed by this TextTarget
   * @name module:activities/text/TextActivityDocument.TextTarget#text
   * @type {string} */
  text: null,
  /**
   * A set of optional attributes for `text`
   * @name module:activities/text/TextActivityDocument.TextTarget#attr
   * @type {object} */
  attr: null,
  /**
   * `true` when the target is a drop-down list
   * @name module:activities/text/TextActivityDocument.TextTarget#isList
   * @type {boolean} */
  isList: false,
  /**
   * Number of characters initially displayed on the text field
   * @name module:activities/text/TextActivityDocument.TextTarget#numIniChars
   * @type {number} */
  numIniChars: 1,
  /**
   * Character used to fill-in the text field
   * @name module:activities/text/TextActivityDocument.TextTarget#iniChar
   * @type {string} */
  iniChar: '_',
  /**
   * Maximum length of the answer
   * @name module:activities/text/TextActivityDocument.TextTarget#maxLenResp
   * @type {number} */
  maxLenResp: 0,
  /**
   * Array of valid answers
   * @name module:activities/text/TextActivityDocument.TextTarget#answers
   * @type {string[]} */
  answers: null,
  /**
   * Set of specific options
   * @name module:activities/text/TextActivityDocument.TextTarget#options
   * @type {object} */
  options: null,
  /**
   * Text displayed by the target when the activity begins
   * @name module:activities/text/TextActivityDocument.TextTarget#iniText
   * @type {string} */
  iniText: null,
  /**
   * Type of additional information offered to the user. Possible values are: `no_info`, `always`,
   * `onError` and `onDemand`.
   * @name module:activities/text/TextActivityDocument.TextTarget#infoMode
   * @type {string} */
  infoMode: 'no_info',
  /**
   * Key that triggers the associated popup when `infoMode` is `onDemand`
   * @name module:activities/text/TextActivityDocument.TextTarget#popupKey
   * @type {string} */
  popupKey: 'F1',
  /**
   * An optional {@link module:boxes/ActiveBoxContent.ActiveBoxContent ActiveBoxContent} with information about this TextTarget
   * @name module:activities/text/TextActivityDocument.TextTarget#popupContent
   * @type {module:boxes/ActiveBoxContent.ActiveBoxContent} */
  popupContent: null,
  /**
   * Time (seconds) to wait before showing the additional information
   * @name module:activities/text/TextActivityDocument.TextTarget#popupDelay
   * @type {number} */
  popupDelay: 0,
  /**
   * Maximum amount of time (seconds) that the additional information will be shown
   * @name module:activities/text/TextActivityDocument.TextTarget#popupMaxTime
   * @type {number} */
  popupMaxTime: 0,
  /**
   * When this flag is `true` and `popupContent` contains audio, no visual feedback will be
   * provided (meaning that audio will be just played)
   * @name module:activities/text/TextActivityDocument.TextTarget#onlyPlay
   * @type {boolean} */
  onlyPlay: false,
  //
  // TRANSIENT PROPERTIES
  //
  /**
   * The drop-down list associated to this target
   * @name module:activities/text/TextActivityDocument.TextTarget#$comboList
   * @type {external:jQuery} */
  $comboList: null,
  /**
   * The span element associated to this target
   * @name module:activities/text/TextActivityDocument.TextTarget#$span
   * @type {external:jQuery} */
  $span: null,
  /**
   * The paragraph element where $span is currently located
   * @name module:activities/text/TextActivityDocument.TextTarget#$p
   * @type {external:jQuery} */
  $p: null,
  /**
   * The span element containing the popup
   * @name module:activities/text/TextActivityDocument.TextTarget#$popup
   * @type {external:jQuery} */
  $popup: null,
  /**
   * Current text in the $span element
   * @name module:activities/text/TextActivityDocument.TextTarget#currentText
   * @type {string} */
  currentText: '',
  /**
   * Ordinal number of this target in the collection of targets
   * @name module:activities/text/TextActivityDocument.TextTarget#num
   * @type {number} */
  num: 0,
  /**
   * Current ordinal position of this target in the document
   * (used in {@link module:activities/text/OrderText.OrderText OrderText} activities)
   * @name module:activities/text/TextActivityDocument.TextTarget#pos
   * @type {number} */
  pos: 0,
  /**
   * Current status of the target. Valid values are: `NOT_EDITED`, `EDITED`, `SOLVED`, `WITH_ERROR` and `HIDDEN`
   * @name module:activities/text/TextActivityDocument.TextTarget#targetStatus
   * @type {string} */
  targetStatus: 'NOT_EDITED',
  /**
   * Flag to control if the initial content of this TextTarget has been modified
   * @name module:activities/text/TextActivityDocument.TextTarget#flagModified
   * @type {boolean} */
  flagModified: false,
  /**
   * Pointer to the activity panel containing this TextTarget
   * @name module:activities/text/TextActivityDocument.TextTarget#parentPane
   * @type {module:activities/text/TextActivityBase.TextActivityBasePanel} */
  parentPane: null,
});

TextActivityDocument.TextTarget = TextTarget;

/* harmony default export */ const text_TextActivityDocument = (TextActivityDocument);

;// CONCATENATED MODULE: ./src/Activity.js
/**
 *  File    : Activity.js
 *  Created : 07/04/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */

/* global window */













// Event used for detecting touch devices
const TOUCH_TEST_EVENT = 'touchstart';

/**
 * Activity is the abstract base class of JClic activities. It defines also the inner class
 * {@link module:Activity.ActivityPanel ActivityPanel}, wich is responsible for user interaction with the activity
 * content.
 * Activities should extend both `Activity` and `ActivityPanel` classes in order to become fully
 * operative.
 * @abstract
 */
class Activity {
  /**
   * Activity constructor
   * @param {module:project/JClicProject.JClicProject} project - The {@link module:project/JClicProject.JClicProject JClicProject} to which this activity belongs
   */
  constructor(project) {
    this.project = project;
    this.eventSounds = new media_EventSounds(this.project.settings.eventSounds);
    this.messages = {};
    this.abc = {};
  }

  /**
   * Registers a new type of activity
   * @param {string} activityName - The name used to identify this activity
   * @param {function} activityClass - The activity class, usually extending Activity
   * @returns {module:Activity.Activity} - The provided activity class
   */
  static registerClass(activityName, activityClass) {
    Activity.CLASSES[activityName] = activityClass;
    return activityClass;
  }

  /**
   * Factory constructor that returns a specific type of Activity based on the `class` attribute
   * declared in `data`.
   * @param {object|external:jQuery} data - Can be a jQuery XML element, or an object obtained with a call to `getAttributes`
   * @param {module:project/JClicProject.JClicProject} project - The {@link module:project/JClicProject.JClicProject JClicProject} to which this activity belongs
   * @returns {module:Activity.Activity}
   */
  static getActivity(data, project) {
    let act = null;
    const isXml = data.jquery && true;
    if (data && project) {
      const className = isXml ? (data.attr('class') || '').replace(/^edu\.xtec\.jclic\.activities\./, '@') : data.className;
      const cl = Activity.CLASSES[className];
      if (cl) {
        act = new cl(project);
        if (isXml)
          act.setProperties(data);
        else
          act.setAttributes(data);
      } else
        log('error', `Unknown activity class: ${className}`);
    }
    return act;
  }

  /**
   * Loads this object settings from an XML element
   * @param {external:jQuery} $xml - The jQuery XML element to parse
   */
  setProperties($xml) {

    // Read attributes
    attrForEach($xml.get(0).attributes, (name, val) => {
      switch (name) {
        // Generic attributes:
        case 'name':
          val = nSlash(val);
        /* falls through */
        case 'code':
        case 'type':
        case 'description':
          this[name] = val;
          break;

        case 'class':
          this.className = val.replace(/^edu\.xtec\.jclic\.activities\./, '@');
          break;

        case 'inverse':
          this.invAss = getBoolean(val, false);
          break;

        case 'autoJump':
        case 'forceOkToAdvance':
        case 'amongParagraphs':
          this[name] = getBoolean(val, false);
          break;
      }
    });

    // Read specific nodes
    $xml.children().each((_n, child) => {
      const $node = external_jquery_default()(child);
      switch (child.nodeName) {
        case 'settings':
          // Read more attributes
          attrForEach($node.get(0).attributes, (name, val) => {
            switch (name) {
              case 'infoUrl':
              case 'infoCmd':
                this[name] = val;
                break;

              case 'margin':
              case 'maxTime':
              case 'maxActions':
                this[name] = Number(val);
                break;

              case 'report':
                this.includeInReports = getBoolean(val, false);
                break;
              case 'countDownTime':
              case 'countDownActions':
              case 'reportActions':
              case 'useOrder':
              case 'dragCells':
                this[name] = getBoolean(val, false);
                break;
            }
          });

          // Read elements of _settings_
          $node.children().each((_n, child) => {
            const $node = external_jquery_default()(child);
            switch (child.nodeName) {
              case 'skin':
                this.skinFileName = $node.attr('file');
                break;

              case 'helpWindow':
                this.helpMsg = getXmlText(this);
                this.showSolution = getBoolean($node.attr('showSolution'), false);
                this.helpWindow = this.helpMsg !== null || this.showSolution;
                break;

              case 'container':
                // Read settings related to the 'container'
                // (the main panel containing the activity and other elements)
                this.bgColor = checkColor($node.attr('bgColor'), settings.BoxBase.BACK_COLOR);

                $node.children().each((_n, child) => {
                  const $child = external_jquery_default()(child);
                  switch (child.nodeName) {
                    case 'image':
                      this.bgImageFile = $child.attr('name');
                      this.tiledBgImg = getBoolean($child.attr('tiled'), false);
                      break;
                    case 'counters':
                      this.bTimeCounter = getBoolean($child.attr('time'), true);
                      this.bActionsCounter = getBoolean($child.attr('actions'), true);
                      this.bScoreCounter = getBoolean($child.attr('score'), true);
                      break;
                    case 'gradient':
                      this.bgGradient = new Gradient().setProperties($child);
                      break;
                  }
                });
                break;

              case 'window':
                // Read settings related to the 'window'
                // (the panel where the activity deploys its content)
                this.activityBgColor = checkColor($node.attr('bgColor'), settings.DEFAULT_BG_COLOR);
                this.transparentBg = getBoolean($node.attr('transparent'), false);
                this.border = getBoolean($node.attr('border'), false);
                $node.children().each((_n, child) => {
                  const $child = external_jquery_default()(child);
                  switch (child.nodeName) {
                    case 'gradient':
                      this.activityBgGradient = new Gradient().setProperties($child);
                      break;
                    case 'position':
                      this.absolutePosition = new Point().setProperties($child);
                      this.absolutePositioned = true;
                      break;
                    case 'size':
                      this.windowSize = new Dimension().setProperties($child);
                      break;
                  }
                });
                break;

              case 'eventSounds':
                // eventSounds is already created in constructor,
                // just read properties
                this.eventSounds.setProperties($node);
                break;
            }
          });
          break;

        case 'messages':
          $node.children('cell').each((_n, child) => {
            const m = this.readMessage(external_jquery_default()(child));
            // Possible message types are: `initial`, `final`, `previous`, `finalError`
            this.messages[m.type] = m;
          });
          break;

        case 'automation':
          // Read the automation settings ('Arith' or other automation engines)
          this.acp = automation_AutoContentProvider.getProvider($node, this.project);
          if (this.acp)
            this.numericContent = this.acp.numericContent;
          break;

        // Settings specific to panel-type activities (puzzles, associations...)
        case 'cells':
          // Read the [ActiveBagContent](ActiveBagContent.html) objects
          const cellSet = new boxes_ActiveBagContent().setProperties($node, this.project.mediaBag);
          // Valid ids:
          // - Panel activities: 'primary', 'secondary', solvedPrimary'
          // - Textpanel activities: 'acrossClues', 'downClues', 'answers'
          this.abc[cellSet.id] = cellSet;
          break;

        case 'scramble':
          // Read the 'shuffle' mode
          this.shuffles = Number($node.attr('times'));
          this.shuffleA = getBoolean($node.attr('primary'));
          this.shuffleB = getBoolean($node.attr('secondary'));
          break;

        case 'layout':
          attrForEach($node.get(0).attributes, (name, value) => {
            switch (name) {
              case 'position':
                this.boxGridPos = value;
                break;
              case 'wildTransparent':
              case 'upperCase':
              case 'checkCase':
                this[name] = getBoolean(value);
            }
          });
          break;

        // Element specific to 'Menu' activities:
        case 'menuElement':
          this.menuElements.push({
            caption: $node.attr('caption') || '',
            icon: $node.attr('icon') || null,
            projectPath: $node.attr('path') || null,
            sequence: $node.attr('sequence') || null,
            description: $node.attr('description') || ''
          });
          break;

        // Element specific to 'CrossWord' and
        // 'WordSearch' activities:
        case 'textGrid':
          // Read the 'textGrid' element into a 'TextGridContent'
          this.tgc = new boxes_TextGridContent().setProperties($node);
          break;

        // Read the clues of 'WordSearch' activities
        case 'clues':
          // Read the array of clues
          this.clues = [];
          this.clueItems = [];
          $node.children('clue').each((n, child) => {
            this.clueItems[n] = Number(external_jquery_default()(child).attr('id'));
            this.clues[n] = child.textContent;
          });
          break;

        // Elements specific to text activities:
        case 'checkButton':
          this.checkButtonText = child.textContent || 'check';
          break;

        case 'prevScreen':
          this.prevScreen = true;
          this.prevScreenMaxTime = $node.attr('maxTime') || -1;
          $node.children().each((_n, child) => {
            switch (child.nodeName) {
              case 'style':
                this.prevScreenStyle = new boxes_BoxBase().setProperties(external_jquery_default()(child));
                break;
              case 'p':
                if (this.prevScreenText === null)
                  this.prevScreenText = '';
                this.prevScreenText += `<p>${child.textContent}</p>`;
                break;
            }
          });
          break;

        case 'evaluator':
          this.ev = text_Evaluator.getEvaluator($node);
          break;

        case 'document':
          // Read main document of text activities
          this.document = new text_TextActivityDocument().setProperties($node, this.project.mediaBag);
          break;
      }
    });
    return this;
  }

  /**
   * Read an activity message from an XML element
   * @param {external:jQuery} $xml - The XML element to be parsed
   * @returns {module:boxes/ActiveBoxContent.ActiveBoxContent}
   */
  readMessage($xml) {
    const msg = new boxes_ActiveBoxContent().setProperties($xml, this.project.mediaBag);
    //
    // Allowed types are: `initial`, `final`, `previous`, `finalError`
    msg.type = $xml.attr('type');
    if (isNullOrUndef(msg.style))
      msg.style = new boxes_BoxBase(null);
    return msg;
  }

  /**
   * Gets a object with the basic attributes needed to rebuild this instance excluding functions,
   * parent references, constants and also attributes retaining the default value.
   * The resulting object is commonly usued to serialize elements in JSON format.
   * @returns {object} - The resulting object, with minimal attrributes
   */
  getAttributes() {
    return getAttr(this, [
      'name', 'className', 'code', 'type', 'description',
      'invAss', 'numericContent',
      'autoJump', 'forceOkToAdvance', 'amongParagraphs',
      'infoUrl', 'infoCmd',
      `margin|${settings.DEFAULT_MARGIN}`, 'maxTime', 'maxActions',
      'includeInReports|true', 'reportActions|false',
      'countDownTime', 'countDownActions',
      'useOrder', 'dragCells',
      'skinFileName',
      'showSolution|false', 'helpMsg',
      `bgColor|${settings.DEFAULT_BG_COLOR}`, 'bgImageFile', 'tiledBgImg',
      'bTimeCounter|true', 'bActionsCounter|true', 'bScoreCounter|true',
      `activityBgColor|${settings.DEFAULT_BG_COLOR}`, 'transparentBg|false', 'border|true',
      'shuffleA', 'shuffleB', 'shuffles', 'boxGridPos',
      'wildTransparent', 'upperCase', 'checkCase',
      'checkButtonText',
      'prevScreen', 'prevScreenMaxTime', 'prevScreenText',
      'bgGradient', 'activityBgGradient', // Gradient
      'absolutePosition', // Point
      'windowSize', // Dimension
      'eventSounds', // EventSounds
      'messages', // ActiveBoxContent{}
      'acp', // AutoContentProvider
      'abc', // ActiveBagContent{}
      'menuElements', // Activity~menuElement
      'tgc', // TextGridContent
      'clues', // string[]
      'clueItems', // number[]
      'prevScreenStyle', // BoxBase
      'ev', // Evaluator
      'document', // TextActivityDocument
    ]);
  }

  /**
   * Load the activity settings from a data object
   * @param {object} data - The data object to parse
   */
  setAttributes(data, mediaBag = this.project.mediaBag) {
    setAttr(this, data, [
      'name', 'className', 'code', 'type', 'description', 'invAss', 'numericContent',
      'autoJump', 'forceOkToAdvance', 'amongParagraphs', 'infoUrl', 'infoCmd',
      'margin', 'maxTime', 'maxActions', 'includeInReports', 'reportActions',
      'countDownTime', 'countDownActions', 'useOrder', 'dragCells', 'skinFileName',
      'showSolution', 'helpMsg', 'bgColor', 'bgImageFile', 'tiledBgImg',
      'bTimeCounter', 'bActionsCounter', 'bScoreCounter',
      'activityBgColor', 'transparentBg', 'border',
      'shuffleA', 'shuffleB', 'shuffles', 'boxGridPos',
      'wildTransparent', 'upperCase', 'checkCase', 'checkButtonText',
      'prevScreen', 'prevScreenMaxTime', 'prevScreenText',
      { key: 'bgGradient', fn: Gradient },
      { key: 'activityBgGradient', fn: Gradient },
      { key: 'absolutePosition', fn: Point },
      { key: 'windowSize', fn: Dimension },
      { key: 'messages', fn: boxes_ActiveBoxContent, group: 'object', init: 'key', params: [mediaBag] },
      { key: 'abc', fn: boxes_ActiveBagContent, group: 'object', init: 'key', params: [mediaBag] },
      { key: 'acp', fn: automation_AutoContentProvider, params: [mediaBag] },
      'menuElements',
      { key: 'tgc', fn: boxes_TextGridContent },
      'clues',
      'clueItems',
      { key: 'prevScreenStyle', fn: boxes_BoxBase },
      { key: 'ev', fn: text_Evaluator },
      { key: 'document', fn: text_TextActivityDocument, params: [mediaBag] },
    ]);

    // Reused objects
    if (data.eventSounds)
      this.eventSounds.setAttributes(data.eventSounds);

    // Manual settings
    if (this.absolutePosition)
      this.absolutePositioned = true;

    return this;
  }

  /**
   * Initialises the {@link module:automation/AutoContentProvider.AutoContentProvider AutoContentProvider}, when defined.
   */
  initAutoContentProvider() {
    if (this.acp !== null)
      this.acp.init();
  }

  /**
   * Preloads the media content of the activity.
   * @param {module:JClicPlayer.JClicPlayer} ps - The {@link module:JClicPlayer.JClicPlayer} used to realize the media objects.
   */
  prepareMedia(ps) {
    this.eventSounds.realize(ps, this.project.mediaBag);
    external_jquery_default().each(this.messages, (_key, msg) => {
      if (msg !== null) msg.prepareMedia(ps);
    });
    external_jquery_default().each(this.abc, (_key, abc) => {
      if (abc !== null)
        abc.prepareMedia(ps);
    });
    return true;
  }

  /**
   * Whether the activity allows the user to request the solution.
   * @returns {boolean}
   */
  helpSolutionAllowed() {
    return false;
  }

  /**
   * Whether the activity allows the user to request help.
   * @returns {boolean}
   */
  helpWindowAllowed() {
    return this.helpWindow &&
      (this.helpSolutionAllowed() && this.showSolution || this.helpMsg !== null);
  }

  /**
   * Retrieves the minimum number of actions needed to solve this activity.
   * @returns {number}
   */
  getMinNumActions() {
    return 0;
  }

  /**
   * When this method returns `true`, the automatic jump to the next activity must be paused at
   * this activity.
   * @returns {boolean}
   */
  mustPauseSequence() {
    return this.getMinNumActions() !== 0;
  }

  /**
   * Whether or not the activity can be reset
   * @returns {boolean}
   */
  canReinit() {
    return true;
  }

  /**
   * Whether or not the activity has additional information to be shown.
   * @returns {boolean}
   */
  hasInfo() {
    return this.infoUrl !== null && this.infoUrl.length > 0 ||
      this.infoCmd !== null && this.infoCmd.length > 0;
  }

  /**
   * Whether or not the activity uses random to shuffle internal components
   * @returns {boolean}
   */
  hasRandom() {
    return false;
  }

  /**
   * When `true`, the activity must always be shuffled
   * @returns {boolean}
   */
  shuffleAlways() {
    return false;
  }

  /**
   * When `true`, the activity makes use of the keyboard
   * @returns {boolean}
   */
  needsKeyboard() {
    return false;
  }

  /**
   * Called when the activity must be disposed
   */
  end() {
    this.eventSounds.close();
    this.clear();
  }

  /**
   * Called when the activity must reset its internal components
   */
  clear() {
  }

  /**
   *
   * Getter method for `windowSize`
   * @returns {module:AWT.Dimension}
   */
  getWindowSize() {
    return new Dimension(this.windowSize);
  }

  /**
   * Setter method for `windowSize`
   * @param {module:AWT.Dimension} windowSize
   */
  setWindowSize(windowSize) {
    this.windowSize = new Dimension(windowSize);
  }

  /**
   * Builds the {@link module:Activity.ActivityPanel ActivityPanel} object.
   * Subclasses must update the `Panel` member of its prototypes to produce specific panels.
   * @param {module:JClicPlayer.JClicPlayer} ps - The {@link module:JClicPlayer.JClicPlayer JClicPlayer} used to build media objects.
   * @returns {module:Activity.ActivityPanel}
   */
  getActivityPanel(ps) {
    return new this.constructor.Panel(this, ps);
  }
}

/**
 * Classes derived from `Activity` should register themselves by adding a field to
 * `Activity.CLASSES` using `Activity.registerClass`
 * @type {object}
 */
Activity.CLASSES = {
  '@panels.Menu': Activity
};

Object.assign(Activity.prototype, {
  /**
   * The {@link module:project/JClicProject.JClicProject JClicProject} to which this activity belongs
   * @name module:Activity.Activity#project
   * @type {module:project/JClicProject.JClicProject} */
  project: null,
  /**
   * The Activity name
   * @name module:Activity.Activity#name
   * @type {string} */
  name: settings.DEFAULT_NAME,
  /**
   * The class name of this Activity
   * @name module:Activity.Activity#className
   * @type {string} */
  className: null,
  /**
   * Code used in reports to filter queries. Default is `null`.
   * @name module:Activity.Activity#code
   * @type {string} */
  code: null,
  /**
   * Type of activity, used in text activities to distinguish between different variants of the
   * same activity. Possible values are: `orderWords`, `orderParagraphs`, `identifyWords` and
   * `identifyChars`.
   * @name module:Activity.Activity#type
   * @type {string} */
  type: null,
  /**
   * A short description of the activity
   * @name module:Activity.Activity#description
   * @type {string} */
  description: null,
  /**
   * The space between the activity components measured in pixels.
   * @name module:Activity.Activity#margin
   * @type {number} */
  margin: settings.DEFAULT_MARGIN,
  /**
   * The background color of the activity panel
   * @name module:Activity.Activity#bgColor
   * @type {string} */
  bgColor: settings.DEFAULT_BG_COLOR,
  /**
   * When set, gradient used to draw the activity window background
   * @name module:Activity.Activity#bgGradient
   * @type {module:AWT.Gradient} */
  bgGradient: null,
  /**
   * Whether the bgImage (if any) has to be tiled across the panel background
   * @name module:Activity.Activity#tiledBgImg
   * @type {boolean} */
  tiledBgImg: false,
  /**
   * Filename of the image used as a panel background.
   * @name module:Activity.Activity#bgImageFile
   * @type {string} */
  bgImageFile: null,
  /**
   * Whether to draw a border around the activity panel
   * @name module:Activity.Activity#border
   * @type {boolean} */
  border: true,
  /**
   * Whether to place the activity panel at the point specified by `absolutePosition` or leave
   * it centered on the main player's window.
   * @name module:Activity.Activity#absolutePositioned
   * @type {boolean} */
  absolutePositioned: false,
  /**
   * The position of the activity panel on the player.
   * @name module:Activity.Activity#absolutePosition
   * @type {module:AWT.Point} */
  absolutePosition: null,
  /**
   * Whether to generate usage reports
   * @name module:Activity.Activity#includeInReports
   * @type {boolean} */
  includeInReports: true,
  /**
   * Whether to send action events to the {@link module:Reporter.Reporter Reporter}
   * @name module:Activity.Activity#reportActions
   * @type {boolean} */
  reportActions: false,
  /**
   * Whether to allow help about the activity or not.
   * @name module:Activity.Activity#helpWindow
   * @type {boolean} */
  helpWindow: false,
  /**
   * Whether to show the solution on the help window.
   * @name module:Activity.Activity#showSolution
   * @type {boolean} */
  showSolution: false,
  /**
   * Message to be shown in the help window when `showSolution` is `false`.
   * @name module:Activity.Activity#helpMsg
   * @type {string} */
  helpMsg: '',
  /**
   * Specific set of {@link module:media/EventSounds.EventSounds EventSounds} used in the activity. The default is `null`, meaning
   * to use the default event sounds.
   * @name module:Activity.Activity#eventSounds
   * @type {module:media/EventSounds.EventSounds} */
  eventSounds: null,
  /**
   * Wheter the activity must be solved in a specific order or not.
   * @name module:Activity.Activity#useOrder
   * @type {boolean} */
  useOrder: false,
  /**
   * Wheter the cells of the activity will be dragged across the screen.
   * When `false`, a line will be painted to link elements.
   * @name module:Activity.Activity#dragCells
   * @type {boolean} */
  dragCells: false,
  /**
   * File name of the Skin used by the activity. The default value is `null`, meaning that the
   * activity will use the skin specified for the project.
   * @name module:Activity.Activity#skinFileName
   * @type {string} */
  skinFileName: null,
  /**
   * Maximum amount of time (seconds) to solve the activity. The default value is 0, meaning
   * unlimited time.
   * @name module:Activity.Activity#maxTime
   * @type {number}*/
  maxTime: 0,
  /**
   * Whether the time counter should display a countdown when `maxTime > 0`
   * @name module:Activity.Activity#countDownTime
   * @type {boolean} */
  countDownTime: false,
  /**
   * Maximum number of actions allowed to solve the activity. The default value is 0, meaning
   * unlimited actions.
   * @name module:Activity.Activity#maxActions
   * @type {number}*/
  maxActions: 0,
  /**
   * Whether the actions counter should display a countdown when `maxActions > 0`
   * @name module:Activity.Activity#countDownActions
   * @type {boolean} */
  countDownActions: false,
  /**
   * URL to be launched when the user clicks on the 'info' button. Default is `null`.
   * @name module:Activity.Activity#infoUrl
   * @type {string} */
  infoUrl: null,
  /**
   * System command to be launched when the user clicks on the 'info' button. Default is `null`.
   * Important: this parameter is currently not being used
   * @name module:Activity.Activity#infoCmd
   * @type {string} */
  infoCmd: null,
  /**
   * The content of the initial, final, previous and error messages shown by the activity.
   * @name module:Activity.Activity#messages
   * @type {module:boxes/ActiveBoxContent.ActiveBoxContent[]} */
  messages: null,
  /**
   * Preferred dimension of the activity window
   * @name module:Activity.Activity#windowSize
   * @type {module:AWT.Dimension} */
  windowSize: new Dimension(settings.DEFAULT_WIDTH, settings.DEFAULT_HEIGHT),
  /**
   * Whether the activity window has transparent background.
   * @name module:Activity.Activity#transparentBg
   * @type {boolean} */
  transparentBg: false,
  /**
   * The background color of the activity
   * @name module:Activity.Activity#activityBgColor
   * @type {string} */
  activityBgColor: settings.DEFAULT_BG_COLOR,
  /**
   * Gradient used to draw backgrounds inside the activity.
   * @name module:Activity.Activity#activityBgGradient
   * @type {module:AWT.Gradient} */
  activityBgGradient: null,
  /**
   * Whether to display or not the 'time' counter
   * @name module:Activity.Activity#bTimeCounter
   * @type {boolean} */
  bTimeCounter: true,
  /**
   * Whether to display or not the 'score' counter
   * @name module:Activity.Activity#bScoreCounter
   * @type {boolean} */
  bScoreCounter: true,
  /**
   * Whether to display or not the 'actions' counter
   * @name module:Activity.Activity#bActionsCounter
   * @type {boolean} */
  bActionsCounter: true,
  /**
   * Special object used to generate random content at the start of the activity
   * @name module:Activity.Activity#acp
   * @type {module:automation/AutoContentProvider.AutoContentProvider} */
  acp: null,
  //
  // Fields used only in certain activity types
  // ------------------------------------------
  //
  /**
   * Array of bags with the description of the content to be displayed on panels and cells.
   * @name module:Activity.Activity#abc
   * @type {module:boxes/ActiveBagContent.ActiveBagContent[]} */
  abc: null,
  /**
   * Content of the grid of letters used in crosswords and shuffled letters
   * @name module:Activity.Activity#tgc
   * @type {module:boxes/TextGridContent.TextGridContent} */
  tgc: null,
  /**
   * The main document used in text activities
   * @name module:Activity.Activity#document
   * @type {module:activities/text/TextActivityDocument.TextActivityDocument} */
  document: null,
  /**
   * Relative position of the text grid (uses the same position codes as box grids)
   * @name module:Activity.Activity#boxGridPos
   * @type {string} */
  boxGridPos: 'AB',
  /**
   * Number of times to shuffle the cells at the beginning of the activity
   * @name module:Activity.Activity#shuffles
   * @type {number} */
  shuffles: settings.DEFAULT_SHUFFLES,
  /**
   * Box grid A must be shuffled.
   * @name module:Activity.Activity#shuffleA
   * @type {boolean} */
  shuffleA: true,
  /**
   * Box grid B must be shuffled.
   * @name module:Activity.Activity#shuffleB
   * @type {boolean} */
  shuffleB: true,
  /**
   * Flag to indicate "inverse resolution" in complex associations
   * @name module:Activity.Activity#invAss
   * @type {boolean} */
  invAss: false,
  /**
   * Array of menu elements, used in activities of type {@link module:activities/panels/Menu.Menu Menu}
   * @name module:Activity.Activity#menuElements
   * @type {object[]} */
  menuElements: null,
  /**
   * This activity uses numeric expressions, so text literals should be
   * converted to numbers for comparisions, taking in account the
   * number format of the current locale (dot or comma as decimal separator)
   * @name module:Activity.Activity#numericContent
   * @type {boolean} */
  numericContent: false,
});

/**
 * This object is responsible for rendering the contents of the activity on the screen and
 * managing user's interaction.
 * Each type of Activity must implement its own `ActivityPanel`.
 * In JClic, {@link http://projectestac.github.io/jclic/apidoc/edu/xtec/jclic/Activity.Panel.html Activity.Panel}
 * extends {@link http://docs.oracle.com/javase/7/docs/api/javax/swing/JPanel.html javax.swing.JPanel}.
 * On this implementation, the JPanel will be replaced by an HTML `div` tag.
 * @extends module:AWT.Container
 */
class ActivityPanel extends Container {
  /**
   * ActivityPanel constructor
   * @param {module:Activity.Activity} act - The {@link module:Activity.Activity Activity} to which this Panel belongs
   * @param {module:JClicPlayer.JClicPlayer} ps - Any object implementing the methods defined in the
   * {@link http://projectestac.github.io/jclic/apidoc/edu/xtec/jclic/PlayStation.html PlayStation}
   * Java interface.
   * @param {external:jQuery} [$div] - The jQuery DOM element where this Panel will deploy
   */
  constructor(act, ps, $div) {
    // ActivityPanel extends Container
    super();
    this.act = act;
    this.ps = ps;
    this.minimumSize = new Dimension(100, 100);
    this.preferredSize = new Dimension(500, 400);
    if ($div)
      this.$div = $div;
    else
      this.$div = external_jquery_default()('<div/>', { class: 'JClicActivity', 'aria-label': getMsg('Activity panel') });
    this.act.initAutoContentProvider();
  }

  /**
   * Sets the size and position of this activity panel
   * @param {module:AWT.Rectangle} rect
   */
  setBounds(rect) {
    this.pos.x = rect.pos.x;
    this.pos.y = rect.pos.y;
    this.dim.width = rect.dim.width;
    this.dim.height = rect.dim.height;

    this.invalidate(rect);
    this.$div.css({
      position: 'relative',
      left: rect.pos.x,
      top: rect.pos.y,
      width: rect.dim.width,
      height: rect.dim.height
    });
  }

  /**
   * Prepares the visual components of the activity
   */
  buildVisualComponents() {
    this.playing = false;
    this.skin = null;
    if (this.act.skinFileName && this.act.skinFileName.length > 0 && this.act.skinFileName !== this.act.project.settings.skinFileName)
      this.skin = this.act.project.mediaBag.getSkinElement(this.act.skinFileName, this.ps);

    this.bgImage = null;
    if (this.act.bgImageFile && this.act.bgImageFile.length > 0) {
      const mbe = this.act.project.mediaBag.getElement(this.act.bgImageFile, true);
      if (mbe)
        this.bgImage = mbe.data;
    }

    this.backgroundColor = this.act.activityBgColor;

    if (this.act.transparentBg)
      this.backgroundTransparent = true;

    // TODO: fix bevel-border type
    if (this.act.border)
      this.border = true;

    const cssAct = {
      display: 'block',
      'background-color': this.backgroundTransparent ? 'transparent' : this.backgroundColor
    };

    // Border shadow style Material Design, inspired in [http://codepen.io/Stenvh/pen/EaeWqW]
    if (this.border) {
      cssAct['box-shadow'] = '0 2px 5px 0 rgba(0, 0, 0, 0.16), 0 2px 10px 0 rgba(0, 0, 0, 0.12)';
      cssAct['border-radius'] = '2px';
      cssAct['color'] = '#272727';
    }

    if (this.act.activityBgGradient)
      cssAct['background-image'] = this.act.activityBgGradient.getCss();

    this.$div.css(cssAct);
  }

  /**
   * Activities should implement this method to update the graphic content of its panel. The method
   * will be called from {@link module:AWT.Container#update} when needed.
   * @param {module:AWT.Rectangle} dirtyRegion - Specifies the area to be updated. When `null`,
   * it's the whole panel.
   */
  updateContent(dirtyRegion) {
    // To be overridden by subclasses. Here does nothing.
    return super.updateContent(dirtyRegion);
  }

  /**
   * Plays the specified event sound
   * @param {string} event - The type of event to be performed
   */
  playEvent(event) {
    this.act.eventSounds.play(event);
  }

  /**
   * Basic initialization procedure, common to all activities.
   */
  initActivity() {
    if (this.playing) {
      this.playing = false;
      this.ps.reportEndActivity(this.act, this.solved);
    }
    this.solved = false;
    this.ps.reportNewActivity(this.act, 0);
    this.attachEvents();
    this.enableCounters();
  }

  /**
   * Called when the activity starts playing
   */
  startActivity() {
    this.playing = true;
  }

  /**
   * Called by {@link module:JClicPlayer.JClicPlayer JClicPlayer} when this activity panel is fully visible, just after the
   * initialization process.
   */
  activityReady() {
    // To be overrided by subclasses
  }

  /**
   * Displays help about the activity
   */
  showHelp() {
    // To be overrided by subclasses
  }

  /**
   * Sets the real dimension of this ActivityPanel.
   * @param {module:AWT.Dimension} maxSize - The maximum surface available for the activity panel
   * @returns {module:AWT.Dimension}
   */
  setDimension(maxSize) {
    return new Dimension(
      Math.min(maxSize.width, this.act.windowSize.width),
      Math.min(maxSize.height, this.act.windowSize.height));
  }

  /**
   * Attaches the events specified in the `events` member to the `$div` member
   */
  attachEvents() {
    this.events.forEach(ev => this.attachEvent(this.$div, ev));
    // Prepare handler to check if we are in a touch device
    if (!settings.TOUCH_DEVICE && external_jquery_default().inArray(TOUCH_TEST_EVENT, this.events) === -1)
      this.attachEvent(this.$div, TOUCH_TEST_EVENT);
  }

  /**
   * Attaches a single event to the specified object
   * @param {external:jQuery} $obj - The object to which the event will be attached
   * @param {string} evt - The event name
   */
  attachEvent($obj, evt) {
    $obj.on(evt, this, event => {
      if (event.type === TOUCH_TEST_EVENT) {
        if (!settings.TOUCH_DEVICE)
          settings.TOUCH_DEVICE = true;
        if (external_jquery_default().inArray(TOUCH_TEST_EVENT, this.events) === -1) {
          // Disconnect handler
          $obj.off(TOUCH_TEST_EVENT);
          return;
        }
      }
      return event.data.processEvent.call(event.data, event);
    });
  }

  /**
   * Main handler used to process mouse, touch, keyboard and edit events.
   * @param {external:Event} event - The HTML event to be processed
   * @returns {boolean} - When this event handler returns `false`, jQuery will stop its
   * propagation through the DOM tree. See: {@link http://api.jquery.com/on}
   */
  processEvent(_event) {
    return false;
  }

  /**
   * Fits the panel within the `proposed` rectangle. The panel can occupy more space, but always
   * not surpassing the `bounds` rectangle.
   * @param {module:AWT.Rectangle} proposed - The proposed rectangle
   * @param {module:AWT.Rectangle} bounds - The maximum allowed bounds
   */
  fitTo(proposed, bounds) {
    const origin = new Point();
    if (this.act.absolutePositioned && this.act.absolutePosition !== null) {
      origin.x = Math.max(0, this.act.absolutePosition.x + proposed.pos.x);
      origin.y = Math.max(0, this.act.absolutePosition.y + proposed.pos.y);
      proposed.dim.width -= this.act.absolutePosition.x;
      proposed.dim.height -= this.act.absolutePosition.y;
    }
    const d = this.setDimension(new Dimension(
      Math.max(2 * this.act.margin + settings.MINIMUM_WIDTH, proposed.dim.width),
      Math.max(2 * this.act.margin + settings.MINIMUM_HEIGHT, proposed.dim.height)));
    if (!this.act.absolutePositioned) {
      origin.moveTo(
        Math.max(0, proposed.pos.x + (proposed.dim.width - d.width) / 2),
        Math.max(0, proposed.pos.y + (proposed.dim.height - d.height) / 2));
    }
    if (origin.x + d.width > bounds.dim.width)
      origin.x = Math.max(0, bounds.dim.width - d.width);
    if (origin.y + d.height > bounds.dim.height)
      origin.y = Math.max(0, bounds.dim.height - d.height);
    this.setBounds(new Rectangle(origin.x, origin.y, d.width, d.height));

    // Build accessible components at the end of current tree
    window.setTimeout(() => this.buildAccessibleComponents(), 0);
  }

  /**
   * 
   * Builds the accessible components needed for this ActivityPanel
   * This method is called when all main elements are placed and visible, when the activity is ready
   * to start or when resized.
   */
  buildAccessibleComponents() {
    // Clear existing elements
    if (this.accessibleCanvas && this.$canvas && this.$canvas.children().length > 0) {
      // UPDATED May 2020: clearHitRegions has been deprecated!
      // this.$canvas.get(-1).getContext('2d').clearHitRegions();
      this.$canvas.empty();
    }
    // Create accessible elements in subclasses
  }

  /**
   *  Forces the ending of the activity.
   */
  forceFinishActivity() {
    // to be overrided by subclasses
  }

  /**
   * Ordinary ending of the activity, usually called form `processEvent`
   * @param {boolean} result - `true` if the activity was successfully completed, `false` otherwise
   */
  finishActivity(result) {
    this.playing = false;
    this.solved = result;

    if (this.bc !== null)
      this.bc.end();

    if (result) {
      this.setAndPlayMsg('final', 'finishedOk');
    } else {
      this.setAndPlayMsg('finalError', 'finishedError');
    }
    this.ps.activityFinished(this.solved);
    this.ps.reportEndActivity(this.act, this.solved);
  }

  /**
   * Sets the message to be displayed in the skin message box and optionally plays a sound event.
   * @param {string} msgCode - Type of message (initial, final, finalError...)
   * @param {string} [eventSoundsCode] - Optional name of the event sound to be played.
   */
  setAndPlayMsg(msgCode, eventSoundsCode) {
    const msg = this.act.messages[msgCode] || null;
    this.ps.setMsg(msg);
    if (msg === null || msg.mediaContent === null)
      this.playEvent(eventSoundsCode);
  }

  /**
   * Ends the activity
   */
  end() {
    this.forceFinishActivity();
    if (this.playing) {
      if (this.bc !== null)
        this.bc.end();
      this.ps.reportEndActivity(this.act, this.solved);
      this.playing = false;
      this.solved = false;
    }
    this.clear();
  }

  /**
   * Miscellaneous cleaning operations
   */
  clear() {
    // to be overridden by subclasses
  }

  /**
   * Enables or disables the three counters (time, score and actions)
   * @param {boolean} eTime - Whether to enable or disable the time counter
   * @param {boolean} eScore - Whether to enable or disable the score counter
   * @param {boolean} eActions - Whether to enable or disable the actions counter
   */
  enableCounters(eTime, eScore, eActions) {
    if (typeof eTime === 'undefined')
      eTime = this.act.bTimeCounter;
    if (typeof eScore === 'undefined')
      eScore = this.act.bScoreCounter;
    if (typeof eActions === 'undefined')
      eActions = this.act.bActionsCounter;

    this.ps.setCounterEnabled('time', eTime);
    if (this.act.countDownTime)
      this.ps.setCountDown('time', this.act.maxTime);
    this.ps.setCounterEnabled('score', eScore);
    this.ps.setCounterEnabled('actions', eActions);
    if (this.act.countDownActions)
      this.ps.setCountDown('actions', this.act.maxActions);
  }

  /**
   * Shuffles the contents of the activity
   * @param {module:boxes/ActiveBoxBag.ActiveBoxBag[]} bg - The sets of boxes to be shuffled
   * @param {boolean} visible - The shuffle process must be animated on the screen (not yet implemented!)
   * @param {boolean} fitInArea - Shuffled pieces cannot go out of the current area
   */
  shuffle(bg, visible, fitInArea) {
    const steps = this.act.shuffles;
    let i = steps;
    while (i > 0) {
      const k = i > steps ? steps : i;
      bg.forEach(abb => { if (abb) abb.shuffleCells(k, fitInArea); });
      i -= steps;
    }
  }
}

Object.assign(ActivityPanel.prototype, {
  /**
   * The Activity this panel is related to
   * @name module:Activity.ActivityPanel#act
   * @type {module:Activity.Activity} */
  act: null,
  /**
   * The jQuery div element used by this panel
   * @name module:Activity.ActivityPanel#$div
   * @type {external:jQuery} */
  $div: null,
  /**
   * The jQuery main canvas element used by this panel
   * @name module:Activity.ActivityPanel#$canvas
   * @type {external:jQuery} */
  $canvas: null,
  /**
   * Always true, since canvas hit regions have been deprecated!
   * See: https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Hit_regions_and_accessibility
   * @name module:Activity.ActivityPanel#accessibleCanvas
   * @type {boolean}
   */
  accessibleCanvas: true,
  /**
   * The realized current {@link module:skins/Skin.Skin Skin}
   * @name module:Activity.ActivityPanel#skin
   * @type {module:skins/Skin.Skin} */
  skin: null,
  /**
   * Background element (currently a `span`) used to place animated GIFs when needed
   * @name module:Activity.ActivityPanel#$animatedBg
   * @type {external:jQuery} */
  $animatedBg: null,
  /**
   * Additional background element for animated GIFs, used in associations
   * @name module:Activity.ActivityPanel#$animatedBgB
   * @type {external:jQuery} */
  $animatedBgB: null,
  /**
   * `true` when the activity is solved, `false` otherwise
   * @name module:Activity.ActivityPanel#solved
   * @type {boolean} */
  solved: false,
  /**
   * The realized image used as a background
   * @name module:Activity.ActivityPanel#bgImage
   * @type {external:HTMLImageElement} */
  bgImage: null,
  /**
   * `true` while the activity is playing
   * @name module:Activity.ActivityPanel#playing
   * @type {boolean} */
  playing: false,
  /**
   * `true` if the activity is running for first time (not due to a click on the `replay` button)
   * @name module:Activity.ActivityPanel#firstRun
   * @type {boolean} */
  firstRun: true,
  /**
   * Currently selected item. Used in some types of activities.
   * @name module:Activity.ActivityPanel#currentItem
   * @type {number} */
  currentItem: 0,
  /**
   * The object used to connect cells and other elements in some types of activity
   * @name module:Activity.ActivityPanel#bc
   * @type {module:boxes/BoxConnector.BoxConnector} */
  bc: null,
  /**
   * The PlayStation used to realize media objects and communicate with the player services
   * (usually a {@link module:JClicPlayer.JClicPlayer JClicPlayer}
   * @name module:Activity.ActivityPanel#ps
   * @type {module:JClicPlayer.JClicPlayer} */
  ps: null,
  /**
   * The minimum size of this kind of ActivityPanel
   * @name module:Activity.ActivityPanel#minimumSize
   * @type {module:AWT.Dimension} */
  minimumSize: null,
  /**
   * The preferred size of this kind of ActivityPanel
   * @name module:Activity.ActivityPanel#preferredSize
   * @type {module:AWT.Dimension} */
  preferredSize: null,
  /**
   * List of events intercepted by this ActivityPanel. Current events are: 'keydown', 'keyup',
   * 'keypress', 'mousedown', 'mouseup', 'click', 'dblclick', 'mousemove', 'mouseenter',
   * 'mouseleave', 'mouseover', 'mouseout', 'touchstart', 'touchend', 'touchmove' and 'touchcancel'.
   * @name module:Activity.ActivityPanel#events
   * @type {string[]} */
  events: ['click'],
  backgroundColor: null,
  backgroundTransparent: false,
  border: null,
});

/**
 * The panel class associated to each type of activity
 * @type {module:Activity.ActivityPanel} */
Activity.Panel = ActivityPanel;

/* harmony default export */ const src_Activity = (Activity);

;// CONCATENATED MODULE: ./src/project/JClicProject.js
/**
 *  File    : project/JClicProject.js
 *  Created : 01/04/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */









/**
 *  JClicProject contains all the components of a JClic project: activities, sequences, media
 *  files, descriptors and metadata.
 *
 *  This encapsulation is achieved by three auxiliary objects:
 *  - {@link module:project/ProjectSettings.ProjectSettings ProjectSettings}: stores metadata like full title, description, authors, languages,
 *  educational topics...
 *  - {@link module:bags/ActivitySequence.ActivitySequence ActivitySequence}: defines the order in which the activities must be shown.
 *  - {@link module:bags/MediaBag.MediaBag MediaBag}: contains the list of all media files used by the activities
 */
class JClicProject {
  /**
   * JClicProject constructor
   */
  constructor() {
    this.settings = new project_ProjectSettings(this);
    this.activitySequence = new bags_ActivitySequence(this);
    this._activities = {};
    this.mediaBag = new bags_MediaBag(this);
  }

  /**
   * Loads the project settings from a main jQuery XML element
   * @param {external:jQuery} $xml - The XML element
   * @param {string} path - The full path of this project
   * @param {external:JSZip} [zip] - An optional JSZip object where this project is encapsulated
   * @param {object} [options] - An object with miscellaneous options
   * @returns {module:project/JClicProject.JClicProject}
   */
  setProperties($xml, path, zip, options) {
    if (path) {
      this.path = path;
      if (path.file)
        this.basePath = path;
      else
        this.basePath = getBasePath(path);
    }
    this.zip = zip;
    this.name = $xml.attr('name');
    this.version = $xml.attr('version');
    if ($xml.attr('type') !== undefined && $xml.attr('type') !== '')
      this.type = $xml.attr('type');
    if ($xml.attr('code') !== undefined && $xml.attr('code') !== '')
      this.code = $xml.attr('code');
    this.settings.setProperties($xml.children('settings'));
    this.activitySequence.setProperties($xml.children('sequence'));
    this.mediaBag.setProperties($xml.children('mediaBag'));
    this.reportableActs = 0;
    this._activities = {};
    const $node = $xml.children('activities');
    const $acts = $node.children('activity');
    const ownFonts = this.mediaBag.getElementsOfType('font');
    if (ownFonts.length > 0)
      options.ownFonts = (options.ownFonts || []).concat(ownFonts);
    Font.checkTree($acts, options);
    $acts.each((_n, act) => {
      const $act = external_jquery_default()(act);
      this._activities[nSlash($act.attr('name'))] = $act;
      if ($act.children('settings').attr('report') === 'true')
        this.reportableActs++;
    });
    return this;
  }

  /**
   * Gets a object with the basic attributes needed to rebuild this instance excluding functions,
   * parent references, constants and also attributes retaining the default value.
   * The resulting object is commonly usued to serialize elements in JSON format.
   * @returns {object} - The resulting object, with minimal attrributes
   */
  getAttributes() {
    const keys = Object.keys(this._activities);
    this.activities = {};
    keys.forEach(k => {
      const act = this._activities[k];
      this.activities[k] = act.jquery ? src_Activity.getActivity(act, this) : act;
    });

    return getAttr(this, ['name', 'version', 'type', 'code', 'settings', 'activitySequence', 'activities', 'mediaBag']);
  }

  /**
   * Gets a JSON string representing the content of this project. This string can be transformed later into a data
   * object suitable for `setAttributes`.
   * @param {number} [space] - The number of white spaces to place between items. Defaults to zero (meaning all the JSON rendered in one single line)
   * @returns {string} - The JSON text
   */
  getJSON(space = 0) {
    return JSON.stringify(
      this.getAttributes(),
      (_key, val) => val.toFixed ? Number(val.toFixed(4)) : val,
      space
    );
  }

  /**
   * Loads the project settings from a data object
   * @param {object} data - The data object
   * @param {string} path - The full path of this project
   * @param {external:JSZip} [zip] - An optional JSZip object where this project is encapsulated
   * @param {object} [options] - An object with miscellaneous options
   * @returns {module:project/JClicProject.JClicProject}
   */
  setAttributes(data, path, zip, options) {
    if (path) {
      this.path = path;
      if (path.file)
        this.basePath = path;
      else
        this.basePath = getBasePath(path);
    }
    this.zip = zip;
    this.name = data.name;
    this.version = data.version;
    if (data.type)
      this.type = data.type;
    if (data.code)
      this.code = data.code;
    this.settings.setAttributes(data.settings);
    this.activitySequence.setAttributes(data.activitySequence);
    this.mediaBag.setAttributes(data.mediaBag);
    this.reportableActs = 0;
    this._activities = data.activities;

    const ownFonts = this.mediaBag.getElementsOfType('font');
    if (ownFonts.length > 0)
      options.ownFonts = (options.ownFonts || []).concat(ownFonts);
    // TODO: Check fonts
    Font.checkTree(this._activities, options);
    this.reportableActs = Object.keys(this._activities)
      .filter(k => this._activities[k].includeInReports)
      .length;
    return this;
  }

  /**
   * Finds activities by name and builds the corresponding {@link module:Activity.Activity Activity} object.
   * @param {string} name - The name of the requested activity
   * @returns {module:Activity.Activity}
   */
  getActivity(name) {
    return src_Activity.getActivity(this._activities[nSlash(name)], this);
  }

  /**
   *
   * Builds the {@link module:skins/Skin.Skin Skin}, {@link module:media/EventSounds.EventSounds EventSounds} and {@link module:bags/MediaBag.MediaBag MediaBag} fonts associated to this project.
   * @param {module:JClicPlayer.JClicPlayer} ps - The PlayStation (usually a {@link module:JClicPlayer.JClicPlayer JClicPlayer}) linked to this project.
   */
  realize(ps) {
    // Build skin
    if (this.skin === null && this.settings.skinFileName !== null && this.settings.skinFileName.length > 0)
      this.skin = this.mediaBag.getSkinElement(this.settings.skinFileName, ps);

    this.settings.eventSounds.realize(ps, this.mediaBag);

    // Build all elements of type `font`
    this.mediaBag.buildAll('font', null, ps);
  }

  /**
   * Run finalizers on realized objects
   */
  end() {
    // TODO: Implement JClicProject.end()
  }
}

Object.assign(JClicProject.prototype, {
  /**
   * The project's name
   * @name module:project/JClicProject.JClicProject#name
   * @type {string} */
  name: 'unknown',
  /**
   * The version of the XML file format used to save the project (currently 0.1.3)
   * @name module:project/JClicProject.JClicProject#version
   * @type {string} */
  version: '0.1.3',
  /**
   * Optional property that can be used by reporting systems
   * @name module:project/JClicProject.JClicProject#type
   * @type {string} */
  type: null,
  /**
   * Optional property that can be used by reporting systems
   * @name module:project/JClicProject.JClicProject#code
   * @type {string} */
  code: null,
  /**
   * Object containing the project settings
   * @name module:project/JClicProject.JClicProject#settings
   * @type {module:project/ProjectSettings.ProjectSettings} */
  settings: null,
  /**
   * Object containing the order in which the activities should be played
   * @name module:project/JClicProject.JClicProject#activitySequence
   * @type {module:bags/ActivitySequence.ActivitySequence} */
  activitySequence: null,
  /**
   * Array of jQuery xml elements containing the data of each activity. Don't rely on this object
   * to retrieve real activities. Use the method {@link module:project/JClicProject.JClicProject#getActivity getActivity} instead.
   * @name module:project/JClicProject.JClicProject#_activities
   * @private
   * @type {external:jQuery[]} */
  _activities: null,
  /**
   * Number of activities suitable to be included reports
   * @name module:project/JClicProject.JClicProject#reportableActs
   * @type {number}
   */
  reportableActs: 0,
  /**
   * The collection of all media elements used in this project
   * @name module:project/JClicProject.JClicProject#mediaBag
   * @type {module:bags/MediaBag.MediaBag} */
  mediaBag: null,
  /**
   * The object that builds and manages the visual interface presented to users
   * @name module:project/JClicProject.JClicProject#skin
   * @type {module:skins/Skin.Skin} */
  skin: null,
  /**
   * Relative path or absolute URL to be used as a base to access files, usually in conjunction
   * with {@link module:JClicPlayer.JClicPlayer#basePath}
   * @name module:project/JClicProject.JClicProject#basePath
   * @type {string} */
  basePath: '',
  /**
   * Full path of this project
   * @name module:project/JClicProject.JClicProject#path
   * @type {string} */
  path: null,
  /**
   * The JSZip object where this project is stored (can be `null`)
   * @name module:project/JClicProject.JClicProject#zip
   * @type {external:JSZip} */
  zip: null,
});

/* harmony default export */ const project_JClicProject = (JClicProject);

;// CONCATENATED MODULE: ./src/report/ActionReg.js
/**
 *  File    : report/ActionReg.js
 *  Created : 17/05/2016
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */




/**
 * This class stores information about one specific action done by the current user while playing
 * an activity.
 *
 */
class ActionReg {
  /**
   * ActionReg constructor
   * @param {string} type - Type of action (`click`, `write`, `move`, `select`...)
   * @param {string}+ source - Description of the object on which the action is done.
   * @param {string}+ dest - Description of the object that acts as a target of the action (used in pairings)
   * @param {boolean} ok - `true` if the action was OK, `false`, `null` or `undefined` otherwise
   */
  constructor(type, source, dest, ok) {
    this.type = type;
    this.source = source || null;
    this.dest = dest || null;
    this.ok = ok || false;
    this.time = (new Date()).valueOf();
  }

  /**
   * Provides the data associated with this action in XML format suitable for a
   * {@link http://clic.xtec.cat/en/jclic/reports/|JClic Reports Server}.
   * @returns {external:jQuery}
   */
  $getXML() {
    const attr = { ok: this.ok, time: this.time };
    if (this.type)
      attr.type = this.type;
    if (this.source)
      attr.source = this.source;
    if (this.dest)
      attr.dest = this.dest;
    return external_jquery_default()('<action/>', attr);
  }

  /**
   * Fills this ActionReg with data provided in XML format
   * @param {external:jQuery} $xml - The XML element to be processed, already wrapped as jQuery object
   */
  setProperties($xml) {
    attrForEach($xml.get(0).attributes, (name, value) => {
      switch (name) {
        case 'type':
        case 'source':
        case 'dest':
          this[name] = value;
          break;
        case 'time':
          this[name] = Number(value);
          break;
        case 'ok':
          this[name] = getBoolean(value, false);
          break;
      }
    });
  }
}

Object.assign(ActionReg.prototype, {
  /**
   * The type of action (`click`, `write`, `move`, `select`...)
   * @name module:report/ActionReg.ActionReg#type
   * @type {string} */
  type: 'unknown',
  /**
   * Description of the object on which the action was done
   * @name module:report/ActionReg.ActionReg#source
   * @type {string} */
  source: null,
  /**
   * Description of the object that has acted as a target of the action (used in pairings)
   * @name module:report/ActionReg.ActionReg#dest
   * @type {string} */
  dest: null,
  /**
   * Time stamp taken when the action was done
   * @name module:report/ActionReg.ActionReg#time
   * @type {number} */
  time: 0,
  /**
   * `true` if the action was OK
   * @name module:report/ActionReg.ActionReg#isOk
   * @type {boolean} */
  isOk: false,
});

/* harmony default export */ const report_ActionReg = (ActionReg);

;// CONCATENATED MODULE: ./src/report/ActivityReg.js
/**
 *  File    : report/ActivityReg.js
 *  Created : 17/05/2016
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */





/**
 * This class stores miscellaneous data obtained by the current user playing an {@link module:Activity.Activity Activity}.
 */
class ActivityReg {
  /**
   * ActivityReg constructor
   * @param {module:Activity.Activity} act - The {@link module:Activity.Activity Activity} referenced by this object.
   */
  constructor(act) {
    this.name = act.name;
    this.code = act.code;
    this.actions = [];
    this.startTime = (new Date()).valueOf();
    this.minActions = act.getMinNumActions();
    this.reportActions = act.reportActions;
  }

  /**
   * Provides the data associated with the current activity in an XML format suitable for a
   * {@link http://clic.xtec.cat/en/jclic/reports/|JClic Reports Server}.
   * @returns {external:jQuery}
   */
  $getXML() {
    const attr = {
      start: this.startTime,
      time: this.totalTime,
      solved: this.solved,
      score: this.score,
      minActions: this.minActions,
      actions: this.numActions
    };
    if (this.name)
      attr.name = this.name;
    if (this.code)
      attr.code = this.code;
    if (!this.closed)
      attr.closed = false;
    if (this.reportActions)
      attr.reportActions = true;

    const $result = external_jquery_default()('<activity/>', attr);
    this.actions.forEach(ac => {
      $result.append(ac.$getXML());
    });
    return $result;
  }

  /**
   * Builds an object with relevant data about the results obtained by the current student in this activity
   * @returns {object} - The results of this activity
   */
  getData() {
    const result = {
      name: this.name,
      time: Math.round(this.totalTime / 10) / 100,
      solved: this.solved,
      score: this.score,
      minActions: this.minActions,
      actions: this.numActions,
      precision: this.getPrecision(),
      closed: this.closed
    };
    if (this.code)
      result.code = this.code;
    return result;
  }

  /**
   * Fills this ActivityReg with data provided in XML format
   * @param {external:jQuery} $xml -The XML element to be processed, already wrapped as jQuery object
   */
  setProperties($xml) {
    attrForEach($xml.get(0).attributes, (name, value) => {
      switch (name) {
        case 'name':
        case 'code':
          this[name] = value;
          break;
        case 'start':
        case 'time':
        case 'score':
        case 'minActions':
        case 'actions':
          this[name] = Number(value);
          break;
        case 'solved':
        case 'closed':
        case 'reportActions':
          this[name] = getBoolean(value, false);
          break;
      }
    });
    $xml.children('action').each((_n, child) => {
      const action = new report_ActionReg();
      action.setProperties(external_jquery_default()(child));
      this.actions.push(action);
    });
  }

  /**
   * Reports a new action done by the user while playing the current activity
   * @param {string} type - Type of action (`click`, `write`, `move`, `select`...)
   * @param {string}+ source - Description of the object on which the action is done.
   * @param {string}+ dest - Description of the object that acts as a target of the action (used in pairings)
   * @param {boolean} ok - `true` if the action was OK, `false`, `null` or `undefined` otherwise
   */
  newAction(type, source, dest, ok) {
    if (!this.closed) {
      this.lastAction = new report_ActionReg(type, source, dest, ok);
      this.actions.push(this.lastAction);
    }
  }

  /**
   * Retrieves a specific {@link module:report/ActionReg.ActionReg ActionReg} element from `actions`
   * @param {number} index - The nth action to be retrieved
   * @returns {module:report/ActionReg.ActionReg}
   */
  getActionReg(index) {
    return index >= this.actions.length ? null : this.actions[index];
  }

  /**
   * Closes the current activity, adjusting total time if needed
   */
  closeActivity() {
    if (!this.closed) {
      if (this.lastAction)
        this.totalTime = this.lastAction.time - this.startTime;
      else
        this.totalTime = (new Date()).valueOf() - this.startTime;
      this.closed = true;
    }
  }

  /**
   * calculates the final score obtained by the user in this activity.
   * The algorithm used takes in account the minimal number of actions needed, the actions
   * really done by the user, and if the activity was finally solved or not.
   * @returns {number}
   */
  getPrecision() {
    let result = 0;
    if (this.closed && this.minActions > 0 && this.numActions > 0) {
      if (this.solved) {
        if (this.numActions < this.minActions)
          result = 100;
        else
          result = Math.round(this.minActions * 100 / this.numActions);
      } else
        result = Math.round(100 * (this.score * this.score) / (this.minActions * this.numActions));
    }
    return result;
  }

  /**
   * This method should be called when the current activity finishes. Data about user's final results
   * on the activity will then be saved.
   * @param {number} score - The final score, usually in a 0-100 scale.
   * @param {number} numActions - The total number of actions done by the user to solve the activity
   * @param {boolean} solved - `true` if the activity was finally solved, `false` otherwise.
   */
  endActivity(score, numActions, solved) {
    if (!this.closed) {
      this.solved = solved;
      this.numActions = numActions;
      this.score = score;
      this.closeActivity();
    }
  }
}

Object.assign(ActivityReg.prototype, {
  /**
   * Name of the associated activity
   * @name module:report/ActivityReg.ActivityReg#name
   * @type {string} */
  name: '',
  /**
   * Optional code assigned to this activity, used for later filtering
   * @name module:report/ActivityReg.ActivityReg#code
   * @type {string} */
  code: '',
  /**
   * Timestamp when the user starts playing the activity
   * @name module:report/ActivityReg.ActivityReg#startTime
   * @type {number} */
  startTime: 0,
  /**
   * Total time spent by the user in the activity, measured in milliseconds
   * @name module:report/ActivityReg.ActivityReg#totalTime
   * @type {number} */
  totalTime: 0,
  /**
   * Collection of actions done by the user while playing the activity
   * @name module:report/ActivityReg.ActivityReg#actions
   * @type {module:report/ActionReg.ActionReg[]} */
  actions: [],
  /**
   * `true` only when the user has finished and solved the activity
   * @name module:report/ActivityReg.ActivityReg#solved
   * @type {boolean} */
  solved: false,
  /**
   * Last {@link module:report/ActionReg.ActionReg ActionReg} performed by the user in this activity
   * @name module:report/ActivityReg.ActivityReg#lastAction
   * @type {module:report/ActionReg.ActionReg} */
  lastAction: null,
  /**
   * Final score obtained by the current user in this activity
   * @name module:report/ActivityReg.ActivityReg#score
   * @type {number} */
  score: 0,
  /**
   * Minimum number of actions needed to solve the activity
   * @name module:report/ActivityReg.ActivityReg#minActions
   * @type {number} */
  minActions: 0,
  /**
   * `true` when the activity has finished, `false` for the activity that is currently playing
   * @name module:report/ActivityReg.ActivityReg#closed
   * @type {boolean} */
  closed: false,
  /**
   * `true` when this type of activity should record specific actions done by the users
   * @name module:report/ActivityReg.ActivityReg#reportActions
   * @type {boolean} */
  reportActions: false,
  /**
   * Number of actions done by the user playing this activity
   * @name module:report/ActivityReg.ActivityReg#numActions
   * @type {number} */
  numActions: 0,
});

/* harmony default export */ const report_ActivityReg = (ActivityReg);

;// CONCATENATED MODULE: ./src/report/SequenceReg.js
/**
 *  File    : report/SequenceReg.js
 *  Created : 17/05/2016
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */



/**
 * This class stores the results of the activities related to an {@link module:bags/ActivitySequenceElement.ActivitySequenceElement ActivitySequenceElement}.
 * It's main component is an array of {@link module:report/ActivityReg.ActivityReg ActivityReg} elements.
 */
class SequenceReg {
  /**
   * SequenceReg constructor
   * @param {module:bags/ActivitySequenceElement.ActivitySequenceElement} ase - The {@link module:bags/ActivitySequenceElement.ActivitySequenceElement ActivitySequenceElement} related to this sequence.
   */
  constructor(ase) {
    this.name = ase.tag;
    this.description = ase.description;
    this.activities = [];
    this.currentActivity = null;
    this.totalTime = 0;
    this.closed = false;
    this.info = new SequenceRegInfo(this);
  }

  /**
   * Builds a complex object with data about the results of the activities done in this sequence
   * @returns {object} - The sequence results
   */
  getData() {
    const result = {
      sequence: this.name,
      activities: []
    };
    this.activities.forEach(act => result.activities.push(act.getData()));
    return result;
  }

  /**
   * Returns the `info` element associated to this SequenceReg.
   * @returns {module:report/SequenceReg.SequenceRegInfo}
   */
  getInfo() {
    return this.info.recalc();
  }

  /**
   * This method should be called when the current working session finishes.
   */
  endSequence() {
    if (this.currentActivity && this.activities.length > 0) {
      if (!this.currentActivity.closed)
        this.currentActivity.closeActivity();
      this.totalTime = this.currentActivity.startTime + this.currentActivity.totalTime - this.activities[0].startTime;
      this.info.valid = false;
    }
  }

  /**
   * This method should be invoked when the user starts a new activity
   * @param {module:Activity.Activity} act - The {@link module:Activity.Activity Activity} that has just started
   */
  newActivity(act) {
    if (!this.closed) {
      this.currentActivity = new report_ActivityReg(act);
      this.activities.push(this.currentActivity);
      this.info.valid = false;
    }
  }

  /**
   * This method should be called when the current activity finishes. Data about user's final results
   * on the activity will then be saved.
   * @param {number} score - The final score, usually in a 0-100 scale.
   * @param {number} numActions - The total number of actions done by the user to solve the activity
   * @param {boolean} solved - `true` if the activity was finally solved, `false` otherwise.
   */
  endActivity(score, numActions, solved) {
    if (this.currentActivity) {
      this.currentActivity.endActivity(score, numActions, solved);
      this.info.valid = false;
    }
  }

  /**
   * Reports a new action done by the user while playing the current activity
   * @param {string} type - Type of action (`click`, `write`, `move`, `select`...)
   * @param {string}+ source - Description of the object on which the action is done.
   * @param {string}+ dest - Description of the object that acts as a target of the action (used in pairings)
   * @param {boolean} ok - `true` if the action was OK, `false`, `null` or `undefined` otherwise
   */
  newAction(type, source, dest, ok) {
    if (this.currentActivity) {
      this.currentActivity.newAction(type, source, dest, ok);
      this.info.valid = false;
    }
  }
}

Object.assign(SequenceReg.prototype, {
  /**
   * The `tag` member of the associated {@link module:bags/ActivitySequenceElement.ActivitySequenceElement ActivitySequenceElement}
   * @name module:report/SequenceReg.SequenceReg#name
   * @type {string} */
  name: '',
  /**
   * Optional description given to the {@link module:bags/ActivitySequenceElement.ActivitySequenceElement ActivitySequenceElement}
   * @name module:report/SequenceReg.SequenceReg#description
   * @type {string} */
  description: '',
  /**
   * Collection of all the {@link module:report/ActivityReg.ActivityReg ActivityReg} elements done during this sequence.
   * @name module:report/SequenceReg.SequenceReg#activities
   * @type {module:report/ActivityReg.ActivityReg[]} */
  activities: [],
  /**
   * Registry linked to the {@link module:Activity.Activity Activity} that is currently running
   * @name module:report/SequenceReg.SequenceReg#currentActivity
   * @type {module:report/ActivityReg.ActivityReg} */
  currentActivity: null,
  /**
   * Total time spent on the activities of this sequence
   * @name module:report/SequenceReg.SequenceReg#totalTime
   * @type {number} */
  totalTime: 0,
  /**
   * Flag indicating if the sequence is closed or already available for more activities
   * @name module:report/SequenceReg.SequenceReg#closed
   * @type {boolean} */
  closed: false,
  /**
   * Object with global information associated to this sequence
   * @name module:report/SequenceReg.SequenceReg#info
   * @type {module:report/SequenceReg.SequenceRegInfo} */
  info: null,
});

/**
 * This object stores the global results of a {@link module:report/SequenceReg.SequenceReg SequenceReg}
 */
class SequenceRegInfo {
  /**
   * SequenceRegInfo constructor
   * @param {module:report/SequenceReg.SequenceReg} sqReg - The {@link module:report/SequenceReg.SequenceReg SequenceReg} associated tho this `Info` object.
   */
  constructor(sqReg) {
    this.sqReg = sqReg;
  }

  /**
   * Clears all global data associated with this sequence
   */
  clear() {
    this.nActivities = this.nActClosed = this.nActSolved = this.nActScore = 0;
    this.ratioSolved = this.nActions = this.tScore = this.tTime = 0;
    this.valid = false;
  }

  /**
   * Computes the value of all global variables based on the data stored in `activities`
   * @returns {module:report/SequenceReg.SequenceRegInfo} - This "info" object
   */
  recalc() {
    if (!this.valid) {
      this.clear();
      this.nActivities = this.sqReg.activities.length;
      if (this.nActivities > 0) {
        this.sqReg.activities.forEach(ar => {
          if (ar.closed) {
            this.nActClosed++;
            this.tTime += ar.totalTime;
            this.nActions += ar.numActions;
            if (ar.solved)
              this.nActSolved++;
            const r = ar.getPrecision();
            if (r >= 0) {
              this.tScore += r;
              this.nActScore++;
            }
          }
        });
        if (this.nActClosed > 0)
          this.ratioSolved = this.nActSolved / this.nActClosed;
        if (this.nActScore > 0)
          this.tScore = Math.round(this.tScore / this.nActScore);
      }
      this.valid = true;
    }
    return this;
  }
}

Object.assign(SequenceRegInfo.prototype, {
  /**
   * The {@link module:report/SequenceReg.SequenceReg SequenceReg} associated to this "info" object
   * @name module:report/SequenceReg.SequenceRegInfo#sqReg
   * @type {module:report/SequenceReg.SequenceReg} */
  sqReg: null,
  /**
   * When `false`, data must be recalculated
   * @name module:report/SequenceReg.SequenceRegInfo#valid
   * @type {boolean} */
  valid: false,
  /**
   * Number of activities played in this sequence
   * @name module:report/SequenceReg.SequenceRegInfo#nActivities
   * @type {number} */
  nActivities: 0,
  /**
   * Number of activities already closed
   * @name module:report/SequenceReg.SequenceRegInfo#nActClosed
   * @type {number} */
  nActClosed: 0,
  /**
   * Number of activities solved
   * @name module:report/SequenceReg.SequenceRegInfo#nActSolved
   * @type {number} */
  nActSolved: 0,
  /**
   * Number of activities with score > 0
   * @name module:report/SequenceReg.SequenceRegInfo#nActScore
   * @type {number} */
  nActScore: 0,
  /**
   * Percentage of solved activities
   * @name module:report/SequenceReg.SequenceRegInfo#ratioSolved
   * @type {number} */
  ratioSolved: 0,
  /**
   * Number of actions done by the user while in this sequence
   * @name module:report/SequenceReg.SequenceRegInfo#nActions
   * @type {number} */
  nActions: 0,
  /**
   * Sum of the scores of all the activities played
   * @name module:report/SequenceReg.SequenceRegInfo#tScore
   * @type {number} */
  tScore: 0,
  /**
   * Sum of the playing time reported by each activity (not always equals to the sequence's total time)
   * @name module:report/SequenceReg.SequenceRegInfo#tTime
   * @type {number} */
  tTime: 0,
});

SequenceReg.Info = SequenceRegInfo;

/* harmony default export */ const report_SequenceReg = (SequenceReg);

;// CONCATENATED MODULE: ./src/report/SessionReg.js
/**
 *  File    : report/SessionReg.js
 *  Created : 17/05/2016
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Catalan Educational Telematic Network (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */



/**
 * This class encapsulates data of a user's working session, usually associated to a single {@link module:project/JClicProject.JClicProject JClicProject}
 * It's main component is `sequences`, an array of {@link module:report/SequenceReg.SequenceReg SequenceReg} objects.
 */
class SessionReg {
  /**
   * SessionReg constructor
   * @param {module:project/JClicProject.JClicProject} project - The JClicProject referenced by this session.
   * @param {string} [code] - Optional code to be used by this SessionReg
   */
  constructor(project, code) {
    this.projectName = project.name;
    this.code = code || project.code;
    this.sequences = [];
    this.actNames = [];
    this.started = new Date();
    this.info = new SessionRegInfo(this);
    this.reportableActs = project.reportableActs;
  }

  /**
   * Builds a complex object with the results of all activities done during this working session
   * @param {boolean} recalcInfo - When `true`, global variables (number of sequences, score, total time...)
   * will be recalculated from the data stored in the {@link module:report/SequenceReg.SequenceReg SequenceReg} objects.
   * @param {boolean} includeEmpty - When `true`, sequences without reported activities will be also included in the results
   * @returns {object} - An object containing the full session data
   */
  getData(recalcInfo, includeEmpty) {
    if (recalcInfo)
      this.info.recalc();

    const result = {
      projectName: this.projectName,
      played: this.info.nActivities,
      ratioPlayed: Math.round(this.info.ratioPlayed * 100),
      solved: this.info.nActSolved,
      ratioSolved: Math.round(this.info.ratioSolved * 100),
      actions: this.info.nActions,
      score: this.info.tScore,
      time: Math.round(this.info.tTime / 10) / 100,
      sequences: []
    };

    this.sequences.forEach(s => {
      const seq = s.getData();
      if (includeEmpty || seq.activities.length > 0)
        result.sequences.push(seq);
    });
    return result;
  }

  /**
   * Returns the `info` element associated to this SessionReg.
   * @returns {module:report/SessionReg.SessionRegInfo}
   */
  getInfo() {
    return this.info.recalc();
  }

  /**
   * Closes this session
   */
  end() {
    this.endSequence();
  }

  /**
   * This method should be called when the current working session finishes.
   */
  endSequence() {
    if (this.currentSequence && this.currentSequence.totalTime === 0)
      this.currentSequence.endSequence();
    this.currentSequence = null;
    this.info.valid = false;
  }

  /**
   * This method should be invoked when a new sequence starts
   * @param {module:bags/ActivitySequenceElement.ActivitySequenceElement} ase - The {@link module:bags/ActivitySequenceElement.ActivitySequenceElement ActivitySequenceElement} referenced by this sequence.
   */
  newSequence(ase) {
    this.endSequence();
    this.currentSequence = new report_SequenceReg(ase);
    this.sequences.push(this.currentSequence);
    this.info.valid = false;
  }

  /**
   * This method should be invoked when the user starts a new activity
   * @param {module:Activity.Activity} act - The {@link module:Activity.Activity Activity} that has just started
   */
  newActivity(act) {
    if (this.currentSequence) {
      // Save activity name if not yet registered
      if (this.actNames.indexOf(act.name) === -1)
        this.actNames.push(act.name);
      this.currentSequence.newActivity(act);
      this.info.valid = false;
    }
  }

  /**
   * This method should be called when the current activity finishes. Data about user's final results
   * on the activity will then be saved.
   * @param {number} score - The final score, usually in a 0-100 scale.
   * @param {number} numActions - The total number of actions done by the user to solve the activity
   * @param {boolean} solved - `true` if the activity was finally solved, `false` otherwise.
   */
  endActivity(score, numActions, solved) {
    if (this.currentSequence) {
      this.currentSequence.endActivity(score, numActions, solved);
      this.info.valid = false;
    }
  }

  /**
   * Reports a new action done by the user while playing the current activity
   * @param {string} type - Type of action (`click`, `write`, `move`, `select`...)
   * @param {string}+ source - Description of the object on which the action is done.
   * @param {string}+ dest - Description of the object that acts as a target of the action (used in pairings)
   * @param {boolean} ok - `true` if the action was OK, `false`, `null` or `undefined` otherwise
   */
  newAction(type, source, dest, ok) {
    if (this.currentSequence) {
      this.currentSequence.newAction(type, source, dest, ok);
      this.info.valid = false;
    }
  }

  /**
   * Gets the name of the current sequence
   * @returns {string}
   */
  getCurrentSequenceTag() {
    return this.currentSequence ? this.currentSequence.name : null;
  }

  /**
   * Gets information about the current sequence
   * @returns {module:report/SequenceReg.SequenceRegInfo}
   */
  getCurrentSequenceInfo() {
    return this.currentSequence ? this.currentSequence.getInfo() : null;
  }
}

Object.assign(SessionReg.prototype, {
  /**
   * Number of activities suitable to be reported in this session
   * @name module:report/SessionReg.SessionReg#reportableActs
   * @type {number} */
  reportableActs: 0,
  /**
   * Array with unique names of the activities being reported in this session
   * @name module:report/SessionReg.SessionReg#actNames
   * @type {string[]} */
  actNames: null,
  /**
   * List of sequences done in this session
   * @name module:report/SessionReg.SessionReg#sequences
   * @type {module:report/SequenceReg.SequenceReg[]} */
  sequences: null,
  /**
   * The sequence currently active
   * @name module:report/SessionReg.SessionReg#currentSequence
   * @type {module:report/SequenceReg.SequenceReg} */
  currentSequence: null,
  /**
   * Starting date and time of this session
   * @name module:report/SessionReg.SessionReg#started
   * @type {external:Date} */
  started: null,
  /**
   * Name of the {@link module:project/JClicProject.JClicProject JClicProject} associated to this session
   * @name module:report/SessionReg.SessionReg#projectName
   * @type {string} */
  projectName: '',
  /**
   * Current session info
   * @name module:report/SessionReg.SessionReg#info
   * @type {module:report/SessionReg.SessionRegInfo} */
  info: null,
  /**
   * Optional code to be used with this session
   * @name module:report/SessionReg.SessionReg#code
   * @type {string} */
  code: null,
});

/**
 * This object stores the global results of a {@link module:report/SessionReg.SessionReg SessionReg}
 */
class SessionRegInfo {
  /**
   * SessionRegInfo constructor
   * @param {module:report/SessionReg.SessionReg} sReg - The {@link module:report/SessionReg.SessionReg SessionReg} associated tho this `Info` object.
   */
  constructor(sReg) {
    this.sReg = sReg;
  }

  /**
   * Clears all data associated with this working session
   */
  clear() {
    this.numSequences = this.nActivities = this.nActSolved = this.nActScore = 0;
    this.ratioSolved = this.ratioPlayed = this.nActions = this.tScore = this.tTime = 0;
    this.valid = false;
  }

  /**
   * Computes the value of all global variables based on the data stored in `sequences`
   * @returns {module:report/SessionReg.SessionRegInfo} - This "info" object
   */
  recalc() {
    if (!this.valid) {
      this.clear();
      this.sReg.sequences.forEach(sr => {
        const sri = sr.getInfo();
        if (sri.nActivities > 0) {
          this.numSequences++;
          if (sri.nActClosed > 0) {
            this.nActivities += sri.nActClosed;
            this.nActions += sri.nActions;
            if (sri.nActScore > 0) {
              this.nActScore += sri.nActScore;
              this.tScore += sri.tScore * sri.nActScore;
            }
            this.tTime += sri.tTime;
            this.nActSolved += sri.nActSolved;
          }
        }
      });
      if (this.nActScore > 0)
        this.tScore = Math.round(this.tScore / this.nActScore);
      if (this.nActivities > 0) {
        this.ratioSolved = this.nActSolved / this.nActivities;
        if (this.sReg.reportableActs > 0)
          this.ratioPlayed = this.sReg.actNames.length / this.sReg.reportableActs;
      }
      this.valid = true;
    }
    return this;
  }
}

Object.assign(SessionRegInfo.prototype, {
  /**
   * The SessionReg linked to this Info object
   * @name module:report/SessionReg.SessionRegInfo#sReg
   * @type {module:report/SessionReg.SessionReg} */
  sReg: null,
  /**
   * When `false`, this session info needs to be recalculated
   * @name module:report/SessionReg.SessionRegInfo#valid
   * @type {boolean} */
  valid: false,
  /**
   * Number of sequences played
   * @name module:report/SessionReg.SessionRegInfo#numSequences
   * @type {number} */
  numSequences: 0,
  /**
   * Number of activities played
   * @name module:report/SessionReg.SessionRegInfo#nActivities
   * @type {number} */
  nActivities: 0,
  /**
   * Number of activities solved
   * @name module:report/SessionReg.SessionRegInfo#nActSolved
   * @type {number} */
  nActSolved: 0,
  /**
   * Number of activities with score > 0
   * @name module:report/SessionReg.SessionRegInfo#nActScore
   * @type {number} */
  nActScore: 0,
  /**
   * Percentage of solved activities
   * @name module:report/SessionReg.SessionRegInfo#ratioSolved
   * @type {number} */
  ratioSolved: 0,
  /**
   * Percentage of reportable activities played
   * @name module:report/SessionReg.SessionRegInfo#ratioPlayed
   * @type {number} */
  ratioPlayed: 0,
  /**
   * Number of actions done by the user while in this working session
   * @name module:report/SessionReg.SessionRegInfo#nActions
   * @type {number} */
  nActions: 0,
  /**
   * Sum of the scores of all the activities played
   * @name module:report/SessionReg.SessionRegInfo#tScore
   * @type {number} */
  tScore: 0,
  /**
   * Sum of the playing time reported by each activity (not always equals to the session's total time)
   * @name module:report/SessionReg.SessionRegInfo#tTime
   * @type {number} */
  tTime: 0,
});

SessionReg.Info = SessionRegInfo;

/* harmony default export */ const report_SessionReg = (SessionReg);

;// CONCATENATED MODULE: ./src/report/EncryptMin.js
/**
 *  File    : report/Encryption.js
 *  Created : 18/06/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */

/**
 *
 * Utilities to encrypt and decrypt strings using simple methods, just to avoid write
 * passwords in plain text in data and configuration files. Do not use it as a
 * secure cryptographic system!
 *
 * Based on {@link https://github.com/projectestac/jclic/blob/master/src/utilities/edu/xtec/util/Encryption.java Encryption}
 * utilities, created by Albert Llastarri for {@link https://github.com/projectestac/jclic JClic}.
 *
 * IMPORTANT: This is a shortened version of Encryption with only the methods needed to decrypt
 * stored passwords. Full version is on file `src/misc/encryption/Encryption.js`
 *
 * @abstract
 */
class Encryption {
  /**
   * Decrypts the given code
   * @param {string} txt - Code to be decrypted
   * @returns {string}
   */
  static Decrypt(txt) {
    if (txt === null || txt.length === 0)
      return null;
    const s = Encryption.decodify(txt);
    return s === Encryption.BLANK ? '' : s;
  }

  /**
   * @param {string} cA (was char[])
   * @param {number} fromIndex
   * @returns {string} (was char)
   */
  static hexCharArrayToChar(cA, fromIndex) {
    let n = 0;
    for (let i = 0; i <= 3; i++) {
      const j = Number.parseInt(cA[fromIndex + i], 16);
      if (isNaN(j))
        throw 'Invalid expression!';
      else
        n = n * 16 + j;
    }
    return String.fromCharCode(n);
  }

  /**
   * @param {string} cA - (was char[])
   * @param {number} fromIndex
   * @returns {number}
   */
  static hexCharArrayToInt(cA, fromIndex) {
    let n = 0;
    for (let i = 0; i <= 1; i++) {
      const j = Number.parseInt(cA[fromIndex + i], 16);
      if (isNaN(j))
        throw 'Invalid expression!';
      else
        n = n * 16 + j;
    }
    return n;
  }

  /**
   * @param {string} cA - (was char[])
   * @returns {string}
   */
  static decodifyZerosField(cA) {
    let
      sb = '',
      num = Number.parseInt(cA[0], 32),
      k = 0,
      i = 0;

    for (i = 0; num !== 0; i++) {
      while (num > 0) {
        sb = sb + cA[i * 3 + 1] + cA[i * 3 + 2];
        num--;
        k++;
      }
      if (cA.length > i * 3 + 3)
        num = Number.parseInt(cA[i * 3 + 3], 32);
      else
        num = 0;
    }
    for (let j = i * 3 + 1; j < cA.length; j++)
      sb = sb + cA[j];

    return Number.parseInt(k, 32) + sb;
  }

  /**
   * @param {string} cA - (was char[])
   * @returns {string} (was StringBuilder)
   */
  static decompressZeros(cA) {
    cA = Encryption.decodifyZerosField(cA);
    let
      numBytesZeros = Number.parseInt(cA[0], 32),
      iniNoZeros = numBytesZeros * 2 + 1,
      bFi = false,
      sb = '';

    for (let i = 0; i < numBytesZeros && !bFi; i++) {
      const zeros = Encryption.hexCharArrayToInt(cA, 1 + i * 2);
      let s = zeros.toString(2);
      while (s.length < 8)
        s = '0' + s;
      for (let j = 0; j <= 7 && !bFi; j++) {
        if (s[j] === '1')
          sb = sb + '0';
        else if (iniNoZeros < cA.length)
          sb = sb + cA[iniNoZeros++];
        else
          bFi = true;
      }
    }
    return sb;
  }

  /**
   * @param {string} sb1 - (was StringBuilder)
   * @returns {string}
   */
  static decodifyFromHex(sb1) {
    let sb = '', j = 0;
    for (let i = 0; j < sb1.length; i++) {
      const c = Encryption.hexCharArrayToChar(sb1, j);
      sb = sb + c;
      j += 4;
    }
    return sb;
  }

  /**
   * @param {string} s
   * @returns {string} (was char[])
   */
  static unchangeOrder(s) {
    let m = 0, n = s.length - 1;
    const cA = [];
    for (let p = 0; p < s.length; p++)
      cA[p] = '';
    for (let i = 0; i < s.length; i++)
      if (i % 2 === 0)
        cA[i] = s[m++];
      else
        cA[i] = s[n--];
    return cA.join('');
  }

  /**
   * @param {string} word
   * @returns {string}
   */
  static codify(word) {
    if (word.length > 24)
      throw 'Password is too large!';
    return Encryption.changeOrder(Encryption.compressZeros(Encryption.codifyToHexWord(word)));
  }

  /**
   * @param {string} word
   * @returns {string}
   */
  static decodify(word) {
    try {
      return Encryption.decodifyFromHex(Encryption.decompressZeros(Encryption.unchangeOrder(word)));
    } catch (e) { //The supplied word was not codified using this system
      return '';
    }
  }
}

/**
* Default bank password
* @type {string}
*/
Encryption.BLANK = '___blank___##';

/* harmony default export */ const EncryptMin = (Encryption);

;// CONCATENATED MODULE: ./src/report/SCORM.js
/**
 *  File    : report/SCORM.js
 *  Created : 18/07/2016
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */

/* global window */




/**
 * This class detects if JClic.js is running in an SCORM environment and, if true,
 * exposes the methods needed to notify the results of activities.
 * Both SCORM 1.2 and 2004 are supported.
 */
class SCORM {
  /**
   * SCORM constructor
   * @param {object} API - The global SCORM API object
   * @param {module:report/Reporter.Reporter} reporter - The {@link module:Reporter.Reporter Reporter} associated to this SCORM object
   */
  constructor(API, reporter) {
    this.API = API;
    // Check if 'API' has a function named 'Initialized'
    if (typeof API.Initialize === 'function')
      this.is2004 = true;
    else {
      // SCORM 1.2
      this.prefix = 'LMS';
      this.core = 'cmi.core.';
    }
    this.reporter = reporter;
  }

  /**
   * Recursive function used to find the SCORM "API" object
   * @param {object} win - The 'window' object to scan for global SCORM API objects
   * @param {number} tries - Recursive attempts currently achieved
   * @returns {object} - The global SCORM API object, or `null` if not found
   */
  static scanForAPI(win, tries) {
    if (win.API_1484_11 && win.API_1184_11.Initialize && win.API_1184_11.SetValue && win.API_1184_11.Commit)
      return win.API_1184_11;
    else if (win.API && win.API.LMSInitialize && win.API.LMSSetValue && win.API.LMSCommit)
      return win.API;
    else if (win.parent && win.parent !== win && tries++ < SCORM.DISCOVER_MAX_TRIES)
      return SCORM.scanForAPI(win.parent, tries);
    else
      return null;
  }

  /**
   * Checks for the presence of a SCORM API on the current browser session.
   * @param {module:report/Reporter.Reporter} reporter - The {@link module:Reporter.Reporter Reporter} linked to the requested SCORM object
   * @returns {module:report/SCORM.SCORM} - A valid SCORM object, or `null` if no SCORM API was found.
   */
  static getSCORM(reporter) {
    let result = null;
    try {
      let api = SCORM.scanForAPI(window, 0);
      if (api === null && window.opener)
        api = SCORM.scanForAPI(window.opener, 0);

      if (api) {
        result = new SCORM(api, reporter);
        if (!result.initialize())
          result = null;
      }
    } catch (ex) {
      result = null;
      log('warn', 'Unable to use SCORM: %s', ex.toString());
    }
    return result;
  }

  /**
   * Initializes communication with the SCORM API
   * @returns {boolean}
   */
  initialize() {
    let result = false;
    try {
      result = this.API[this.prefix + 'Initialize']('');
      if (result) {
        this.studentId = this.getValue(this.core + (this.is2004 ? 'learner_id' : 'student_id'));
        this.studentName = this.getValue(this.core + (this.is2004 ? 'learner_name' : 'student_name'));
        this.setValue(this.core + 'score.min', 0);
        this.setValue(this.core + 'score.max', 100);
        external_jquery_default()(window).on('unload', () => {
          this.commitInfo();
          this.terminate();
          this.API = null;
        });
      }
      log('debug', 'SCORM initialized');
    } catch (ex) {
      log('error', `Error initializing SCORM API: ${ex.message}`);
    }
    return result;
  }

  /**
   * Terminates communication with the SCORM API
   * @returns {boolean}
   */
  terminate() {
    let result = false;
    try {
      result = this.API[this.is2004 ? 'Terminate' : 'LMSFinish']('');
    } catch (ex) {
      log('error', `Error terminating SCORM API: ${ex.message}`);
    }
    return result;
  }

  /**
   * Commits the current information to the SCORM API
   */
  commitInfo() {
    const
      info = this.reporter.getInfo(),
      score = Math.round(info.globalScore * 100),
      time = this.getTimeExpression(info.tTime);

    this.setValue(this.core + 'score.raw', score);
    this.setValue(this.core + 'session_time', time);
    this.commit();
    log('debug', `SCORM results reported: ${score} (${time})`);
  }

  /**
   * Commits current pending data to the SCORM API
   * @returns {boolean}
   */
  commit() {
    let result = false;
    try {
      result = this.API[this.prefix + 'Commit']('');
    } catch (ex) {
      log('error', 'Error commiting data to the SCORM API: ${ex.message}');
    }
    return result;
  }

  /**
   * Sends a specific value to the SCORM API
   * @param {string} key - A SCORM valid key
   * @param {string|number} value - The value associated with this key
   * @returns {string}
   */
  setValue(key, value) {
    let result = false;
    try {
      result = this.API[this.prefix + 'SetValue'](key, value);
    } catch (ex) {
      log('error', `Error setting value "${value}" to "${key}" in SCORM API: ${ex.message}`);
    }
    return result;
  }

  /**
   * Gets a specific value from the SCORM API
   * @param {string} key - A SCORM valid key
   * @returns {string} - The value associated with the provided key, or `null` if not found
   */
  getValue(key) {
    let result = false;
    try {
      result = this.API[this.prefix + 'GetValue'](key);
    } catch (ex) {
      log('error', `Error retrieving "${key}" from SCORM API: ${ex.message}`);
    }
    return result;
  }

  /**
   * Gets a string expression of the given time (in milliseconds) suitable for a SCORM transaction.
   * @see {@link http://www.ostyn.com/standards/scorm/samples/ISOTimeForSCORM.htm}
   * @param {number} millis - The amount of time, in milliseconds
   * @returns {string} - An ISO8601 valid expression
   */
  getTimeExpression(millis) {
    const
      d = new Date(millis),
      h = d.getUTCHours(),
      m = d.getUTCMinutes(),
      s = d.getUTCSeconds();

    return this.is2004 ?
      `PT${h}H${m}M${s}S` :
      `${('0000' + h).slice(-4)}:${('00' + m).slice(-2)}:${('00' + s).slice(-2)}`;
  }

  /**
   * Gets the SCORM type of this SCORM object
   * @returns {string}
   */
  getScormType() {
    return `SCORM ${this.is2004 ? '2004' : '1.2'}`;
  }
}

Object.assign(SCORM.prototype, {
  /**
   * True when the API is of type SCORM 2004, false for SCORM 1.2
   * @name module:report/SCORM.SCORM#is2004
   * @type {boolean} */
  is2004: false,
  /**
   * The Reporter associated to this SCORM object
   * @name module:report/SCORM.SCORM#reporter
   * @type {module:report/Reporter.Reporter} */
  reporter: null,
  /**
   * Prefix to be used in SCORM function names. Should be 'LMS' for SCORM 1.2
   * @name module:report/SCORM.SCORM#prefix
   * @type {string} */
  prefix: '',
  /**
   * Prefix used in core SCORM keys. Should be 'cmi.core.' for 1.2 and 'cmi.' for 2004
   * @name module:report/SCORM.SCORM#core
   * @type {string} */
  core: 'cmi.',
  /**
   * SCORM API object used to communicate with the LMS
   * @name module:report/SCORM.SCORM#API
   * @type {object} */
  API: null,
  /**
   * The student ID retrieved from the SCORM API
   * @name module:report/SCORM.SCORM#studentId
   * @type {string} */
  studentId: '',
  /**
   * The student name retrieved from the SCORM API
   * @name module:report/SCORM.SCORM#studentName
   * @type {string} */
  studentName: '',
});

/**
 * Maximum recursive attempts allowed to find the global SCORM API object
 * @type {number} */
SCORM.DISCOVER_MAX_TRIES = 50;

/* harmony default export */ const report_SCORM = (SCORM);

;// CONCATENATED MODULE: ./src/report/Reporter.js
/**
 *  File    : report/Reporter.js
 *  Created : 17/05/2016
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */

/* global Promise, window */







/**
 * This class implements the basic operations related with the processing of times and scores
 * done by users playing JClic activities. These operations include: identification of users,
 * compilation of data coming from the activities, storage of this data for later use, and
 * presentation of summarized results.
 */
class Reporter {
  /**
   * Reporter constructor
   * @param {module:JClicPlayer.JClicPlayer} ps - The {@link module:JClicPlayer.JClicPlayer JClicPlayer} used to retrieve localized messages
   */
  constructor(ps) {
    this.ps = ps;
    this.sessions = [];
    this.started = new Date();
    this.initiated = false;
    this.info = new ReporterInfo(this);
  }

  /**
   * Registers a new type of reporter
   * @param {string} reporterName - The name used to identify this reporter
   * @param {function} reporterClass - The reporter class, usually extending Reporter
   * @returns {module:report/Reporter.Reporter} - The provided reporter class
   */
  static registerClass(reporterName, reporterClass) {
    Reporter.CLASSES[reporterName] = reporterClass;
    return reporterClass;
  }

  /**
   * Creates a new Reporter of the requested class
   * The resulting object must be prepared to operate with a call to its `init` method.
   * @param {string} className - Class name of the requested reporter. When `null`, a basic Reporter is created.
   * @param {module:JClicPlayer.JClicPlayer} ps - The {@link module:JClicPlayer.JClicPlayer JClicPlayer} used to retrieve localized messages
   * @returns {module:report/Reporter.Reporter}
   */
  static getReporter(className, ps) {
    let result = null;
    if (className === null) {
      className = 'Reporter';
      if (ps.options.hasOwnProperty('reporter'))
        className = ps.options.reporter;
    }
    if (Reporter.CLASSES.hasOwnProperty(className))
      result = new Reporter.CLASSES[className](ps);
    else
      log('error', 'Unknown reporter class: %s', className);

    return result;
  }

  /**
   * Returns the `info` element associated to this Reporter.
   * @returns {module:report/Reporter.ReporterInfo}
   */
  getInfo() {
    return this.info.recalc();
  }

  /**
   * Gets a specific property from this reporting system
   * @param {string} key - Requested property
   * @param {string}+ defaultValue - Default return value when requested property does not exist
   * @returns {string}
   */
  getProperty(key, defaultValue) {
    return defaultValue;
  }

  /**
   * Gets a specific boolean property from this reporting system
   * @param {string} key - Requested property
   * @param {boolean}+ defaultValue - Default return when requested property does not exist
   * @returns {boolean}
   */
  getBooleanProperty(key, defaultValue) {
    const s = this.getProperty(key, defaultValue === true ? 'true' : 'false');
    return key === null ? defaultValue : s === 'true' ? true : false;
  }

  /**
   * Gets the list of groups or organizations currently registered in the system. This
   * method should be implemented by classes derived of `Reporter`.
   * @returns {external:Promise} - When fulfilled, an array of group data is returned as a result
   */
  getGroups() {
    return Promise.reject('No groups defined!');
  }

  /**
   * Gets the list of users currently registered in the system, optionally filtered by
   * a specific group ID. This method should be implemented by classes derived of `Reporter`.
   * @param {string}+ groupId - Optional group ID to be used as a filter criteria
   * @returns {external:Promise} - When fulfilled, an object with a collection of user data records
   * is returned
   */
  getUsers(groupId) {
    return Promise.reject('No users defined in ' + groupId);
  }

  /**
   * Gets extended data associated with a specific user. This is a method intended to be
   * implemented in subclasses.
   * @param {string} _userId - The requested user ID
   * @returns {external:Promise} - When fulfilled, an object with user data is returned.
   */
  getUserData(_userId) {
    return Promise.reject('Unknown user!');
  }

  /**
   * Gets extended data associated with a specific group or organization. This
   * is a method intended to be implemented in subclasses.
   * @param {string} _groupId - The requested group ID
   * @returns {external:Promise} - When fulfilled, an object with group data is returned.
   */
  getGroupData(_groupId) {
    return Promise.reject('Unknown group!');
  }

  /**
   * Checks if this reporting system manages its own database of users and groups. Defaults to `false`
   * @returns {boolean}
   */
  userBased() {
    if (this.bUserBased === null)
      this.bUserBased = this.getBooleanProperty('USER_TABLES', false);
    return this.bUserBased;
  }

  /**
   * Allows the current user to create a new group, and asks his name
   * @returns {external:Promise} - When fulfilled, the chosen name for the new group is returned.
   */
  promptForNewGroup() {
    // TODO: Implement promptForNewGroup
    return Promise.reject('Remote creation of groups not yet implemented!');
  }

  /**
   * Allows the current user to create a new user ID, and asks his ID and password
   * @returns {external:Promise} - When fulfilled, an object with the new user ID and password
   * is returned.
   */
  promptForNewUser() {
    // TODO: Implement promptForNewUser
    return Promise.reject('Remote creation of users not yet implemented!');
  }

  /**
   * Allows the current user to select its group or organization from the current groups list
   * @returns {external:Promise}
   */
  promptGroupId() {
    return new Promise((resolve, reject) => {
      if (!this.userBased())
        reject('This system does not manage users!');
      else {
        this.getGroups().then((groupList) => {
          // Creation of new groups not yet implemented!
          if (!groupList || groupList.length < 1)
            reject('No groups defined!');
          else {
            let sel = 0;
            const $groupSelect = external_jquery_default()('<select/>').attr({ size: Math.max(3, Math.min(15, groupList.length)) });
            groupList.forEach(g => $groupSelect.append(external_jquery_default()('<option/>').attr({ value: g.id }).text(g.name)));
            $groupSelect.change(ev => { sel = ev.target.selectedIndex; });
            this.ps.skin.showDlg(true, {
              main: [
                external_jquery_default()('<h2/>', { class: 'subtitle' }).html(getMsg('Select group:')),
                $groupSelect],
              bottom: [
                this.ps.skin.$okDlgBtn,
                this.ps.skin.$cancelDlgBtn]
            }).then(() => {
              resolve(groupList[sel].id);
            }).catch(reject);
          }
        }).catch(reject);
      }
    });
  }

  /**
   * Asks for a valid user ID fulfilling the promise if found, rejecting it otherwise
   * @param {boolean}+ forcePrompt - Prompt also if `userId` is already defined (default is `false`)
   * @returns {external:Promise}
   */
  promptUserId(forcePrompt) {
    return new Promise((resolve, reject) => {
      if (this.userId !== null && !forcePrompt)
        resolve(this.userId);
      else if (!this.userBased())
        reject('This system does not manage users!');
      else {
        const $pwdInput = external_jquery_default()('<input/>', { type: 'password', size: 8, maxlength: 64 });
        if (this.getBooleanProperty('SHOW_USER_LIST', true)) {
          this.promptGroupId().then(groupId => {
            this.getUsers(groupId).then(userList => {
              // Creation of new users not yet implemented
              // let userCreationAllowed = this.getBooleanProperty('ALLOW_CREATE_USERS', false)
              if (!userList || userList.length < 1)
                reject('Group ' + groupId + ' has no users!');
              else {
                let sel = -1;
                const $userSelect = external_jquery_default()('<select/>').attr({ size: Math.max(3, Math.min(15, userList.length)) });
                userList.forEach(u => $userSelect.append(external_jquery_default()('<option/>').attr({ value: u.id }).text(u.name)));
                $userSelect.change(ev => { sel = ev.target.selectedIndex; });
                this.ps.skin.showDlg(true, {
                  main: [
                    external_jquery_default()('<h2/>', { class: 'subtitle' }).html(getMsg('Select user:')),
                    $userSelect,
                    external_jquery_default()('<h2/>', { class: 'subtitle' }).html(getMsg('Password:')).append($pwdInput)],
                  bottom: [
                    this.ps.skin.$okDlgBtn,
                    this.ps.skin.$cancelDlgBtn]
                }).then(() => {
                  if (sel >= 0) {
                    if (userList[sel].pwd && EncryptMin.Decrypt(userList[sel].pwd) !== $pwdInput.val()) {
                      window.alert(getMsg('Incorrect password'));
                      reject('Incorrect password');
                    } else {
                      this.userId = userList[sel].id;
                      resolve(this.userId);
                    }
                  } else
                    reject('No user has been selected');
                }).catch(reject);
              }
            }).catch(reject);
          }).catch(reject);
        } else {
          const $userInput = external_jquery_default()('<input/>', { type: 'text', size: 8, maxlength: 64 });
          this.ps.skin.showDlg(true, {
            main: [
              external_jquery_default()('<div/>').css({ 'text-align': 'right' })
                .append(external_jquery_default()('<h2/>', { class: 'subtitle' }).html(getMsg('User:'))
                  .append($userInput))
                .append(external_jquery_default()('<h2/>', { class: 'subtitle' }).html(getMsg('Password:'))
                  .append($pwdInput))],
            bottom: [
              this.ps.skin.$okDlgBtn,
              this.ps.skin.$cancelDlgBtn]
          }).then(() => {
            this.getUserData($userInput.val()).then(user => {
              if (user.pwd && EncryptMin.Decrypt(user.pwd) !== $pwdInput.val()) {
                window.alert(getMsg('Incorrect password'));
                reject('Incorrect password');
              } else {
                this.userId = user.id;
                resolve(this.userId);
              }
            }).catch(reject);
          }).catch(reject);
        }
      }
    });
  }

  /**
   * Builds a complex object containing all the results reported while playing activities
   * @returns {object} - The current results
   */
  getData() {

    // Force the re-calculation of all scores
    this.info.recalc();

    const result = {
      started: this.started.toISOString(),
      descriptionKey: this.descriptionKey,
      descriptionDetail: this.descriptionDetail,
      projects: this.info.numSessions,
      sequences: this.info.numSequences,
      activitiesDone: this.info.nActivities,
      playedOnce: this.info.nActPlayed,
      reportable: this.info.reportableActs,
      ratioPlayed: Math.round(this.info.ratioPlayed * 100),
      activitiesSolved: this.info.nActSolved,
      ratioSolved: Math.round(this.info.ratioSolved * 100),
      actScore: this.info.nActScore,
      partialScore: Math.round(this.info.partialScore * 100),
      globalScore: Math.round(this.info.globalScore * 100),
      time: Math.round(this.info.tTime / 10) / 100,
      actions: this.info.nActions,
      sessions: []
    };

    if (this.userId)
      result.userId = this.userId;
    else if (this.SCORM)
      result.user = this.SCORM.studentName + (this.SCORM.studentId === '' ? '' : ` (${this.SCORM.studentId})`);

    this.sessions.forEach(sr => {
      if (sr.getInfo().numSequences > 0)
        result.sessions.push(sr.getData(false, false));
    });

    return result;
  }

  /**
   * Initializes this report system with an optional set of parameters.
   * Returns a Promise, fulfilled when the reporter is fully initialized.
   * @param {object} [options] - Initial settings passed to the reporting system
   * @returns {external:Promise}
   */
  init(options) {
    if (!options)
      options = this.ps.options;
    this.userId = getVal(options.user);
    this.sessionKey = getVal(options.key);
    this.sessionContext = getVal(options.context);
    this.groupCodeFilter = getVal(options.groupCodeFilter);
    this.userCodeFilter = getVal(options.userCodeFilter);
    if (options.SCORM !== false) {
      this.SCORM = report_SCORM.getSCORM(this);
      if (this.SCORM !== null && this.descriptionKey === Reporter.prototype.descriptionKey)
        this.descriptionKey = this.SCORM.getScormType();
    }
    this.initiated = true;
    log('debug', 'Basic Reporter initialized');
    return Promise.resolve(true);
  }

  /**
   * Closes this reporting system
   * @returns {external:Promise} - A Promise object to be fullfilled when all pending tasks are finished.
   */
  end() {
    log('debug', 'Basic Reporter ending');
    this.endSession();
    return Promise.resolve(true);
  }

  /**
   * Finalizes the current sequence
   */
  endSequence() {
    if (this.currentSession) {
      this.currentSession.endSequence();
      this.info.valid = false;
    }
  }

  /**
   * Finalizes the current session
   */
  endSession() {
    this.endSequence();
    this.currentSession = null;
  }

  /**
   * Creates a new group (method to be implemented in subclasses)
   * @param {object} _gd
   */
  newGroup(_gd) {
    throw "No database!";
  }

  /**
   * Creates a new user (method to be implemented in subclasses)
   * @param {object} _ud
   */
  newUser(_ud) {
    throw "No database!";
  }

  /**
   * This method should be invoked when a new session starts.
   * @param {module:project/JClicProject.JClicProject} jcp - The {@link module:project/JClicProject.JClicProject JClicProject} this session refers to.
   */
  newSession(jcp) {
    this.endSession();
    this.currentSession = new report_SessionReg(jcp);
    this.sessions.push(this.currentSession);
    this.info.valid = false;
  }

  /**
   * This method should be invoked when a new sequence starts
   * @param {module:bags/ActivitySequenceElement.ActivitySequenceElement} ase - The {@link module:bags/ActivitySequenceElement.ActivitySequenceElement ActivitySequenceElement} referenced by this sequence.
   */
  newSequence(ase) {
    if (this.currentSession) {
      this.currentSession.newSequence(ase);
      this.info.valid = false;
      if (this.SCORM)
        this.SCORM.commitInfo();
    }
  }

  /**
   * This method should be invoked when the user starts a new activity
   * @param {module:Activity.Activity} act - The {@link module:Activity.Activity Activity} reporter has just started
   */
  newActivity(act) {
    if (this.currentSession) {
      this.currentSession.newActivity(act);
      this.info.valid = false;
    }
  }

  /**
   * This method should be called when the current activity finishes. Data about user's final results
   * on the activity will then be saved.
   * @param {number} score - The final score, usually in a 0-100 scale.
   * @param {number} numActions - The total number of actions done by the user to solve the activity
   * @param {boolean} solved - `true` if the activity was finally solved, `false` otherwise.
   */
  endActivity(score, numActions, solved) {
    if (this.currentSession) {
      this.currentSession.endActivity(score, numActions, solved);
      this.info.valid = false;
    }
  }

  /**
   * Reports a new action done by the user while playing the current activity
   * @param {string} type - Type of action (`click`, `write`, `move`, `select`...)
   * @param {string}+ source - Description of the object on which the action is done.
   * @param {string}+ dest - Description of the object reporter acts as a target of the action (usually in pairings)
   * @param {boolean} ok - `true` if the action was OK, `false`, `null` or `undefined` otherwhise
   */
  newAction(type, source, dest, ok) {
    if (this.currentSession) {
      this.currentSession.newAction(type, source, dest, ok);
      this.info.valid = false;
    }
  }

  /**
   * Gets information about the current sequence
   * @returns {module:report/SequenceReg.SequenceRegInfo}
   */
  getCurrentSequenceInfo() {
    return this.currentSession === null ? null : this.currentSession.getCurrentSequenceInfo();
  }

  /**
   * Gets the name of the current sequence
   * @returns {string}
   */
  getCurrentSequenceTag() {
    return this.currentSession === null ? null : this.currentSession.getCurrentSequenceTag();
  }
}

Object.assign(Reporter.prototype, {
  /**
   * The {@link module:report/Reporter.ReporterInfo ReporterInfo} used to calculate and store global results.
   * @name module:report/Reporter.Reporter#info
   * @type {module:report/Reporter.ReporterInfo} */
  info: null,
  /**
   * The {@link module:JClicPlayer.JClicPlayer JClicPlayer} used to retrieve messages
   * @name module:report/Reporter.Reporter#ps
   * @type {module:JClicPlayer.JClicPlayer} */
  ps: null,
  /**
   * A valid SCORM bridge, or `null` if no SCORM API detected.
   * @name module:report/Reporter.Reporter#SCORM */
  SCORM: null,
  /**
   * User ID currently associated with this reporting system
   * @name module:report/Reporter.Reporter#userId
   * @type {string} */
  userId: null,
  /**
   * Optional key to be added as a field in session records
   * @name module:report/Reporter.Reporter#sessionKey
   * @type {string} */
  sessionKey: null,
  /**
   * A second optional key to be reported as a field in session records
   * @name module:report/Reporter.Reporter#sessionContext
   * @type {string} */
  sessionContext: null,
  /**
   * Optional filter key to be used in the group selection dialog
   * @name module:report/Reporter.Reporter#groupCodeFilter
   * @type {string} */
  groupCodeFilter: null,
  /**
   * Another optional filter key to be used in the user selection dialog
   * @name module:report/Reporter.Reporter#userCodeFilter
   * @type {string} */
  userCodeFilter: null,
  /**
   * Description of this reporting system
   * @name module:report/Reporter.Reporter#descriptionKey
   * @type {string} */
  descriptionKey: 'Results are not currently being saved',
  /**
   * Additional info to display after the reporter's `description`
   * @name module:report/Reporter.Reporter#descriptionDetail
   * @type {string} */
  descriptionDetail: '',
  /**
   * Starting date and time of this report
   * @name module:report/Reporter.Reporter#started
   * @type {external:Date} */
  started: null,
  /**
   * Array of sessions included in this report
   * @name module:report/Reporter.Reporter#sessions
   * @type {module:report/SessionReg.SessionReg[]} */
  sessions: [],
  /**
   * Currently active session
   * @name module:report/Reporter.Reporter#currentSession
   * @type {module:report/SessionReg.SessionReg} */
  currentSession: null,
  /**
   * `true` if the system was successfully initiated, `false` otherwise
   * @name module:report/Reporter.Reporter#initiated
   * @type {boolean} */
  initiated: false,
  /**
   * `true` if the system is connected to a database with user's data.
   * When `false`, a generic ID will be used.
   * @name module:report/Reporter.Reporter#bUserBased
   * @type {boolean} */
  bUserBased: null,
  /**
   * Maximum number of incorrect UserID attempts
   * @name module:report/Reporter.Reporter#MAX_USERID_PROMPT_ATTEMPTS
   * @type {number} */
  MAX_USERID_PROMPT_ATTEMPTS: 3,
});

/**
 * This object stores the global results of a {@link module:Reporter.Reporter Reporter}
 */
class ReporterInfo {
  /**
   * ReporterInfo constructor
   * @param {module:report/Reporter.Reporter} rep - The {@link module:Reporter.Reporter Reporter} associated tho this `Info` object.
   */
  constructor(rep) {
    this.rep = rep;
  }

  /**
   * Clears all data associated with this ReporterInfo
   */
  clear() {
    this.numSessions = this.numSequences = this.nActivities = this.reportableActs = this.nActSolved =
      this.nActPlayed = this.nActScore = this.nActions = this.ratioSolved = this.ratioPlayed =
      this.tScore = this.tTime = this.partialScore = this.globalScore = 0;
    this.valid = false;
  }

  /**
   * Computes the value of all global variables based on the data stored in `sessions`
   * @returns {module:report/Reporter.ReporterInfo} - This "info" object
   */
  recalc() {
    if (!this.valid) {
      this.clear();
      this.rep.sessions.forEach(ses => {
        const inf = ses.getInfo();
        this.reportableActs += inf.sReg.reportableActs;
        if (inf.numSequences > 0) {
          this.numSessions++;
          this.numSequences += inf.numSequences;
          if (inf.nActivities > 0) {
            this.nActivities += inf.nActivities;
            this.nActPlayed += inf.sReg.actNames.length;
            this.nActSolved += inf.nActSolved;
            this.nActions += inf.nActions;
            if (inf.nActScore > 0) {
              this.tScore += inf.tScore * inf.nActScore;
              this.nActScore += inf.nActScore;
            }
            this.tTime += inf.tTime;
          }
        }
      });
      if (this.nActivities > 0) {
        this.ratioSolved = this.nActSolved / this.nActivities;
        if (this.reportableActs > 0)
          this.ratioPlayed = this.nActPlayed / this.reportableActs;
        this.partialScore = this.tScore / (this.nActScore * 100);
        this.globalScore = this.partialScore * this.ratioPlayed;
      }
      this.valid = true;
    }
    return this;
  }
}

Object.assign(ReporterInfo.prototype, {
  /**
   * The Reporter linked to this Info object
   * @name module:report/Reporter.ReporterInfo#rep
   * @type {module:report/Reporter.Reporter}
   */
  rep: null,
  /**
   * When `false`, data must be recalculated
   * @name module:report/Reporter.ReporterInfo#valid
   * @type {boolean} */
  valid: false,
  /**
   * Number of sessions registered
   * @name module:report/Reporter.ReporterInfo#numSessions
   * @type {number} */
  numSessions: 0,
  /**
   * Number of sequences played
   * @name module:report/Reporter.ReporterInfo#numSequences
   * @type {number} */
  numSequences: 0,
  /**
   * Number of activities played
   * @name module:report/Reporter.ReporterInfo#nActivities
   * @type {number} */
  nActivities: 0,
  /**
   * Number of activities in existing in the played projects suitable to be reported
   * @name module:report/Reporter.ReporterInfo#reportableActs
   * @type {number} */
  reportableActs: 0,
  /**
   * Number of activities solved
   * @name module:report/Reporter.ReporterInfo#nActSolved
   * @type {number} */
  nActSolved: 0,
  /**
   * Number of different activities played
   * @name module:report/Reporter.ReporterInfo#nActPlayed
   * @type {number} */
  nActPlayed: 0,
  /**
   * Global score obtained in all sessions registered by this reporter
   * @name module:report/Reporter.ReporterInfo#nActScore
   * @type {number} */
  nActScore: 0,
  /**
   * Number of actions done by the user while in this working session
   * @name module:report/Reporter.ReporterInfo#nActions
   * @type {number} */
  nActions: 0,
  /**
   * Percentage of solved activities
   * @name module:report/Reporter.ReporterInfo#ratioSolved
   * @type {number} */
  ratioSolved: 0,
  /**
   * Percentage of reportable activities played
   * @name module:report/Reporter.ReporterInfo#ratioPlayed
   * @type {number} */
  ratioPlayed: 0,
  /**
   * Sum of the scores of all the activities played
   * @name module:report/Reporter.ReporterInfo#tScore
   * @type {number} */
  tScore: 0,
  /**
   * Global score obtained
   * @name module:report/Reporter.ReporterInfo#partialScore
   * @type {number} */
  partialScore: 0,
  /**
   * Sum of the playing time reported by each activity (not always equals to the sum of all session's time)
   * @name module:report/Reporter.ReporterInfo#tTime
   * @type {number} */
  tTime: 0,
  /**
   * Final score based on the percent of reportable activities played. If the user plays all the
   * activities, this result equals to `partialScore`.
   * @name module:report/Reporter.ReporterInfo#globalScore
   * @type {number} */
  globalScore: 0,
});

Reporter.Info = ReporterInfo;

/**
 * Static list of classes derived from Reporter. It should be filled by Reporter classes at declaration time.
 * @type {object}
 */
Reporter.CLASSES = { 'Reporter': Reporter };

/* harmony default export */ const report_Reporter = (Reporter);

;// CONCATENATED MODULE: ./src/JClicPlayer.js
/**
 *  File    : JClicPlayer.js
 *  Created : 28/04/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2022 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */

/* global JSON, Promise, location, window, document */

















/**
 * JClicPlayer is one of the the main classes of the JClic system. It implements the
 * {@link http://projectestac.github.io/jclic/apidoc/edu/xtec/jclic/PlayStation.html PlayStation}
 * interface, needed to host JClic activities.
 * JClicPlayer offers to {@link module:Activity.ActivityPanel ActivityPanel} objects all the necessary resources and functions:
 * media bags (to load and realize images and other media contents), sequence control, management
 * of the reporting system, user interface, display of system messages, etc.
 * @extends module:AWT.Container
 */
class JClicPlayer extends Container {

  /**
   * JClicPlayer constructor
   * @param {external:jQuery} $topDiv - The HTML `div` element where this JClicPlayer will deploy.
   * @param {object} [options] - A set of optional customized options.
   */
  constructor($topDiv, options) {

    // JClicPlayer extends Container
    super();
    // Build cascading options
    options = init(options);
    this.options = external_jquery_default().extend(Object.create(this.options), options);
    // Generate unique ID
    this.id = `JC${(0x10000 + Math.round(Math.random() * 0xFFFF)).toString(16).toUpperCase().substr(1)}`;
    // Identify the HTML element where this player will deploy
    this.$topDiv = $topDiv || external_jquery_default()('<div/>');
    // Avoid side effects of 'align=center' in old HTML pages
    this.$topDiv.css({ 'text-align': 'initial' });

    // Special case: $topDiv inside a TD (like in http://clic.xtec.cat/gali)
    if (this.$topDiv.parent().is('td')) {
      // Set explicit width and height to fill-in the TD
      this.$topDiv.css({
        width: toCssSize(this.options.width, null, null, '100%'),
        height: toCssSize(this.options.height, null, null, '100%'),
      });
    }

    // Build the main container
    this.$mainContainer = external_jquery_default()('<div/>', { class: 'JClicContainer', id: this.id })
      .css({ width: '100%', height: '100%' })
      .appendTo(this.$topDiv);

    // Intitialize other elements
    this.localFS = location && location.protocol === 'file:';
    this.$div = external_jquery_default()('<div/>', { class: 'JClicPlayer' });
    this.project = new project_JClicProject();
    this.activeMediaBag = new media_ActiveMediaBag();
    this.counterVal = { score: 0, actions: 0, time: 0 };
    this.bgImageOrigin = new Point();
    this.buildActions();
    this.history = new src_PlayerHistory(this);
    this.audioEnabled = this.options.audioEnabled;
    this.navButtonsAlways = this.options.navButtonsAlways;
    this.defaultSkin = skins_Skin.getSkin(this.options.skin, this);
    this.setSkin(skins_Skin.getSkin('@empty.xml', this));
    this.initTimers();
    this.listenTouchEvents();
    log('info', 'JClicPlayer ready');
  }

  /**
   *
   * Detects swipe-right, swipe-left and double touch gestures on touch devices,
   * associating them with 'next activity', 'previous activity' and 'toggle full screen' actions
   */
  listenTouchEvents() {

    // Enable listeners only in touch devices
    //if ('ontouchstart' in window) {

    let startTouch = null;
    let startTouchTime = 0;
    let thisDiv = this.$div[0];
    const { minSwipeX, maxSwipeY, rightToLeft } = this.options;

    // Generic handler for touch events
    const touchEventHandler = event => {
      // Process only single-finger events targeted to our main 'div'
      if (event.target === thisDiv && event.changedTouches && event.changedTouches.length === 1) {
        const touch = event.changedTouches[0];
        const dx = startTouch ? touch.clientX - startTouch.clientX : 0;
        const dy = startTouch ? touch.clientY - startTouch.clientY : 0;
        const dist = Math.sqrt(dx * dx + dy * dy);

        switch (event.type) {
          case 'touchstart':
            const currentTime = new Date();
            // Detect double taps, done in less than 800 ms and at short distance
            if (
              document && document.fullscreenEnabled
              && startTouch && startTouchTime
              && currentTime - startTouchTime < 800
              && dist < minSwipeX
            ) {
              event.preventDefault();
              log('info', 'Toggle full screen mode from double touch');
              this.skin.setScreenFull();
              startTouch = null;
            }
            else {
              startTouch = touch;
              startTouchTime = currentTime;
            }
            break;

          case 'touchend':
            // Discard non-horizontal gestures and those that do not have sufficient length
            if (startTouch && Math.abs(dx) > minSwipeX && Math.abs(dy) < maxSwipeY) {
              const actionName = dx < 0 && !rightToLeft ? 'next' : 'prev';
              const action = this.actions[actionName];
              if (action && action.enabled) {
                event.preventDefault();
                log('info', `Performing action "${actionName}" from touch gesture`);
                action.actionPerformed(event);
              }
              startTouch = null;
            }
            // Cancel double touch detection when long gestures detected
            else if (dist > minSwipeX)
              startTouch = null;
            break;

          case 'touchcancel':
            startTouch = null;
            break;
        }
      }
      else
        // Cancel any started gesture
        startTouch = null;
    };

    // Handle touch events
    thisDiv.addEventListener('touchstart', touchEventHandler);
    thisDiv.addEventListener('touchend', touchEventHandler);
    thisDiv.addEventListener('touchcancel', touchEventHandler);
    //}
  }

  /**
   * Generates an unique ID for elements being used with this player
   * @param {string} lb - The element's label
   * @returns {string}
   */
  getUniqueId(lb) {
    return `${this.id}-${lb}`;
  }

  /**
   * Builds the {@link module:AWT.Action} objects for this player
   */
  buildActions() {
    this.actions = {
      'next': new Action('next', () => this.history.processJump(this.project.activitySequence.getJump(false, this.reporter), false)),
      'prev': new Action('prev', () => this.history.processJump(this.project.activitySequence.getJump(true, this.reporter), false)),
      'return': new Action('return', () => this.history.pop()),
      'reset': new Action('reset', () => { if (this.actPanel && this.actPanel.act.canReinit()) this.initActivity(); }),
      'help': new Action('help', () => { if (this.actPanel) this.actPanel.showHelp(); }),
      'info': new Action('info', () => {
        if (this.actPanel && this.actPanel.act.hasInfo()) {
          if (this.actPanel.act.infoUrl)
            this.displayURL(this.act.infoUrl, true);
          else if (this.actPanel.act.infoCmd)
            this.runCmd(this.actPanel.act.infoCmd);
        }
      }),
      'reports': new Action('reports', () => this.showReports()),
      'audio': new Action('audio', () => {
        this.audioEnabled = !this.audioEnabled;
        if (!this.audioEnabled)
          this.stopMedia();
        media_EventSounds.prototype.globalEnabled = this.audioEnabled;
      })
    };

    external_jquery_default().each(this.actions, (key, value) => {
      value.addStatusListener(action => { if (this.skin) this.skin.actionStatusChanged(action); });
    });
  }

  /**
   * Resets the main components of this player
   */
  reset() {
    log('info', 'Restoring player');
    this.removeActivity();
    this.end();
    this.activeMediaBag = new media_ActiveMediaBag();
    this.history.clearHistory();
    this.setSkin(null);
    this.setMsg(null);
    this.setCounterValue('score', 0);
    this.setCounterValue('actions', 0);
    this.setCounterValue('time', 0);
    if (this.skin)
      this.skin.setWaitCursor('reset');
  }

  /**
   * Instructs the player to stop working
   */
  stop() {
    this.stopMedia(-1);
  }

  /**
   * Executes miscellaneous finalization routines.
   * @returns {external:Promise} - A promise to be fullfilled when all pending tasks are finished.
   */
  end() {
    let result = null;
    this.stopMedia();
    this.closeHelpWindow();
    if (this.reporter) {
      result = this.reporter.end();
      this.reporter = null;
    }
    if (this.actPanel) {
      this.actPanel.end();
      this.actPanel.$div.remove();
      this.actPanel = null;
    }
    if (this.project) {
      this.project.end();
      this.project = null;
    }
    if (this.activeMediaBag)
      this.activeMediaBag.removeAll();
    return result || Promise.resolve(true);
  }

  /**
   * Creates and initializes the {@link module:Reporter.Reporter Reporter} member
   * @returns {external:Promise}
   */
  initReporter() {
    if (this.reporter) {
      this.reporter.end();
      this.reporter = null;
    }
    this.reporter = report_Reporter.getReporter(null, this);
    return this.reporter.init();
  }

  /**
   * Creates and initializes objects of type {@link module:AWT.Timer}
   */
  initTimers() {
    // Main timer
    if (this.timer)
      this.timer.stop();
    this.timer = new Timer(() => {
      this.incCounterValue('time');
      if (this.actPanel && this.actPanel.act.maxTime > 0
        && this.actPanel.playing
        && this.counterVal['time'] >= this.actPanel.act.maxTime)
        this.actPanel.finishActivity(false);
    }, 1000, false);

    // One-time timer, for delayed actions
    if (this.delayedTimer)
      this.delayedTimer.stop();
    this.delayedTimer = new Timer(() => {
      if (this.delayedAction)
        this.delayedAction.processEvent(this.delayedAction, null);
    }, 1000, false);
    this.delayedTimer.repeats = false;
  }

  /**
   * Opens the reports dialog
   */
  showReports() {
    if (this.skin) this.skin.showReports(this.reporter);
  }

  /**
   * Closes the help dialog window
   */
  closeHelpWindow() {
    if (this.skin) this.skin._closeDlg(false);
  }

  /**
   * Sets the current skin
   * @param {module:skins/Skin.Skin} [newSkin] - The skin to use. When `null`, `defaultSkin` will be used.
   */
  setSkin(newSkin) {
    newSkin = newSkin || (this.project && this.project.skin ? this.project.skin : this.defaultSkin);
    if (newSkin && (this.skin === null || newSkin.name !== this.skin.name)) {
      newSkin.attach(this);
      this.skin = newSkin;
      this.skin.doLayout();
    }
  }

  /**
   * Sets the current project of this player, without starting any activity
   * @param {module:project/JClicProject.JClicProject} project - The project to be set
   */
  setProject(project) {
    if (this.project) {
      if (this.project !== project)
        this.project.end();
      this.removeActivity();
    }
    this.project = project || new project_JClicProject();
    this.project.realize(this);
  }

  /**
   * Loads the specified project and starts playing at the specified activity or sequence tag.
   * @param {string|JClicProject} [project] - The project to load (if it's a string) or to use (if it's an object of type {@link module:project/JClicProject.JClicProject JClicProject}).
   * When it's a `string`, it can be the absolute or relative path to:
   * - A `.jclic` project file, in XML format
   * - A `.jclic.json` project file in JSON format
   * - A `.jclic.zip` compressed project file (containing one file of type '.jclic' or '.jclic.json')
   * - A `.scorm.zip` file, as exported by JClic Author.
   * - A `project.json` file, as exported by JClic Author
   * When `null` or `undefined`, refers to the current project.
   * @param {string|number} [sequence] - Sequence tag or numeric order in the {@link module:bags/ActivitySequence.ActivitySequence ActivitySequence}
   * to be loaded. If _sequence_ and _activity_ are both `null`, the first {@link module:bags/ActivitySequenceElement.ActivitySequenceElement ActivitySequenceElement}
   * will be loaded.
   * @param {string} [activity] - Name of the activity to be loaded (usually `null`)
   */
  load(project, sequence, activity) {

    this.forceFinishActivity();
    this.setWaitCursor(true);

    // The ActivityPanel object to be obtained as a result of the loading process
    let actp = null;

    // step one: load the project
    if (project) {
      if (typeof project === 'string') {

        // Param `project` is a file name or URL (otherwise, is a realized `JClicProject` object)
        const fullPath = getPath(this.basePath, project);

        // Previous step: Check if `project` points to a "project.json" file
        if (fullPath.endsWith('project.json')) {
          log('info', `Loading JSON info from: ${fullPath}`);
          external_jquery_default().getJSON(fullPath).done(({ mainFile }) => {
            // Read the `mainFile` field of `project.json`
            if (mainFile && endsWith(mainFile, '.jclic') || endsWith(mainFile, '.jclic.json')) {
              // Load project's main file
              this.load(getPath(getBasePath(fullPath), mainFile), sequence, activity);
            } else {
              log('error', `Invalid or null "mainFile" specified in ${fullPath} - "project.json".`);
            }
          }).fail((jqhxr, textStatus, error) => {
            const errMsg = `${textStatus} (${error}) while loading ${project}`;
            log(errMsg);
            window.alert(`Error!\n${errMsg}`);
          }).always(
            () => this.setWaitCursor(false)
          );
          return;
        }

        // Step 0: Check if `project` points to a ZIP file
        if (fullPath.endsWith('.zip')) {
          // TODO: Implement register of zip files in PlayerHistory
          this.zip = null;
          log('info', `Loading ZIP file: ${fullPath}`);

          // Launch loading of ZIP file in a separated thread
          external_jszip_utils_default().getBinaryContent(fullPath, (err, data) => {
            if (err) {
              this.setWaitCursor(false);
              log('error', `Error loading ZIP file: ${err.toString()}`);
              return;
            }
            new (external_jszip_default())().loadAsync(data).then(zip => {
              this.zip = zip;
              this.zip.fullZipPath = fullPath;
              this.zip.zipBasePath = getBasePath(fullPath);
              let fileName = null;
              // Check if ZIP contains a "project.json" file (as in the ".scorm.zip" files generated by JClic Author)
              if (this.zip.files['project.json']) {
                this.zip.files['project.json'].async('string').then(content => {
                  try {
                    const json = JSON.parse(content);
                    // Read the `mainFile` field of `project.json`
                    if (endsWith(json['mainFile'], '.jclic')) {
                      // Load project's main file
                      this.load(getPath(this.zip.zipBasePath, json['mainFile']), sequence, activity);
                    } else {
                      log('error', `Invalid or null "mainFile" specified in ${fullPath} - "project.json".`);
                    }
                  } catch (err) {
                    log('error', `Error reading "project.json" in ${fullPath}: ${err ? err.toString() : 'unknown error'}`);
                  }
                }).catch(reason => {
                  log('error', `Error reading ZIP file: ${reason ? reason.toString() : 'unknown reason'}`);
                });
              } else {
                // Find first file with extension '.jclic' inside the zip file
                fileName = Object.keys(this.zip.files).find(fn => fn.endsWith('.jclic')) || null;
                if (fileName)
                  this.load(getPath(this.zip.zipBasePath, fileName), sequence, activity);
                else
                  log('error', 'This ZIP file does not contain any JClic project!');
              }
              this.setWaitCursor(false);
            }).catch(reason => {
              log('error', `Error reading ZIP file: ${reason ? reason.toString() : 'unknown reason'}`);
              this.setWaitCursor(false);
            });
          });
          return;
        } else if (this.localFS && window.JClicObject && !window.JClicObject.projectFiles[fullPath]) {
          external_scriptjs_default()(`${fullPath}.js`, () => {
            // 25 Mar 20201:
            // Workaround for a bug on Chrome and Firefox XML parsers, throwing errors whith hexadecimal character entities
            if (window.JClicObject.projectFiles[fullPath]) {
              window.JClicObject.projectFiles[fullPath] = mReplace([
                [/&#xD;/g, '\r'],
                [/&#xA;/g, '\n'],
                [/&#x9;/g, '\t'],
              ], window.JClicObject.projectFiles[fullPath]);
              this.load(project, sequence, activity);
            }
          });
          this.setWaitCursor(false);
          return;
        }

        // Step one: load the project file
        const processProjectFile = fp => {
          const isXml = fp.indexOf('data:text/xml;') === 0 || fp.endsWith('.jclic');

          const loader = isXml ? external_jquery_default().get(fp, null, null, 'xml') : external_jquery_default().getJSON(fp);

          loader.done(data => {
            if (data === null || typeof data !== 'object') {
              log('error', `Bad data. Project not loaded: ${project}`);
              return;
            }
            const prj = new project_JClicProject();
            if (isXml)
              prj.setProperties(external_jquery_default()(data).find('JClicProject'), fullPath, this.zip, this.options);
            else
              prj.setAttributes(data, fullPath, this.zip, this.options);

            log('info', `Project file loaded and parsed: ${project}`);
            const elements = prj.mediaBag.buildAll(null, element => {
              log('trace', `"${element.name}" ready.`);
              this.incProgress(1);
            }, this);
            log('info', `Media elements to be loaded: ${elements}`);
            this.setProgress(0, elements);
            let loops = 0;
            const interval = 500;
            this.setWaitCursor(true);
            const checkMedia = window.setInterval(() => {
              // Wait for a maximum time of two minutes
              if (++loops > this.options.maxWaitTime / interval) {
                window.clearInterval(checkMedia);
                this.setProgress(-1);
                this.setWaitCursor(false);
                log('error', 'Error loading media');
              }
              const waitingObjects = prj.mediaBag.countWaitingElements();
              // player.setProgress(waiting)
              if (waitingObjects === -1) {
                window.clearInterval(checkMedia);
                this.setProgress(-1);
                this.setWaitCursor(false);
                // Call `load` again, passing the loaded [JClicProject](JClicProject.html) as a parameter
                this.load(prj, sequence, activity);
              }
            }, interval);
          }).fail((jqXHR, textStatus, errorThrown) => {
            const errMsg = `${textStatus} (${errorThrown}) while loading ${project}`;
            log(errMsg);
            window.alert(`Error!\n${errMsg}`);
          }).always(() => this.setWaitCursor(false));
        };


        log('info', `Loading project: ${project}`);
        let fp = fullPath;

        // Special case for ZIP files
        if (this.zip) {
          const fName = getRelativePath(fp, this.zip.zipBasePath);
          if (this.zip.files[fName]) {
            this.zip.file(fName).async('string').then(text => {
              processProjectFile(`data:${fName.endsWith('.jclic') ? 'text/xml' : 'application/json'};charset=UTF-8,${text}`);
            }).catch(reason => {
              log('error', `Unable to extract "${fName}" from ZIP file because of: ${reason ? reason.toString() : 'unknown reason'}`);
              this.setWaitCursor(false);
            });
            return;
          }
        }
        // Special case for local file systems (using `file` protocol)
        else if (this.localFS) {
          // Check if file is already loaded in the global variable `JClicObject`
          if (window.JClicObject && window.JClicObject.projectFiles[fullPath]) {
            fp = `data:${fullPath.endsWith('.jclic') ? 'text/xml' : 'application/json'};charset=UTF-8,${window.JClicObject.projectFiles[fullPath]}`;
          } else {
            log('error', `Unable to load: ${fullPath}.js`);
            this.setWaitCursor(false);
            return;
          }
        }
        processProjectFile(fp);
        return;
      }

      // From here, assume that `project` is a [JClicProject](JClicProject.html)
      this.setProject(project);

      // If none specified, start with the first element of the sequence
      if (!sequence && !activity)
        sequence = '0';

      // start reporter session
      if (this.reporter)
        this.reporter.newSession(project);

    }

    // Step two: load the ActivitySequenceElement
    if (!isNullOrUndef(sequence)) {
      log('info', `Loading sequence: ${sequence}`);
      this.navButtonsDisabled = false;
      // Try to load sequence by tag
      let ase = null;
      if (typeof sequence === 'string')
        ase = this.project.activitySequence.getElementByTag(sequence, true);
      if (ase === null) {
        // Try to treat 'sequence' as a number
        const n = parseInt(sequence, 10);
        if (typeof n === 'number')
          ase = this.project.activitySequence.getElement(n, true);
      }

      if (ase !== null) {
        // Success! We have a real [ActivitySequenceElement](ActivitySequenceElement.html)
        if (this.reporter)
          this.reporter.newSequence(ase);
        activity = ase.activity;
      }
    }

    // Step three: load the activity
    if (activity) {
      const act = this.project.getActivity(activity);
      if (act) {
        // Success! We have a real [Activity](Activity.html)
        log('info', `Loading activity: ${activity}`);
        // Clean static references to previous audio elements
        bags_MediaBagElement.resetAudioElements();
        act.prepareMedia(this);
        this.project.activitySequence.checkCurrentActivity(act.name);
        actp = act.getActivityPanel(this);
        actp.buildVisualComponents();
      } else {
        log('error', `Missing activity: ${activity}`);
      }
    }

    // Step four: put the activity panel on place

    // Remove the current ActivityPanel
    if (this.actPanel !== null) {
      this.actPanel.end();
      this.actPanel.$div.remove();
      this.actPanel = null;
      this.setCounterValue('time', 0);
    }

    // Attach the new ActivityPanel
    if (actp) {
      // Sets the actPanel member to this ActivityPanel
      this.actPanel = actp;

      if (this.options.fade > 0)
        this.actPanel.$div.css('display', 'none');

      // Places the JQuery DOM element of actPanel within the player main panel
      this.$div.prepend(this.actPanel.$div);
      if (this.skin)
        this.skin.resetAllCounters(false);

      // Sets the current skin
      if (this.actPanel.skin)
        this.setSkin(this.actPanel.skin);
      else if (this.project.skin) {
        this.setSkin(this.project.skin);
        this.lastProjectSkin = this.project.skin;
      }
      else if (this.lastProjectSkin)
        this.setSkin(this.lastProjectSkin);
      else
        this.setSkin(null);

      if (this.skin) {
        // Enable or disable actions
        const hasReturn = this.history.storedElementsCount() > 0 || this.options.returnAsExit;
        const navBtnFlag = this.navButtonsAlways ?
          'both' : this.navButtonsDisabled ?
            'none' : this.project.activitySequence.getNavButtonsFlag();
        this.actions['next'].setEnabled((navBtnFlag === 'fwd' || navBtnFlag === 'both') &&
          this.project.activitySequence.hasNextAct(hasReturn));
        this.actions['prev'].setEnabled((navBtnFlag === 'back' || navBtnFlag === 'both') &&
          this.project.activitySequence.hasPrevAct(hasReturn));
        this.actions['return'].setEnabled(hasReturn);
        this.actions['help'].setEnabled(this.actPanel.act.helpWindowAllowed());
        this.actions['reset'].setEnabled(this.actPanel.act.canReinit());
        this.actions['info'].setEnabled(this.actPanel.act.hasInfo());
      }
      this.doLayout();
      this.initActivity();

      this.history.pushBrowserHistory();

      this.actPanel.$div.fadeIn(this.options.fade, () => this.activityReady());
    }
    this.setWaitCursor(false);
  }

  /**
   * Forces the current activity to stop playing.
   */
  forceFinishActivity() {
    this.timer.stop();
    this.delayedTimer.stop();
    if (this.actPanel) {
      this.closeHelpWindow();
      this.actPanel.forceFinishActivity();
      this.stopMedia();
      this.activeMediaBag.removeAll();
    }
  }

  /**
   *
   * Removes the current {@link module:Activity.ActivityPanel ActivityPanel} from this player
   */
  removeActivity() {
    this.forceFinishActivity();
    if (this.actPanel) {
      this.actPanel.end();
      this.actPanel.$div.remove();
      this.actPanel = null;
      this.setMsg(null);
      this.doLayout();
    }
  }

  /**
   *
   * Initializes the activity
   */
  initActivity() {
    this.setWaitCursor(true);
    this.timer.stop();
    this.delayedTimer.stop();
    this.setCounterValue('time', 0);
    this.stopMedia();
    if (this.actPanel) {
      this.actPanel.initActivity();
      this.timer.start();
      if (!this.actPanel.act.mustPauseSequence())
        this.startAutoPassTimer();
      log('info', `Activity "${this.actPanel.act.name}" running`);
    }
    this.setWaitCursor(false);
  }

  /**
   * Called by {@link module:JClicPlayer.JClicPlayer#load} when the {@link module:Activity.ActivityPanel ActivityPanel} is fully visible, just
   * after the JQuery animation effect.
   */
  activityReady() {
    if (this.actPanel) {
      this.actPanel.activityReady();
      log('info', 'Activity ready');
    }
  }

  /**
   * Starts the activity. This method is usually called from text activities with previous text.
   */
  startActivity() {
    this.setWaitCursor(true);
    if (this.actPanel)
      this.actPanel.startActivity();
    this.setWaitCursor(false);
  }

  /**
   * Configures the layout and visual aspect of the player area.
   */
  doLayout() {

    // Main player area settings
    const
      width = this.dim.width = this.$div.width(),
      height = this.dim.height = this.$div.height(),
      mainCss = {
        'background-color': this.actPanel ? this.actPanel.act.bgColor : 'azure',
        'background-image': ''
      };

    if (this.actPanel) {
      const act = this.actPanel.act;
      if (act.bgGradient)
        // Canvas version also available
        mainCss['background-image'] = act.bgGradient.getCss();

      if (act.bgImageFile && act.bgImageFile.length > 0) {
        this.project.mediaBag.getElement(act.bgImageFile, true).getFullPathPromise().then(bgImageUrl => {
          this.$div.css({
            'background-image': 'url(\'' + bgImageUrl + '\')',
            'background-repeat': act.tiledBgImg ? 'repeat' : 'no-repeat',
            'background-position': act.tiledBgImg ? '' : 'center center'
          });
        });
      }

      // Activity panel settings
      // Calc the maximum rectangle available for the activity panel
      const
        m = settings.BoxBase.AC_MARGIN,
        proposedRect = new Rectangle(m, m, width - 2 * m, height - 2 * m);

      if (this.actPanel.bgImage && !act.tiledBgImg && act.absolutePositioned) {
        // Special case: when the activity has a background image not tiled, and an absolute
        // position has been specified, the ActivityPanel must be placed at this absolute
        // position, relative to the background image
        this.bgImageOrigin.x = (width - this.actPanel.bgImage.width) / 2;
        this.bgImageOrigin.y = (height - this.actPanel.bgImage.height) / 2;
        proposedRect.pos.moveTo(this.bgImageOrigin);
        proposedRect.dim.width -= this.bgImageOrigin.x - m;
        proposedRect.dim.height -= this.bgImageOrigin.y - m;
        proposedRect.dim.width = Math.min(proposedRect.dim.width, width);
        proposedRect.dim.height = Math.min(proposedRect.dim.height, height);
      }

      // ActivityPanel will calculate and set its position and size based on the maximum and optimal
      // available space
      /* TODO: Try with a computed rectangle instead of "this", to avoid the loss of the right margin
       * in narrow displays */
      this.actPanel.fitTo(proposedRect, this);
    }
    this.$div.css(mainCss);
  }

  /**
   * Plays the specified media.
   * @param {module:media/MediaContent.MediaContent} mediaContent - The media to be played
   * @param {module:boxes/ActiveBox.ActiveBox} [mediaPlacement] - The cell where the graphic component of this media should be placed (used with video objects)
   * @param {function[]} [delayedActions] - If set, store the the action in this array for future execution
   */
  playMedia(mediaContent, mediaPlacement = null, delayedActions = null) {

    let ji = null;
    const fn = mediaContent.file;
    let action = null;

    switch (mediaContent.type) {
      case 'PLAY_AUDIO':
      case 'PLAY_VIDEO':
      case 'PLAY_MIDI':
      case 'RECORD_AUDIO':
      case 'PLAY_RECORDED_AUDIO':
        if (this.audioEnabled) {
          const amp = this.activeMediaBag.getActiveMediaPlayer(mediaContent, this.project.mediaBag, this);
          if (amp)
            action = () => amp.play(mediaPlacement);
        }
        break;

      case 'RUN_CLIC_PACKAGE':
        ji = new bags_JumpInfo('JUMP', fn);
        if (mediaContent.externalParam) {
          // Relative path computed in History.processJump
          ji.projectPath = mediaContent.externalParam;
        }
        action = () => this.history.processJump(ji, true);
        break;

      case 'RUN_CLIC_ACTIVITY':
        this.history.push();
        action = () => this.load(null, null, fn);
        break;

      case 'RETURN':
        if (this.history.storedElementsCount() > 0 || !this.options.returnAsExit) {
          action = () => this.history.pop();
          break;
        }
      case 'EXIT':
        ji = new bags_JumpInfo('EXIT', fn);
        action = () => this.history.processJump(ji, false);
        break;

      case 'RUN_EXTERNAL':
        action = () => this.runCmd(fn);
        break;

      case 'URL':
        if (fn)
          // When mediaContent.level is 2 or more, the URL will be opened in a separate window.
          action = () => this.displayURL(fn, mediaContent.level > 1);
        break;

      default:
        log('error', `Unknown media type: ${mediaContent.type}`);
        break;
    }

    // Execute the action or pass callback
    if (delayedActions && action)
      delayedActions.push(action);
    else if (action)
      action();
  }

  /**
   * Stops currently playing media
   * @param {number} [level=-1] - Sets the threshold above which all media objects with equal
   * or greater `level` will also also be muted.
   */
  stopMedia(level) {
    if (typeof level !== 'number')
      level = -1;
    this.activeMediaBag.stopAll(level);
  }

  /**
   * Launches the specified system command.
   * Currently not implemented.
   * @param {string} cmd
   */
  runCmd(cmd) {
    log('warn', `Unsupported call to external command: "${cmd}"`);
  }

  /**
   * Called from {@link module:Activity.Activity Activity} when finished.
   * @param {boolean} _completedOK - `true` when the activity was successfully completed, `false`
   * otherwise.
   */
  activityFinished(_completedOK) {
    this.closeHelpWindow();
    log('info', 'Activity finished');
    this.timer.stop();
    this.startAutoPassTimer();
  }

  /**
   * Starts the automatic jump to next activity, when applicable.
   */
  startAutoPassTimer() {
    const ase = this.project.activitySequence.getCurrentAct();
    if (ase !== null && ase.delay > 0 && !this.delayedTimer.isRunning() && !this.navButtonsDisabled) {
      this.delayedAction = this.actions['next'];
      this.delayedTimer.interval = ase.delay * 1000;
      this.delayedTimer.start();
    }
  }

  /**
   *
   * Sets the current main message.
   * @param {module:boxes/ActiveBoxContent.ActiveBoxContent} abc - The content of the message
   */
  setMsg(abc) {
    const ab = this.skin ? this.skin.getMsgBox() : null;
    if (ab) {
      ab.clear();
      this.skin.invalidate(ab).update();
      ab.setContent(abc ? abc : boxes_ActiveBoxContent.EMPTY_CONTENT);
      // TODO: Move this method to Skin
      this.skin.invalidate(ab).update();
      ab.playMedia(this);
    }
  }

  /**
   * Launches the active media content associated to the main message, if any.
   */
  playMsg() {
    if (this.skin && this.skin.getMsgBox())
      this.skin.getMsgBox().playMedia(this);
  }

  /**
   * Sets a value to the specified counter
   * @param {string} counter - The id of the counter ('score', 'actions' or 'time')
   * @param {number} newValue - The value to be set
   */
  setCounterValue(counter, newValue) {
    this.counterVal[counter] = newValue;
    if (this.skin && this.skin.counters[counter])
      this.skin.counters[counter].setValue(newValue);
  }

  /**
   * Gets the current value for the specified counter
   * @param {string} counter - The id of the counter ('score', 'actions' or 'time')
   * @returns {number}
   */
  getCounterValue(counter) {
    return this.counterVal[counter];
  }

  /**
   * Enables or disables a specific counter
   * @param {string} counter - The id of the counter ('score', 'actions' or 'time')
   * @param {boolean} bEnabled - When `true`, the counter will be enabled.
   */
  setCounterEnabled(counter, bEnabled) {
    if (this.skin) {
      this.skin.enableCounter(counter, bEnabled);
      this.setCountDown(counter, 0);
    }
  }

  /**
   * Increments by 1 the value of the specified counter
   * @param {string} counter - The id of the counter ('score', 'actions' or 'time')
   */
  incCounterValue(counter) {
    this.counterVal[counter]++;

    const
      actp = this.actPanel,
      cnt = this.skin ? this.skin.counters[counter] : null;

    if (cnt)
      cnt.setValue(this.counterVal[counter]);
    if (counter === 'actions' && actp !== null && actp.act.maxActions > 0 && actp.playing && this.counterVal['actions'] >= actp.act.maxActions)
      window.setTimeout(() => { actp.finishActivity(actp.solved); }, 0);
  }

  /**
   * Sets the specified counter in count-down status, starting at `maxValue`.
   * @param {string} counter - The id of the counter ('score', 'actions' or 'time')
   * @param {number} maxValue - The value from which to start counting down
   */
  setCountDown(counter, maxValue) {
    //this.counterVal[counter] = maxValue
    if (this.skin && this.skin.counters[counter])
      this.skin.counters[counter].setCountDown(maxValue);
  }

  /**
   * Set/unset the panel in 'wait' state
   * @param {boolean} status
   */
  setWaitCursor(status) {
    if (this.skin)
      this.skin.setWaitCursor(status);
  }

  /**
   * Sets the current value of the progress bar
   * @param {number} val - The current value. Should be less or equal than `max`. When -1, the progress bar will be hidden.
   * @param {number} [max] - Optional parameter representing the maximum value. When passed, the progress bar will be displayed.
   */
  setProgress(val, max) {
    if (this.skin)
      this.skin.setProgress(val, max);
  }

  /**
   * Increments the progress bar value by the specified amount, only when the progress bar is running.
   * @param {number} [val=1] - The amount to increment. When not defined, it's 1.
   */
  incProgress(val = 1) {
    if (this.skin)
      this.skin.incProgress(val);
  }

  /**
   * Builds an {@link module:media/ActiveMediaPlayer.ActiveMediaPlayer ActiveMediaPlayer} for the specified {@link module:media/MediaContent.MediaContent}
   * @param {module:media/MediaContent.MediaContent} mediaContent - The media content to be played
   * @returns {module:media/ActiveMediaPlayer.ActiveMediaPlayer}
   */
  getActiveMediaPlayer(mediaContent) {
    return this.activeMediaBag && mediaContent ? this.activeMediaBag.getActiveMediaPlayer(mediaContent, this.project.mediaBag, this) : null;
  }

  /**
   * Notifies the reporting system that a new activity has started
   * @param {module:Activity.Activity} act - The activity that is sending the notification
   */
  reportNewActivity(act) {
    const ase = this.project.activitySequence.getCurrentAct();
    if (this.reporter) {
      if (ase.tag === this.reporter.getCurrentSequenceTag())
        // Notify that the sequence has changed
        this.reporter.newSequence(ase);
      if (act.includeInReports)
        this.reporter.newActivity(act);
    }
    this.setCounterValue('actions', 0);
    this.setCounterValue('score', 0);
  }

  /**
   * Notifies the reporting system that a new action has been performed on the current activity
   * @param {module:Activity.Activity} act - The activity that is sending the notification
   * @param {string} type - Type of action (match, move, switch...)
   * @param {string} source - Object acting as a source of the action (cell, grid, clue...)
   * @param {string} dest - When applicable, object acting as a receiver of the action (cell, grid...)
   * @param {boolean} ok - Whether the action was OK or not
   * @param {number} currentScore - The current score of the activity
   */
  reportNewAction(act, type, source, dest, ok, currentScore) {
    if (this.reporter && act.includeInReports && act.reportActions)
      this.reporter.newAction(type, source, dest, ok);
    if (currentScore >= 0) {
      this.incCounterValue('actions');
      this.setCounterValue('score', currentScore);
    }
  }

  /**
   * Notifies the reporting system that the current activity has finished
   * @param {module:Activity.Activity} act - The activity that is sending the notification
   * @param {boolean} solved - Whether the activity was successfully completed or not.
   */
  reportEndActivity(act, solved) {
    if (this.reporter && act.includeInReports)
      this.reporter.endActivity(this.counterVal['score'], this.counterVal['actions'], solved);
  }

  /**
   * Shows the help info provided by the activity
   * @param {external:jQuery} $hlpComponent - The jQuery DOM component to be shown.
   * @returns {boolean} - True when the component was successfully displayed
   */
  showHelp($hlpComponent) {
    return this.skin ? this.skin.showHelp($hlpComponent) : false;
  }

  /**
   * Navigates to the requested URL
   * @param {string} url - The URL to navigate to
   * @param {boolean} inFrame - When `true` opens in a new frame
   */
  displayURL(url, inFrame) {
    if (url) {
      if (inFrame)
        window.open(url, this.options.infoUrlFrame);
      else {
        this.end().then(() => { window.location.href = url; });
      }
    }
  }

  /**
   * Only when `exitUrl` has been specified in `options`, navigates to the specified URL
   * @param {string} url - The URL to navigate to.
   */
  exit(url) {
    this.displayURL(url || this.options.exitUrl, false);
  }

  /**
   * Sets a title in a specific HTML element, if provided.
   * @param {string} docTitle
   */
  setWindowTitle(docTitle) {
    log('info', `running ${docTitle}`);
  }
}

Object.assign(JClicPlayer.prototype, {
  /**
   * Object with miscellaneous options.
   * @name module:JClicPlayer.JClicPlayer#options
   * @type {object} */
  options: {
    //
    // Max waiting time to have all media loaded (milliseconds)
    maxWaitTime: 120000,
    //
    // Name of the frame where to open links
    infoUrlFrame: '_blank',
    //
    // URL where to navigate to on exit
    exitUrl: null,
    //
    // When `true` and no elements on sequence stack, RETURN acts as EXIT
    returnAsExit: false,
    //
    // At the beginning, the audio should be enabled or disabled
    audioEnabled: true,
    //
    // Navigation buttons are always visible (for debugging purposes)
    navButtonsAlways: false,
    //
    // Time (milliseconds) of the fade-in animation of the activity panel. When 0, no animation
    // is performed
    fade: 300,
    // Minimum horizontal swipe length to be considered an activity change gesture
    minSwipeX: 40,
    // Maximum vertical swipe length to be considered an activity change gesture
    maxSwipeY: 100,
    // Read swipe gestures as in right-to-left languages (default is left-to-right)
    rightToLeft: false,
  },
  /**
   * Unique ID of this player, randomly generated by the constructor
   * @name module:JClicPlayer.JClicPlayer#id
   * @type {string} */
  id: 'JC0000',
  /**
   * The JQuery "div" element used by this player as stage for activities
   * @name module:JClicPlayer.JClicPlayer#$div
   * @type {external:jQuery} */
  $div: null,
  /**
   * The JQuery top container where this player will deploy
   * @name module:JClicPlayer.JClicPlayer#$topDiv
   * @type {external:jQuery} */
  $topDiv: null,
  /**
   * The main container of all JClic components
   * @name module:JClicPlayer.JClicPlayer#$mainContainer
   * @type {external:jQuery} */
  $mainContainer: null,
  /**
   * Flag indicatig that this player has switched to full screen at least once
   * @name module:JClicPlayer.JClicPlayer#fullScreenChecked
   * @type {boolean} */
  fullScreenChecked: false,
  /**
   * The {@link module:project/JClicProject.JClicProject JClicProject} currently hosted in this player
   * @name module:JClicPlayer.JClicPlayer#project
   * @type {module:project/JClicProject.JClicProject} */
  project: null,
  /**
   * Relative path or absolute URL to be used as a base to access files
   * @name module:JClicPlayer.JClicPlayer#basePath
   * @type {string} */
  basePath: '',
  /**
   * A {@link external:JSZip} object pointing to a `jclic.zip` or `jclic.scorm.zip` file containing
   * the current project.
   * Two extra properties will be added to this object when loaded:
   * - __zip.fullZipPath__ {string} - The full path of the ZIP file
   * - __zip.zipBasePath__ {string} - The path to the folder containing the ZIP file
   * @name module:JClicPlayer.JClicPlayer#zip
   * @type {external:JSZip} */
  zip: null,
  /**
   * This flag indicates if the player is running inside a document loaded by `file:` protocol
   * @name module:JClicPlayer.JClicPlayer#localFS
   * @type {boolean}
   */
  localFS: false,
  /**
   * The {@link module:Activity.ActivityPanel ActivityPanel} currently running on this player.
   * @name module:JClicPlayer.JClicPlayer#actPanel
   * @type {module:Activity.Activity#Panel} */
  actPanel: null,
  /**
   * This object records the list of the activities played during the current session.
   * @name module:JClicPlayer.JClicPlayer#history
   * @type {module:PlayerHistory.PlayerHistory} */
  history: null,
  /**
   * The Skin currently used by this player.
   * @name module:JClicPlayer.JClicPlayer#skin
   * @type {module:skins/Skin.Skin} */
  skin: null,
  /**
   * The default Skin to be used if none specified
   * @name module:JClicPlayer.JClicPlayer#defaultSkin
   * @type {module:skins/Skin.Skin} */
  defaultSkin: null,
  /**
   * The last skin directly specified by a {@link module:project/JClicProject.JClicProject JClicProject}
   * @name module:JClicPlayer.JClicPlayer#defaultSkin
   * @type {module:skins/Skin.Skin} */
  lastProjectSkin: null,
  /**
   * Object containing references to realized media objects, ready to play.
   * @name module:JClicPlayer.JClicPlayer#activeMediaBag
   * @type {module:media/ActiveMediaBag.ActiveMediaBag} */
  activeMediaBag: null,
  /**
   * Object responsible for passing the scores obtained by users to a external reporting systems
   * when playing activities.
   * @name module:JClicPlayer.JClicPlayer#reporter
   * @type {module:report/Reporter.Reporter} */
  reporter: null,
  /**
   * Collection of {@link module:AWT.Action} objects used by this player.
   * @name module:JClicPlayer.JClicPlayer#actions
   * @type {module:AWT.Action[]} */
  actions: {},
  /**
   * Main timer object used to feed the time counter. Ticks every second.
   * @name module:JClicPlayer.JClicPlayer#timer
   * @type {module:AWT.Timer} */
  timer: null,
  /**
   * Timer for delayed actions
   * @name module:JClicPlayer.JClicPlayer#delayedTimer
   * @type {module:AWT.Timer} */
  delayedTimer: null,
  /**
   * This variable holds the action to be executed by `delayedTimer`
   * @name module:JClicPlayer.JClicPlayer#delayedAction
   * @type {module:AWT.Action} */
  delayedAction: null,
  /**
   * @typedef JClicPlayer~counterValType
   * @type {object}
   * @property {number} score
   * @property {number} actions
   * @property {number} time */
  /**
   * Current values of the counters
   * @name module:JClicPlayer.JClicPlayer#counterVal
   * @type {module:JClicPlayer.JClicPlayer~counterValType} */
  counterVal: { score: 0, actions: 0, time: 0 },
  /**
   * Point indicating the upper-left corner of the current background image
   * @name module:JClicPlayer.JClicPlayer#bgImageOrigin
   * @type {module:AWT.Point} */
  bgImageOrigin: null,
  /**
   * Whether the player must play all sounds (including system sounds) and other media content
   * of the activities.
   * @name module:JClicPlayer.JClicPlayer#audioEnabled
   * @type {boolean} */
  audioEnabled: true,
  /**
   * Whether the navigation buttons `next` and `back` are enabled o disabled.
   * @name module:JClicPlayer.JClicPlayer#navButtonsDisabled
   * @type {boolean} */
  navButtonsDisabled: false,
  /**
   * When this flag is `true`, the navigation buttons are always enabled despite
   * of the indications made by the activities or the sequence control system.
   * This is used only to debug projects with complicated sequence chaining.
   * @name module:JClicPlayer.JClicPlayer#navButtonsAlways
   * @type {boolean} */
  navButtonsAlways: false,
});

/* harmony default export */ const src_JClicPlayer = (JClicPlayer);

;// CONCATENATED MODULE: ./src/boxes/AbstractBox.js
/**
 *  File    : boxes/AbstractBox.js
 *  Created : 18/04/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */




/**
 * This abstract class is the base for most graphic components of JClic. It describes an area
 * (by default an {@link module:AWT.Rectangle}) with some special properties that determine how it must
 * be drawn on screen.
 *
 * Some types of boxes can act as containers for other boxes, establishing a hierarchy of dependences.
 * @abstract
 * @extends module:AWT.Rectangle
 */
class AbstractBox extends Rectangle {
  /**
   * AbstractBox constructor
   * @param {module:AbstractBox} parent - The AbstractBox to which this one belongs
   * @param {module:AWT.Container} container - The container where this box is placed.
   * @param {module:BoxBase} boxBase - The object where colors, fonts, border and other graphic properties
   * of this box are defined.
   */
  constructor(parent, container, boxBase) {
    // AbstractBox extends AWT.Rectangle
    super();
    this.container = container;
    this.parent = parent;
    this.boxBase = boxBase;
    this.shape = this;
    this.specialShape = false;
    this.visible = true;
  }

  /**
   * Setter method for `parent`
   * @param {module:boxes/AbstractBox.AbstractBox} parent - The new parent of this box
   */
  setParent(parent) {
    this.parent = parent;
  }

  /**
   * Gets the current parent of this box
   * @returns {module:boxes/AbstractBox.AbstractBox}
   */
  getParent() {
    return this.parent;
  }

  /**
   * Finisher method
   */
  end() {
  }

  /**
   * Setter method for `container`
   * @param {module:AWT.Container} newContainer - The new Container assigned to this box
   */
  setContainer(newContainer) {
    this.container = newContainer;
    if (this.$hostedComponent && this.container && this.container.$div) {
      this.$hostedComponent.detach();
      this.container.$div.append(this.$hostedComponent);
    }
  }

  /**
   * Gets the `container` attribute of this box, without checking its parent
   * @returns {module:AWT.Container}
   */
  getContainerX() {
    return this.container;
  }

  /**
   * Gets the container associated to this box, asking its parents when `null`.
   * @returns {module:AWT.Container}
   */
  getContainerResolve() {
    let ab = this;
    while (ab.container === null && ab.parent !== null)
      ab = ab.parent;
    return ab.container;
  }

  /**
   * Invalidates the zone corresponding to this box in the associated {@link module:AWT.Container}, if any.
   * @param {module:AWT.Rectangle} rect - The rectangle to be invalidated. When `null`, it's the full
   * container area.
   */
  invalidate(rect) {
    const cnt = this.getContainerResolve();
    if (cnt)
      cnt.invalidate(rect);
  }

  /**
   * Sets the {@link module:boxes/BoxBase.BoxBase BoxBase} of this box
   * @param {module:boxes/BoxBase.BoxBase} boxBase - The new BoxBase
   */
  setBoxBase(boxBase) {
    this.boxBase = boxBase;
    this.invalidate();
  }

  /**
   * Gets the real {@link module:boxes/BoxBase.BoxBase BoxBase} associated to this box, scanning down parent relationships.
   * @returns {module:boxes/BoxBase.BoxBase}
   */
  getBoxBaseResolve() {
    let ab = this;
    while (!ab.boxBase && ab.parent)
      ab = ab.parent;
    return ab.boxBase || boxes_BoxBase.DEFAULT_BOX_BASE;
  }

  /**
   * Sets the shape used to draw the content of this box
   * @param {module:AWT.Shape} sh - The shape to be set
   */
  setShape(sh) {
    this.shape = sh;
    this.specialShape = true;
    this.invalidate();
    super.setBounds(sh.getBounds());
    this.invalidate();
  }

  /**
   * Gets the current shape used in this box
   * @returns {module:AWT.Shape}
   */
  getShape() {
    return this.shape;
  }

  /**
   * Check if this box contains the specified point
   * @override
   * @param {module:AWT.Point} p - The point to be checked
   * @returns {boolean}
   */
  contains(p) {
    return this.shape === this ? super.contains(p) : this.shape.contains(p);
  }

  /**
   * Sets a new size and/or dimension to this box
   * @override
   * @param {AWT.Rectangle|number} rect - An AWT.Rectangle object, or the `x` coordinate of the
   * upper-left corner of a new rectangle.
   * @param {number} [y] - `y` coordinate of the upper-left corner of the new rectangle.
   * @param {number} [w] - Width of the new rectangle.
   * @param {number} [h] - Height of the new rectangle.
   */
  setBounds(rect, y, w, h) {
    if (typeof rect === 'number')
      // arguments are co-ordinates and size
      rect = new Rectangle(rect, y, w, h);
    // Rectangle comparision
    if (this.equals(rect))
      return;

    const sizeChanged = !this.dim.equals(rect.dim);
    if (this.specialShape) {
      if (sizeChanged) {
        this.shape.scaleBy(new Dimension(rect.dim.width / this.dim.width, rect.dim.height / this.dim.height));
        this.setShape(this.shape);
      }
      if (!this.pos.equals(rect.pos)) {
        this.shape.moveTo(rect.pos);
      }
      this.setShape(this.shape);
    } else
      super.setBounds(rect);

    if (this.$hostedComponent)
      this.setHostedComponentBounds(sizeChanged);

    return this;
  }

  /**
   * Sets a new location for this box. In JClic this method was named `setLocation`
   * @param {AWT.Point|number} newPos - A point or the `x` coordinate of a new point.
   * @param {number} [y] - The `y` coordinate of a new point.
   */
  moveTo(newPos, y) {
    if (typeof newPos === 'number')
      newPos = new Point(newPos, y);
    this.setBounds((new Rectangle(this)).moveTo(newPos));
  }

  /**
   * Sets a new location to this box. In JClic this method was named `translate`.
   * @param {number} dx - The displacement on the X axis
   * @param {number} dy - The displacement on the Y axis
   */
  moveBy(dx, dy) {
    this.setBounds((new Rectangle(this)).moveBy(dx, dy));
  }

  /**
   * Changes the size of this box
   * @param {number} width
   * @param {number} height
   */
  setSize(width, height) {
    this.setBounds(new Rectangle(this.pos, new Dimension(width, height)));
  }

  /**
   * Checks if this box has border
   * @returns {boolean}
   */
  hasBorder() {
    return this.border;
  }

  /**
   * Sets/unsets a border to this box
   * @param {boolean} newVal - `true` to set a border.
   */
  setBorder(newVal) {
    if (!newVal)
      this.invalidate();
    this.border = newVal;
    if (newVal)
      this.invalidate();
  }

  /**
   * Checks if this box is fully visible
   * @returns {boolean}
   */
  isVisible() {
    return this.visible;
  }

  /**
   * Sets this box visible or invisible
   * @param {boolean} newVal - `true` for visible
   */
  setVisible(newVal) {
    this.visible = newVal;
    this.setHostedComponentVisible();
    this.invalidate();
  }

  /**
   * Makes {@link module:boxes/AbstractBox.AbstractBox#$hostedComponent} visible or invisible, based on the value of
   * the AbstractBox `visible` flag.
   */
  setHostedComponentVisible() {
    if (this.$hostedComponent)
      this.$hostedComponent.css('visibility', this.visible ? 'visible' : 'hidden');
  }

  /**
   * Checks if this box is temporary hidden
   * @returns {boolean}
   */
  isTemporaryHidden() {
    return this.temporaryHidden;
  }

  /**
   * Makes this box temporary hidden (newVal `true`) or resets its original state (newVal `false`)
   * @param {boolean} newVal
   */
  setTemporaryHidden(newVal) {
    this.temporaryHidden = newVal;
  }

  /**
   * Checks if this box is currently inactive.
   * @returns {boolean}
   */
  isInactive() {
    return this.inactive;
  }

  /**
   * Makes this box active (`false`) or inactive (`true`)
   * @param {boolean} newVal
   */
  setInactive(newVal) {
    this.inactive = newVal;
    if (this.$hostedComponent) {
      this.setHostedComponentColors();
      this.setHostedComponentVisible();
    } else {
      if (this.$accessibleElement) {
        const disabled = this.isInactive() && !this.accessibleAlwaysActive;
        this.$accessibleElement.prop({
          disabled: disabled,
          tabindex: disabled ? -1 : 0
        });
      }
      this.invalidate();
    }
  }

  /**
   * Checks if this box is in `inverted` state.
   * @returns {boolean}
   */
  isInverted() {
    return this.inverted;
  }


  /**
   * Puts this box in `inverted` mode or restores its original state.
   * @param {boolean} newVal
   */
  setInverted(newVal) {
    this.inverted = newVal;
    if (this.$hostedComponent)
      this.setHostedComponentColors();
    else
      this.invalidate();
  }

  /**
   * Checks if this box is `marked`
   * @returns {boolean}
   */
  isMarked() {
    return this.marked;
  }

  /**
   * Sets this box in `marked` mode, or restores its original state.
   * @param {boolean} newVal
   */
  setMarked(newVal) {
    if (!newVal)
      this.invalidate();
    this.marked = newVal;
    if (this.$hostedComponent) {
      this.setHostedComponentColors();
      this.setHostedComponentBorder();
    } else if (newVal)
      this.invalidate();
  }

  /**
   * Checks if this box has the input focus
   * @returns {boolean}
   */
  isFocused() {
    return this.focused;
  }

  /**
   *
   * Sets or unsets the input focus to this box.
   * @param {boolean} newVal
   */
  setFocused(newVal) {
    if (!newVal)
      this.invalidate();
    this.focused = newVal;
    if (newVal)
      this.invalidate();
    // Put hosted component on top
    if (this.$hostedComponent)
      this.$hostedComponent.css('z-index', this.focused ? 20 : 2);
  }

  /**
   * Checks if this box is in `alternative` state.
   * @returns {boolean}
   */
  isAlternative() {
    return this.alternative;
  }

  /**
   * Sets this box in `alternative` mode, or restores its original state.
   * @param {boolean} newVal
   */
  setAlternative(newVal) {
    this.alternative = newVal;
    this.invalidate();
  }

  /**
   * Draws the content of this box on an HTML `canvas` element. At this level, only background
   * and border are painted/stroked. Derived classes should implement specific drawing tasks in
   * {@link module:boxes/AbstractBox.AbstractBox#updateContent}.
   * @param {external:CanvasRenderingContext2D} ctx - The canvas rendering context used to draw the
   * box content.
   * @param {module:AWT.Rectangle} [dirtyRegion=null] - The area that must be repainted. `null` refers to the whole box.
   */
  update(ctx, dirtyRegion = null) {
    if (this.isEmpty() || !this.isVisible() || this.isTemporaryHidden())
      return false;

    if (dirtyRegion && !this.shape.intersects(dirtyRegion))
      return false;

    /**
     * TODO: Implement clipping
     Shape saveClip=new Area(g2.getClip())
     Area clip=new Area(saveClip)
     clip.intersect(new Area(shape))
     g2.setClip(clip)
     */

    const style = this.getBoxBaseResolve();
    if (!style.transparent && !style.dontFill && !this.tmpTrans) {
      if (!style.bgGradient || style.bgGradient.hasTransparency()) {
        // Prepare the rendering context
        ctx.fillStyle = this.inactive ?
          style.inactiveColor :
          this.inverted ? style.textColor : style.backColor;
        // Fill the shape
        this.shape.fill(ctx, dirtyRegion);
      }
      if (style.bgGradient) {
        ctx.fillStyle = style.bgGradient.getGradient(ctx, this.shape.getBounds());
        this.shape.fill(ctx, dirtyRegion);
      }
      // Reset the canvas context
      ctx.fillStyle = 'black';
    }

    if (!this.$hostedComponent)
      this.updateContent(ctx, dirtyRegion);

    this.drawBorder(ctx);
    return true;
  }

  /**
   * Here is where classes derived from {@link module:boxes/AbstractBox.AbstractBox AbstractBox} should implement the drawing of its
   * content. Background and border are already painted in {@link module:boxes/AbstractBox.AbstractBox#update}.
   * @param {external:CanvasRenderingContext2D} _ctx - The canvas rendering context used to draw the
   * box content.
   * @param {module:AWT.Rectangle} [_dirtyRegion] - The area that must be repainted. `null` refers to the whole box.
   */
  //
  // Abstract method, to be implemented in subclasses
  updateContent(_ctx, _dirtyRegion) {
  }

  /**
   * Draws the box border
   * @param {external:CanvasRenderingContext2D} ctx - The canvas rendering context where the border
   * will be drawn.
   */
  drawBorder(ctx) {
    if (this.border || this.marked) {
      const style = this.getBoxBaseResolve();

      // Prepare stroke settings
      ctx.strokeStyle = style.borderColor;
      style[this.marked ? 'markerStroke' : 'borderStroke'].setStroke(ctx);
      if (this.marked)
        ctx.globalCompositeOperation = 'xor';

      // Draw border
      this.shape.stroke(ctx);

      // Reset ctx default values
      if (this.marked)
        ctx.globalCompositeOperation = 'source-over';
      ctx.strokeStyle = 'black';
      Stroke.prototype.setStroke(ctx);
    }
  }

  /**
   * Returns the enclosing Rectangle of this box including its border (if any)
   * @returns {module:AWT.Rectangle}
   */
  getBorderBounds() {
    const result = new Rectangle(this.getBounds());
    if (this.border || this.marked) {
      const style = this.getBoxBaseResolve();
      const w = style[this.marked ? 'markerStroke' : 'borderStroke'].lineWidth;
      result.moveBy(-w / 2, -w / 2);
      result.dim.width += w;
      result.dim.height += w;
    }
    return result;
  }

  /**
   * Sets the {@link module:boxes/AbstractBox.AbstractBox#$hostedComponent $hostedComponent} member.
   * @param {external:jQuery} $hc - The jQuery DOM component hosted by this box.
   */
  setHostedComponent($hc) {
    if (this.$hostedComponent)
      this.$hostedComponent.detach();

    this.$hostedComponent = $hc;

    if (this.$hostedComponent) {
      this.setContainer(this.container);
      this.setHostedComponentColors();
      this.setHostedComponentBorder();
      this.setHostedComponentBounds(true);
      this.setHostedComponentVisible();
      this.setFocused(this.focused);
    }
  }

  /**
   * Gets the current {@link module:boxes/AbstractBox.AbstractBox#$hostedComponent|$hostedComponent} member
   * @returns {external:jQuery}
   */
  getHostedComponent() {
    return this.$hostedComponent;
  }

  /**
   * Sets {@link module:boxes/AbstractBox.AbstractBox#$hostedComponent|$hostedComponent} colors and other css properties
   * based on the current {@link module:boxes/BoxBase.BoxBase BoxBase} of this box.
   */
  setHostedComponentColors() {
    if (this.$hostedComponent) {
      const style = this.getBoxBaseResolve();
      const css = style.getCSS(null, this.inactive, this.inverted, this.alternative);
      // Check if cell has background gradient and animated gif
      if (this.$hostedComponent.data('background-image') && css['background-image'])
        css['background-image'] = `${this.$hostedComponent.data('background-image')},${css['background-image']}`;
      this.$hostedComponent.css(css);
    }
  }

  /**
   * Sets the {@link module:boxes/AbstractBox.AbstractBox#$hostedComponent|$hostedComponent} border, based on the current
   * {@link module:boxes/BoxBase.BoxBase BoxBase} of this box.
   */
  setHostedComponentBorder() {
    if (this.$hostedComponent && (this.border || this.marked)) {
      const style = this.getBoxBaseResolve();
      this.$hostedComponent.css({
        'border-width': `${style.get(this.marked ? 'markerStroke' : 'borderStroke').lineWidth}px`,
        'border-style': 'solid',
        'border-color': style.get('borderColor')
      });
    }
  }

  /**
   * Places and resizes {@link module:boxes/AbstractBox.AbstractBox#$hostedComponent|$hostedComponent}, based on the size
   * and position of this box.
   * @param {boolean} _sizeChanged - `true` when this {@link module:boxes/ActiveBox.ActiveBox ActiveBox} has changed its size
   */
  setHostedComponentBounds(_sizeChanged) {
    if (this.$hostedComponent) {
      const
        r = this.getBounds(),
        b = this.border || this.marked ? this.getBoxBaseResolve().get(this.marked ? 'markerStroke' : 'borderStroke').lineWidth : 0;
      this.$hostedComponent.css({
        position: 'absolute',
        width: r.dim.width - 2 * b + 'px',
        height: r.dim.height - 2 * b + 'px',
        top: r.pos.y + 'px',
        left: r.pos.x + 'px'
      });
    }
  }
}

Object.assign(AbstractBox.prototype, {
  /**
   * The parent AbstractBox (can be `null`)
   * @name module:boxes/AbstractBox.AbstractBox#parent
   * @type {module:boxes/AbstractBox.AbstractBox} */
  parent: null,
  /**
   * The Container to which this AbstractBox belongs
   * @name module:boxes/AbstractBox.AbstractBox#container
   * @type {module:AWT.Container} */
  container: null,
  /**
   * The {@link module:boxes/BoxBase.BoxBase BoxBase} related to this AbstractBox. When `null`, the parent can provide an
   * alternative one.
   * @name module:boxes/AbstractBox.AbstractBox#boxBase
   * @type {module:boxes/BoxBase.BoxBase} */
  boxBase: null,
  /**
   * Whether this box has a border or not
   * @name module:boxes/AbstractBox.AbstractBox#border
   * @type {boolean} */
  border: false,
  /**
   * The shape of this box (the box Rectangle or a special Shape, if set)
   * @name module:boxes/AbstractBox.AbstractBox#shape
   * @type {module:AWT.Shape} */
  shape: null,
  /**
   * Whether this box has a shape that is not a rectangle
   * @name module:boxes/AbstractBox.AbstractBox#specialShape
   * @type {boolean} */
  specialShape: false,
  /**
   * Whether this box is visible or not
   * @name module:boxes/AbstractBox.AbstractBox#visible
   * @type {boolean} */
  visible: true,
  /**
   * Used to temporary hide a box while other drawing operations are done
   * @name module:boxes/AbstractBox.AbstractBox#temporaryHidden
   * @type {boolean} */
  temporaryHidden: false,
  /**
   * Cells with this attribute will be transparent but with painted border
   * @name module:boxes/AbstractBox.AbstractBox#tmpTrans
   * @type {boolean}*/
  tmpTrans: false,
  /**
   * Whether this box is active or inactive
   * @name module:boxes/AbstractBox.AbstractBox#inactive
   * @type {boolean} */
  inactive: false,
  /**
   * Whether this box must be displayed with inverted or regular colors
   * @name module:boxes/AbstractBox.AbstractBox#inverted
   * @type {boolean} */
  inverted: false,
  /**
   * Whether this box must be displayed with alternative or regular color and font settings
   * @name module:boxes/AbstractBox.AbstractBox#alternative
   * @type {boolean} */
  alternative: false,
  /**
   * Whether this box is marked (selected) or not
   * @name module:boxes/AbstractBox.AbstractBox#marked
   * @type {boolean} */
  marked: false,
  /**
   * Whether this box holds the input focus
   * @name module:boxes/AbstractBox.AbstractBox#focused
   * @type {boolean} */
  focused: false,
  /**
   * Text to be used in accessible contexts
   * @name module:boxes/AbstractBox.AbstractBox#accessibleText
   * @type {string} */
  accessibleText: '',
  /**
   * Describes the main role of this box on the activity. Useful in wai-aria descriptions.
   * @name module:boxes/AbstractBox.AbstractBox#role
   * @type {string} */
  role: 'cell',
  /**
   * DOM element used to display this cell content in wai-aria contexts
   * @name module:boxes/AbstractBox.AbstractBox#$accessibleElement
   * @type {external:jQuery} */
  $accessibleElement: null,
  /**
   * Flag indicating that $accessibleElement should be always active
   * @name module:boxes/AbstractBox.AbstractBox#accessibleAlwaysActive
   * @type {boolean} */
  accessibleAlwaysActive: false,
  /**
   * An external JQuery DOM element hosted by this box
   * @name module:boxes/AbstractBox.AbstractBox#$hostedComponent
   * @type {external:jQuery} */
  $hostedComponent: null,
});

/* harmony default export */ const boxes_AbstractBox = (AbstractBox);

;// CONCATENATED MODULE: ./src/boxes/ActiveBox.js
/**
 *  File    : boxes/ActiveBox.js
 *  Created : 18/04/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */

/* global document */








/**
 * Objects of this class are widely used in JClic activities: cells in puzzles and associations,
 * messages and other objects are active boxes.
 *
 * The specific content, size and location of `ActiveBox` objects is determined by its
 * {@link module:boxes/ActiveBoxContent.ActiveBoxContent ActiveBoxContent} member. Most ActiveBoxes have only one content, but some of them can
 * have a secondary or "alternative" content stored in the `altContent` field. This content is
 * used only when the `alternative` flag of the ActiveBox is `on`.
 *
 * Active boxes can host video and interactive media content (specified in the `mediaContent`
 * member of the {@link module:boxes/ActiveBoxContent.ActiveBoxContent ActiveBoxContent} through its `hostedMediaPlayer` member.
 * @extends module:boxes/AbstractBox.AbstractBox
 */
class ActiveBox extends boxes_AbstractBox {
  /**
   * ActiveBox constructor
   * @param {module:boxes/AbstractBox.AbstractBox} [parent] - The AbstractBox to which this ActiveBox belongs
   * @param {module:AWT.Container} [container] - The container where this box is placed.
   * @param {module:boxes/BoxBase.BoxBase} [boxBase] - The object where colors, fonts, border and other graphic properties
   * of this box are defined.
   * @param {number} [setIdLoc] - A numeric identifier, used to locate this box in a set of sibling objects.
   * @param {module:AWT.Rectangle} [rect] - The initial bounds of the box.
   */
  constructor(parent, container, boxBase, setIdLoc, rect) {
    // ActiveBox extends AbstractBox
    super(parent, container, boxBase);
    this.clear();
    if (typeof setIdLoc === 'number') {
      this.idLoc = setIdLoc;
      this.idAss = 0;
      this.idOrder = 0;
    }
    if (rect)
      this.setBounds(rect);
  }

  /**
   * Factory constructor that creates a new cell inside a JQuery DOM element.
   * @param {external:jQuery} $dom - The DOM element that will act as a container
   * @param {module:boxes/ActiveBoxContent.ActiveBoxContent} abc - The cell's content. Must not be null and have the `dimension`
   * member initialized.
   * @returns {module:boxes/ActiveBox.ActiveBox}
   */
  static createCell($dom, abc) {
    if (abc && abc.dimension) {
      const
        box = new ActiveBox(),
        $canvas = external_jquery_default()('<canvas width="' + abc.dimension.width + '" height="' + abc.dimension.height + '"/>'),
        rect = new Rectangle(0, 0, abc.dimension.width, abc.dimension.height);
      box.container = new Container();
      box.container.$div = $dom;
      box.setContent(abc);
      box.setBounds(rect);
      $dom.append($canvas);
      // Create accessible, focusable elements only for cells with media content
      // TODO: remove focus mark on blur in cells placed on fillInBlanks activities
      if (abc.mediaContent)
        box.buildAccessibleElement($canvas, $dom);
      box.update($canvas.get(-1).getContext('2d'), rect);
      return box;
    }
  }

  /**
   * Returns the current content used by the box
   * @returns {module:boxes/ActiveBoxContent.ActiveBoxContent}
   */
  getCurrentContent() {
    return this.isAlternative() ? this.altContent : this.content;
  }

  /**
   * Returns the current content, creating an empty one if needed.
   * @returns {module:boxes/ActiveBoxContent.ActiveBoxContent}
   */
  getContent() {
    if (!this.content)
      this.setContent(new boxes_ActiveBoxContent());
    return this.content;
  }

  /**
   * Clears the current content
   */
  clear() {
    this.content = null;
    this.altContent = null;
    this.idOrder = -1;
    this.setInactive(true);
    if (!this.hasHostedComponent)
      this.setHostedComponent(null);
    this.setHostedMediaPlayer(null);
    if (this.$accessibleElement)
      this.$accessibleElement.html('');
    if (this.tmpTrans)
      this.tmpTrans = false;
    this.invalidate();
  }

  /**
   * Checks if two ActiveBox objects have equivalent content
   * @param {module:boxes/ActiveBox.ActiveBox} bx - The ActiveBox to check against this.
   * @param {boolean} [checkCase] - When `true`, the comparing will be case-sensitive.
   * @returns {boolean} - `true` if both cells are equivalent.
   */
  isEquivalent(bx, checkCase) {
    return bx !== null &&
      this.content !== null &&
      this.content.isEquivalent(bx.content, checkCase);
  }

  /**
   * Same functionality as {@link module:boxes/ActiveBox.ActiveBox#isEquivalent isEquivalent}, but comparing the current content.
   * @param {module:boxes/ActiveBox.ActiveBox} bx - The ActiveBox to check against this.
   * @param {boolean} [checkCase] - When `true`, the comparing will be case-sensitive.
   * @returns {boolean}
   */
  isCurrentContentEquivalent(bx, checkCase) {
    return bx !== null &&
      this.getCurrentContent() !== null &&
      this.getCurrentContent().isEquivalent(bx.getCurrentContent(), checkCase);
  }

  /**
   * Swaps the location of two active boxes
   * @param {module:boxes/ActiveBox.ActiveBox} bx - The ActiveBox to swap with this one.
   */
  exchangeLocation(bx) {
    const
      pt = new Point(this.pos),
      idLoc0 = this.idLoc;
    this.moveTo(bx.pos);
    bx.moveTo(pt);
    this.idLoc = bx.idLoc;
    bx.idLoc = idLoc0;
  }

  /**
   * Copy the content of another ActiveBox into this one
   * @param {module:boxes/ActiveBox.ActiveBox} bx - The ActiveBox from which to take the content
   */
  copyContent(bx) {
    this.idOrder = bx.idOrder;
    this.idAss = bx.idAss;
    this.content = bx.content;
    this.altContent = bx.altContent;
    if (this.content) {
      if (this.content.style)
        this.setBoxBase(this.content.style);
      if (this.content.border !== null && bx.hasBorder() !== this.content.border)
        this.setBorder(this.content.border);
    }
    this.setInactive(bx.isInactive());
    this.setInverted(bx.isInverted());
    this.setAlternative(bx.isAlternative());
    this.setHostedComponent(bx.getHostedComponent());
    this.hasHostedComponent = bx.hasHostedComponent;
    this.setHostedMediaPlayer(bx.hostedMediaPlayer);
    if (this.hostedMediaPlayer)
      this.hostedMediaPlayer.setVisualComponentVisible(!this.isInactive() && this.isVisible());
    if (this.$accessibleElement)
      this.$accessibleElement.html(this.toString());
  }

  /**
   *
   * Exhanges the content of this ActiveBox with another one
   * @param {module:boxes/ActiveBox.ActiveBox} bx - The ActiveBox with which to exchange the content.
   */
  exchangeContent(bx) {
    const bx0 = new ActiveBox(this.getParent(), this.getContainerX(), this.boxBase);
    bx0.copyContent(this);
    this.copyContent(bx);
    bx.copyContent(bx0);
  }

  /**
   *
   * Sets the text content of this ActiveBox.
   * @param {string} tx - The text to set.
   */
  setTextContent(tx) {
    // only plain text!
    if (!tx)
      tx = '';
    if (!this.content)
      this.content = new boxes_ActiveBoxContent();
    this.content.text = tx;
    this.content.mediaContent = null;
    this.content.img = null;

    this.setHostedComponent(null);
    this.setInactive(false);
    this.checkHostedComponent();
    this.setHostedMediaPlayer(null);

    if (this.$accessibleElement)
      this.$accessibleElement.html(this.toString());
  }

  /**
   * Sets the default value to `idAss`
   */
  setDefaultIdAss() {
    this.idAss = this.content === null ? -1 : this.content.id;
  }

  /**
   * Checks if this ActiveBox is at its original place.
   * @returns {boolean}
   */
  isAtPlace() {
    return this.idOrder === this.idLoc;
  }

  /**
   * Sets the {@link module:boxes/ActiveBoxContent.ActiveBoxContent ActiveBoxContent} of this ActiveBox
   * @param {ActiveBoxContent|ActiveBagContent} abc - Object containing the content to set.
   * @param {number} i - When `abc` is an {@link module:boxes/ActiveBagContent.ActiveBagContent ActiveBagContent}, this field indicates an
   * index in the content array.
   */
  setContent(abc, i) {
    if (abc instanceof boxes_ActiveBagContent) {
      if (i < 0)
        i = this.idOrder;
      if (i >= abc.getNumCells())
        return;
      if (abc.style !== this.boxBase)
        this.setBoxBase(abc.style);

      // `abc` is now an [ActiveBoxContent](ActiveBoxContent.html)
      abc = abc.getActiveBoxContent(i);
    }
    this.setHostedComponent(null);
    this.setHostedMediaPlayer(null);
    this.content = abc;
    if (abc) {
      if (abc.animatedGifFile && !this.specialShape) {
        const url = `url(${abc.animatedGifFile})`;
        const $hc = external_jquery_default()('<span/>').css({
          'background-image': url,
          'background-position': 'center',
          'background-repeat': 'no-repeat'
        });
        // Save background image for later use
        $hc.data('background-image', url);

        if (abc.imgClip !== null) {
          $hc.css({
            'background-origin': 'border-box',
            'background-position': `${-abc.imgClip.pos.x}px ${-abc.imgClip.pos.y}px`
            // TODO: Use background-size only when the original image must be compressed
            //,'background-size': abc.imgClip.dim.width + 'px ' + abc.imgClip.dim.height + 'px'
          });
        }
        this.setHostedComponent($hc);
      }

      if (abc.style !== this.boxBase)
        this.setBoxBase(abc.style);

      if (abc.innerHtmlText)
        this.setHostedComponent(external_jquery_default()('<div/>').html(abc.innerHtmlText));

      if (abc.hasOwnProperty('border') && this.hasBorder() !== abc.border)
        this.setBorder(abc.border);
      this.setInactive(false);
      if (abc.amp)
        this.setHostedMediaPlayer(abc.amp);
      this.checkHostedComponent();
      this.checkAutoStartMedia();
    } else
      this.clear();

    this.invalidate();
    if (this.$accessibleElement)
      this.$accessibleElement.html(this.toString());
  }

  /**
   * Sets the {@link module:boxes/ActiveBoxContent.ActiveBoxContent ActiveBoxContent} that will act as an alternative content (`altContent` field)
   * of this ActiveBox,
   * @param {ActiveBoxContent|ActiveBagContent} abc - Object containing the content to set.
   * @param {number} i - When `abc` is an {@link module:boxes/ActiveBagContent.ActiveBagContent ActiveBagContent}, this field indicates an
   * index in the content array.
   */
  setAltContent(abc, i) {
    if (abc instanceof boxes_ActiveBagContent) {
      if (i < 0)
        i = this.idOrder;
      // `abc` is now an [ActiveBoxContent](ActiveBoxContent.html)
      abc = abc.getActiveBoxContent(i);
    }
    this.altContent = abc;
    this.checkHostedComponent();
    if (this.isAlternative() && this.hostedMediaPlayer)
      this.setHostedMediaPlayer(null);

    if (this.$accessibleElement) {
      this.$accessibleElement.html(this.toString());
      this.$accessibleElement.prop('disabled', true);
    }
  }

  /**
   * Sets the current content of this ActiveBox
   * @param {module:boxes/ActiveBoxContent.ActiveBoxContent} abc - The content to set.
   */
  setCurrentContent(abc) {
    if (this.isAlternative())
      this.setAltContent(abc);
    else
      this.setContent(abc);
    this.invalidate();
  }

  /**
   * Puts this ActiveBox in "alternative" mode, meaning that `altContent` will be used instead of `content`
   */
  switchToAlt() {
    if (this.isAlternative() || !this.altContent || this.altContent.isEmpty())
      return false;
    this.setHostedComponent(null);
    this.setHostedMediaPlayer(null);
    this.setAlternative(true);
    this.tmpTrans = false;
    this.checkHostedComponent();
    this.checkAutoStartMedia();

    if (this.$accessibleElement)
      this.$accessibleElement.html(this.toString());

    return true;
  }

  /**
   * Checks the presence of content susceptible to be treated as HTML DOM embedded in this ActiveBox.
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Drawing_DOM_objects_into_a_canvas}
   */
  checkHostedComponent() {
    if (this.hasHostedComponent)
      return;
    const
      abc = this.getCurrentContent(),
      style = this.getBoxBaseResolve();
    if (!this.isInactive() && abc && abc.innerHtmlText)
      style.getCSS()['text-align'] = abc.txtAlign.h.replace('middle', 'center');
  }

  /**
   * Checks if the call has a {@link module:media/MediaContent.MediaContent} set to `autostart`, and launches it when found.
   */
  checkAutoStartMedia() {
    const cnt = this.getContent();
    if (cnt && cnt.mediaContent && cnt.mediaContent.autoStart && cnt.amp) {
      cnt.amp.playNow(this);
    }
  }

  /**
   * Draws the content of this Activebox on the specified canvas context.
   * @override
   * @param {external:CanvasRenderingContext2D} ctx - The canvas rendering context used to draw the
   * box content.
   * @param {module:AWT.Rectangle} [dirtyRegion] - The area that must be repainted. `null` refers to the whole box.
   */
  updateContent(ctx, dirtyRegion) {

    const
      abc = this.getCurrentContent(),
      style = this.getBoxBaseResolve();

    if (this.isInactive() || !abc || this.dim.width < 2 || this.dim.height < 2) {
      this._focusAccessibleElement(ctx);
      return true;
    }

    if (dirtyRegion && !this.intersects(dirtyRegion))
      return false;

    let imgRect = null;

    if (abc.img && !this.tmpTrans) {
      try {
        if (abc.imgClip) {
          const r = abc.imgClip.getBounds();
          let img = abc.img;
          if (!abc.imgClip.isRect()) {
            // Prepare a temporary `canvas` object that will contain the clipped image
            const tmpCanvas = document.createElement('canvas');
            tmpCanvas.width = r.pos.x + r.dim.width;
            tmpCanvas.height = r.pos.y + r.dim.height;
            const tmpCtx = tmpCanvas.getContext('2d');
            // Set the clipping region
            abc.imgClip.clip(tmpCtx);
            // Draw the original image
            tmpCtx.drawImage(abc.img, 0, 0);
            // Use the temporary canvas as a source image
            // (as seen on: [http://stackoverflow.com/questions/7242006/html5-copy-a-canvas-to-image-and-back])
            img = tmpCanvas;
          }
          ctx.drawImage(img,
            Math.max(0, r.pos.x), Math.max(0, r.pos.y), Math.min(img.width, r.dim.width), Math.min(img.height, r.dim.height),
            this.pos.x, this.pos.y, this.dim.width, this.dim.height);
        } else {
          let
            imgw = abc.img.naturalWidth || this.dim.width,
            imgh = abc.img.naturalHeight || this.dim.height,
            compress = false,
            scale = 1.0;
          if (settings.COMPRESS_IMAGES &&
            (this.dim.width > 0 && this.dim.height > 0) &&
            (imgw > this.dim.width || imgh > this.dim.height)) {

            scale = Math.min(this.dim.width / imgw, this.dim.height / imgh);
            imgw *= scale;
            imgh *= scale;
            compress = true;
          }
          const xs = abc.imgAlign.h === 'left' ? 0
            : abc.imgAlign.h === 'right' ? this.dim.width - imgw
              : (this.dim.width - imgw) / 2;
          const ys = abc.imgAlign.v === 'top' ? 0
            : abc.imgAlign.v === 'bottom' ? this.dim.height - imgh
              : (this.dim.height - imgh) / 2;
          if (compress) {
            ctx.drawImage(abc.img, this.pos.x + xs, this.pos.y + ys, imgw, imgh);
          } else
            ctx.drawImage(abc.img, this.pos.x + xs, this.pos.y + ys);

          if (abc.avoidOverlapping && abc.text)
            imgRect = new Rectangle(
              Math.max(0, xs), Math.max(0, ys),
              Math.min(this.dim.width, imgw), Math.min(this.dim.height, imgh));
        }
      } catch (ex) {
        log('warn', `Unable to draw image "${abc.image}": ${ex.message}`);
      }
    }
    if (abc.text && abc.text.length > 0) {
      let
        px = this.pos.x,
        py = this.pos.y,
        pWidth = this.dim.width,
        pHeight = this.dim.height;

      if (imgRect) {
        // There is an image in the ActiveBox
        // Try to compute the current space available for text
        const
          prx = [0, imgRect.pos.x, imgRect.pos.x + imgRect.dim.width, pWidth],
          pry = [0, imgRect.pos.y, imgRect.pos.y + imgRect.dim.height, pHeight],
          rr = [
            // Calc four rectangles inside BoxBag, sourronding imgRect
            // Top rectangle:
            new Rectangle(prx[0], pry[0], prx[3], pry[1]),
            // Bottom rectangle:
            new Rectangle(prx[0], pry[2], prx[3], pry[3] - pry[2]),
            // Left rectangle:
            new Rectangle(prx[0], pry[0], prx[1], pry[3]),
            // Right rectangle:
            new Rectangle(prx[2], pry[0], prx[3] - prx[2], pry[3])
          ];
        //
        // Find the rectangle with highest surface, and in accordance
        // with the `txtAlign` values of the current
        // [ActiveBoxContent](ActiveBoxContent)
        let rmax = rr[0];
        let maxSurface = rmax.dim.width * rmax.dim.height;
        for (let i = 1; i < rr.length; i++) {
          let s = rr[i].dim.width * rr[i].dim.height;
          if (s > maxSurface - 1) {
            if (Math.abs(s - maxSurface) <= 1) {
              let b = false;
              switch (i) {
                case 1:
                  b = abc.txtAlign.v === 'bottom';
                  break;
                case 2:
                  b = abc.txtAlign.h === 'left';
                  break;
                case 3:
                  b = abc.txtAlign.h === 'right';
                  break;
              }
              if (!b)
                continue;
            }
            maxSurface = s;
            rmax = rr[i];
          }
        }
        // Finally, this is the surface available to draw text:
        px += rmax.pos.x;
        py += rmax.pos.y;
        pWidth = rmax.dim.width;
        pHeight = rmax.dim.height;
      }

      // Calc available width and height, discounting margins
      const
        availWidth = Math.max(5, pWidth - 2 * style.textMargin),
        availHeight = Math.max(5, pHeight - 2 * style.textMargin);

      // Calc the size of each line
      const lines = style.prepareText(ctx, abc.text, availWidth, availHeight);

      ctx.font = style.font.cssFont();
      ctx.textBaseline = 'alphabetic';
      const
        lineHeight = style.font.getHeight(),
        totalHeight = lineHeight * lines.length;

      // Calc the vertical co-ordinate of the first line
      // Default is 'middle'
      let y = py + style.textMargin + (abc.txtAlign.v === 'top' ? 0
        : abc.txtAlign.v === 'bottom' ? availHeight - totalHeight
          : (availHeight - totalHeight) / 2) + style.font.getMetrics().ascent;

      for (let l = 0; l < lines.length; l++, y += lineHeight) {
        // Calc the horizontal position of each line
        // Default is 'middle'
        const x = px + style.textMargin + (abc.txtAlign.h === 'left' ? 0
          : abc.txtAlign.h === 'right' ?
            availWidth - lines[l].size.width
            : (availWidth - lines[l].size.width) / 2);

        if (style.shadow) {
          // Render text shadow
          const d = Math.max(1, style.font.size / 10);
          ctx.fillStyle = style.shadowColor;
          ctx.fillText(lines[l].text, x + d, y + d);
        }
        // Render text
        ctx.fillStyle = this.isInverted() ? style.backColor
          : this.isAlternative() ? style.alternativeColor : style.textColor;
        ctx.fillText(lines[l].text, x, y);
      }

      this._focusAccessibleElement(ctx);

    }
    return true;
  }

  /**
   * Draw focus on accessible element if needed
   * @param {external:CanvasRenderingContext2D} ctx - The canvas rendering context used to draw the
   * box content.
   */
  _focusAccessibleElement(ctx) {
    if (settings.CANVAS_DRAW_FOCUS && this.$accessibleElement) {
      this.shape.preparePath(ctx);
      ctx.drawFocusIfNeeded(this.$accessibleElement.get(-1));
    }
  }


  /**
   * Gets the `description` field of the current {@link module:boxes/ActiveBoxContent.ActiveBoxContent ActiveBoxContent}
   * @returns {string}
   */
  getDescription() {
    return this.content ? this.content.getDescription() : '';
  }

  /**
   * Gets a descriptive text for this ActiveBox
   * @returns {string}
   */
  toString() {
    return (this.role !== 'cell' ? getMsg(this.role) : '') + (this.getCurrentContent() || '-').toString();
  }

  /**
   * Plays the action or media associated with this ActiveBox
   * @param {module:JClicPlayer.JClicPlayer} ps - Usually, a {@link module:JClicPlayer.JClicPlayer JClicPlayer}
   * @param {function[]} delayedActions - If set, store the the action in this array for future execution
   */
  playMedia(ps, delayedActions = null) {
    const abc = this.getCurrentContent();
    if (abc && abc.mediaContent) {
      log('debug', `Playing: ${abc.mediaContent.toString()}`);
      ps.playMedia(abc.mediaContent, this, delayedActions);
      return true;
    }
    return false;
  }

  /**
   * Sets the hosted media player of this ActiveBox
   * @param {module:media/ActiveMediaPlayer.ActiveMediaPlayer} amp - The media player.
   */
  setHostedMediaPlayer(amp) {
    const old = this.hostedMediaPlayer;
    this.hostedMediaPlayer = amp;
    if (old && old !== amp)
      old.linkTo(null);
    if (amp)
      amp.linkTo(this);
  }

  /**
   * Sets a new size and/or dimension to this box.
   * @override
   * @param {AWT.Rectangle|number} rect - An AWT.Rectangle object, or the `x` coordinate of the
   * upper-left corner of a new rectangle.
   * @param {number} [y] - `y` coordinate of the upper-left corner of the new rectangle.
   * @param {number} [w] - Width of the new rectangle.
   * @param {number} [h] - Height of the new rectangle.
   */
  setBounds(rect, y, w, h) {
    if (typeof rect === 'number')
      // arguments are co-ordinates and size
      rect = new Rectangle(rect, y, w, h);
    // Rectangle comparision
    if (this.equals(rect))
      return;
    super.setBounds(rect);
    if (this.hostedMediaPlayer)
      this.hostedMediaPlayer.checkVisualComponentBounds(this);
  }

  /**
   * Places and resizes {@link module:boxes/AbstractBox.AbstractBox#$hostedComponent $hostedComponent}, based on the size
   * and position of this box.
   * @override
   * @param {boolean} sizeChanged - `true` when this {@link module:boxes/ActiveBox.ActiveBox ActiveBox} has changed its size
   */
  setHostedComponentBounds(sizeChanged) {
    if (this.$hostedComponent) {
      super.setHostedComponentBounds(sizeChanged);
      const abc = this.getCurrentContent();
      if (sizeChanged && abc && abc.animatedGifFile && abc.img) {
        const
          img = abc.img,
          w = Math.max(img.naturalWidth, this.dim.width),
          h = Math.max(img.naturalHeight, this.dim.height);
        let scale = 1, bgSize = '';
        if (abc.imgClip) {
          const r = abc.imgClip.getBounds();
          if (this.dim.width < r.dim.width || this.dim.height < r.dim.height) {
            scale = Math.min(this.dim.width / r.dim.width, this.dim.height / r.dim.height);
            bgSize = `${w * scale}px ${h * scale}px`;
          }
          this.$hostedComponent.css({
            'background-position': `${-abc.imgClip.pos.x * scale}px ${-abc.imgClip.pos.y * scale}px`,
            'background-size': bgSize
          });
        } else {
          if (this.dim.width < w || this.dim.height < h) {
            scale = Math.min(this.dim.width / w, this.dim.height / h);
            bgSize = `${w * scale}px ${h * scale}px`;
          }
          this.$hostedComponent.css({
            'background-size': bgSize
          });
        }
      }
    }
  }

  /**
   * Builds a hidden `buton` that will act as a accessible element associated to the canvas area
   * of this ActiveBox.
   * The button will be created only when `CanvasRenderingContext2D` has a method named `addHitRegion`.
   * See https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Hit_regions_and_accessibility
   * for more information and supported browsers.
   * @param {external:jQuery} $canvas - The `canvas` where this `ActiveBox` will deploy, wrapped up in a jQuery object
   * @param {external:jQuery} $clickReceiver - The DOM element that will be notified  when `$accessibleElement` is activated.
   * @param {external:jQuery} [$canvasGroup] - Optional DOM element containing the accessible element. Useful to group cells in associations. When `null`, the element belongs to $canvas.
   * @param {string} [eventType] - Type of event sent to $clickReceiver. Default is `click`.
   * @returns {external:jQuery} - The accessible element associated to this ActiveBox.
   */
  buildAccessibleElement($canvas, $clickReceiver, $canvasGroup, eventType) {
    if (this.$accessibleElement)
      this.$accessibleElement.remove();

    const canvas = $canvas.get(-1);
    if (canvas.width > 0 && canvas.height > 0) {
      const
        id = Math.round(Math.random() * 100000),
        disabled = this.isInactive() && !this.accessibleAlwaysActive;
      this.$accessibleElement = external_jquery_default()('<button/>', {
        tabindex: disabled ? -1 : 0,
        id: `AE${id}`,
        disabled: disabled
      })
        .html(this.toString())
        .on('click', ev => {
          // Check if event was produced by a mouse click
          if (ev.originalEvent && (ev.originalEvent.pageX !== 0 || ev.originalEvent.pageY !== 0)) {
            // Mouse clicks should be processed odirectly by the canvas, so ignore this accessible event
            return true;
          }
          log('debug', `Click on accessible element: ${this.toString()}`);
          const
            $event = external_jquery_default().Event(eventType || 'click'),
            bounds = this.getBounds(),
            offset = $canvas.offset();
          $event.pageX = offset.left + bounds.pos.x + bounds.dim.width / 2;
          $event.pageY = offset.top + bounds.pos.y + bounds.dim.height / 2;
          $clickReceiver.trigger($event);
          return false;
        });
      const $dest = $canvasGroup || $canvas;
      $dest.append(this.$accessibleElement);
      if (settings.CANVAS_DRAW_FOCUS) {
        this.$accessibleElement.on('focus blur', ev => {
          log('debug', `${ev.type} accessible element: ${this.toString()}`);
          if (this.container)
            this.container.update();
          this.updateContent(canvas.getContext('2d'), null);
        });
      }
    }
    return this.$accessibleElement;
  }
}

Object.assign(ActiveBox.prototype, {
  /**
   * Identifier used to set the relative position of this box in a set.
   * @name module:boxes/ActiveBox.ActiveBox#idOrder
   * @type {number} */
  idOrder: -1,
  /**
   * Identifier used to set a relative position in the space.
   * @name module:boxes/ActiveBox.ActiveBox#idLoc
   * @type {number} */
  idLoc: -1,
  /**
   * Identifier used to establish relationships between cells of different sets (in associations)
   * @name module:boxes/ActiveBox.ActiveBox#idAss
   * @type {number} */
  idAss: -1,
  /**
   * Backup of the original position of the cell, useful when the real position must be restored after a temporary change.
   * @name module:boxes/ActiveBox.ActiveBox#pos0
   * @type {module:AWT.Point} */
  pos0: null,
  /**
   * Main content of this box
   * @name module:boxes/ActiveBox.ActiveBox#content
   * @type {module:boxes/ActiveBoxContent.ActiveBoxContent} */
  content: null,
  /**
   * Alternative content of this box
   * @name module:boxes/ActiveBox.ActiveBox#altContent
   * @type {module:boxes/ActiveBoxContent.ActiveBoxContent} */
  altContent: null,
  /**
   * Flag to check if this box has a 'hosted component'
   * @name module:boxes/ActiveBox.ActiveBox#hostedComponent
   * @type {boolean} */
  hasHostedComponent: false,
  /**
   * The media player associated to this box
   * @name module:boxes/ActiveBox.ActiveBox#hostedMediaPlayer
   * @type {module:media/ActiveMediaPlayer.ActiveMediaPlayer} */
  hostedMediaPlayer: null,
  /**
   * Indicates that this box is used as a background. When drawing, the clipping region must be respected.
   * @name module:boxes/ActiveBox.ActiveBox#isBackground
   * @type {boolean} */
  isBackground: false,
});

/* harmony default export */ const boxes_ActiveBox = (ActiveBox);


;// CONCATENATED MODULE: ./src/skins/Counter.js
/**
 *  File    : skins/Counter.js
 *  Created : 07/05/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */

/**
 * This class encapsulates the operation of a numeric counter, used to display the current
 * values of score, actions and time.
 */
class Counter {
  /**
   * Counter constructor
   * @param {string} id - The type of information stored on this counter
   * @param {external:jQuery} [$div] - The HTML element where this counter will show values (can be _null_)
   */
  constructor(id, $div) {
    if (id)
      this.id = id;
    if ($div)
      this.$div = $div;
  }

  /**
   * Gets the current display value of this counter
   * @returns {number}
   */
  getDisplayValue() {
    let result = this.countDown > 0 ? this.countDown - this.value : this.value;
    if (this.displayDiffFrom)
      result = result - this.displayDiffFrom.value;
    return Math.max(0, Math.min(this.MAX_DISPLAY_VALUE, result));
  }

  /**
   * Paints the value of this counter on screen
   * (method to be overridden by subclasses)
   */
  refreshDisplay() {
    if (this.$div)
      this.$div.html(this.enabled ? (this.getDisplayValue() + 1000).toString().substr(1) : '000');
  }

  /**
   * Enables or disables this counter
   * @param {boolean} enabled - State been assigned to this counter
   */
  setEnabled(enabled) {
    if (this.enabled !== enabled) {
      this.enabled = enabled;
      if (this.$div) {
        this.refreshDisplay();
        this.$div.css('opacity', this.enabled ? 1.0 : 0.3);
      }
    }
  }

  /**
   * Sets the initial value of the counter
   * @param {number} maxValue - Value from which the countdown will start
   */
  setCountDown(maxValue) {
    if (this.countDown !== (this.countDown = maxValue))
      this.refreshDisplay();
  }

  /**
   * Increments by one the value of this counter
   */
  incValue() {
    this.value++;
    if (this.enabled)
      this.refreshDisplay();
  }

  /**
   * Sets a specific value to this counter
   * @param {number} value - The value to set
   */
  setValue(value) {
    if (this.enabled && this.value !== (this.value = value))
      this.refreshDisplay();
  }
}

Object.assign(Counter.prototype, {
  /**
   * Type of counter (usually: `score`, `actions` or `time`)
   * @name module:skins/Counter.Counter#id
   * @type {string} */
  id: '',
  /**
   * The HTML element where this counter shows its value
   * @name module:skins/Counter.Counter#$div
   * @type {external:jQuery}
   */
  $div: null,
  /**
   * Current value of this counter
   * @name module:skins/Counter.Counter#value
   * @type {number} */
  value: 0,
  /**
   * When set, the counter displays a countdown from this value to zero
   * @name module:skins/Counter.Counter#countDown
   * @type {number} */
  countDown: 0,
  /**
   * Flag indicating if this counter is currently enabled
   * @name module:skins/Counter.Counter#enabled
   * @type {boolean} */
  enabled: true,
  /**
   * Maximum value to be displayed by this counter
   * @name module:skins/Counter.Counter#MAX_DISPLAY_VALUE
   * @type {number} */
  MAX_DISPLAY_VALUE: 999,
  /**
   * An optional Counter used as a subtractor to display the current value.
   * Useful to display `errors` subtracting `score` from `actions`.
   * @name module:skins/Counter.Counter#displayDiffFrom
   * @type {module:skins/Counter.Counter}
   */
  displayDiffFrom: null,
});

/* harmony default export */ const skins_Counter = (Counter);

;// CONCATENATED MODULE: ./src/skins/assets/main.css
const main_namespaceObject = ".ID .JClicCtrlCnt {\n  margin: 0 9px 18px 9px;\n  display: -webkit-flex;\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n}\n\n.ID .JClicCountCnt {\n  display: -webkit-flex;\n  display: flex;\n  flex-direction: column;\n}\n\n.ID .JClicMsgBox {\n  height: 60px;\n  flex-grow: 1;\n  background-color: lightblue;\n}\n\n.ID .JClicBtn {\n  cursor: pointer;\n  line-height: 0;\n}\n\n.ID .JClicBtn:disabled {\n  cursor: inherit;\n  opacity: 0.3;\n}\n\n.ID .JClicCounter {\n  width: 40px;\n  height: 20px;\n  padding-left: 20px;\n  color: white;\n  cursor: pointer;\n  font-family: Roboto, Sans-serif;\n  font-size: 18px;\n  text-align: center;\n  background-repeat: no-repeat;\n  background-position: left;\n  box-sizing: content-box;\n}\n";
;// CONCATENATED MODULE: ./src/skins/assets/mainHalf.css
const mainHalf_namespaceObject = ".ID .JClicPlayerCnt {\n  margin: 9px;\n}\n\n.ID .JClicCtrlCnt {\n  margin: 0 4px 9px 4px;\n}\n\n.ID .JClicCtrlCnt button svg, img {\n  width: 18px;\n  height: 18px;\n}\n\n.ID .JClicMsgBox {\n  height: 30px;\n}\n\n.ID .JClicCounter {\n  width: 20px;\n  height: 10px;\n  margin-left: -15px;\n  transform: scale(0.5);\n}\n";
;// CONCATENATED MODULE: ./src/skins/assets/mainTwoThirds.css
const mainTwoThirds_namespaceObject = ".ID .JClicPlayerCnt {\n  margin: 12px;\n}\n\n.ID .JClicCtrlCnt {\n  margin: 0 6px 12px 6px;\n}\n\n.ID .JClicCtrlCnt button svg, img {\n  width: 24px;\n  height: 24px;\n}\n\n.ID .JClicMsgBox {\n  height: 40px;\n}\n\n.ID .JClicCounter {\n  width: 27px;\n  height: 13px;\n  margin-left: -10px;\n  transform: scale(0.666);\n}\n";
;// CONCATENATED MODULE: ./src/skins/assets/prevIcon.svg
const prevIcon_namespaceObject = "<svg fill=\"#FFFFFF\" viewBox=\"0 0 24 24\" width=\"36\" height=\"36\" xmlns=\"http://www.w3.org/2000/svg\">\n  <path d=\"M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z\" />\n</svg>\n";
;// CONCATENATED MODULE: ./src/skins/assets/nextIcon.svg
const nextIcon_namespaceObject = "<svg fill=\"#FFFFFF\" viewBox=\"0 0 24 24\" width=\"36\" height=\"36\" xmlns=\"http://www.w3.org/2000/svg\">\n  <path d=\"M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z\" />\n</svg>\n";
;// CONCATENATED MODULE: ./src/skins/assets/fullScreenIcon.svg
const fullScreenIcon_namespaceObject = "<svg fill=\"#FFFFFF\" viewBox=\"0 0 24 24\" width=\"36\" height=\"36\" xmlns=\"http://www.w3.org/2000/svg\">\n  <path d=\"M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z\" />\n</svg>\n";
;// CONCATENATED MODULE: ./src/skins/assets/fullScreenExitIcon.svg
const fullScreenExitIcon_namespaceObject = "<svg fill=\"#FFFFFF\" viewBox=\"0 0 24 24\" width=\"36\" height=\"36\" xmlns=\"http://www.w3.org/2000/svg\">\n  <path d=\"M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z\" />\n</svg>\n";
;// CONCATENATED MODULE: ./src/skins/assets/closeIcon.svg
const closeIcon_namespaceObject = "<svg fill=\"#FFFFFF\" viewBox=\"0 0 24 24\" width=\"36\" height=\"36\" xmlns=\"http://www.w3.org/2000/svg\">\n  <path d=\"M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z\" />\n</svg>\n";
;// CONCATENATED MODULE: ./src/skins/assets/infoIcon.svg
const infoIcon_namespaceObject = "<svg fill=\"#FFFFFF\" viewBox=\"0 0 24 24\" width=\"36\" height=\"36\" xmlns=\"http://www.w3.org/2000/svg\">\n  <path d=\"M11 17h2v-6h-2v6zm1-15C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zM11 9h2V7h-2v2z\" />\n</svg>\n";
;// CONCATENATED MODULE: ./src/skins/assets/reportsIcon.svg
const reportsIcon_namespaceObject = "<svg fill=\"#FFFFFF\" viewBox=\"0 0 24 24\" width=\"36\" height=\"36\" xmlns=\"http://www.w3.org/2000/svg\">\n  <path d=\"M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 17H7v-7h2v7zm4 0h-2V7h2v10zm4 0h-2v-4h2v4z\" />\n</svg>\n";
;// CONCATENATED MODULE: ./src/skins/assets/timeIcon.svg
const timeIcon_namespaceObject = "<svg fill=\"#FFFFFF\" viewBox=\"0 0 24 24\" width=\"18\" height=\"18\" xmlns=\"http://www.w3.org/2000/svg\">\n  <path d=\"M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z\" />\n  <path d=\"M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z\" />\n</svg>\n";
;// CONCATENATED MODULE: ./src/skins/assets/scoreIcon.svg
const scoreIcon_namespaceObject = "<svg fill=\"#FFFFFF\" viewBox=\"0 0 24 24\" width=\"18\" height=\"18\" xmlns=\"http://www.w3.org/2000/svg\">\n  <path d=\"M9 16.2L4.8 12l-1.4 1.4L9 19 21 7l-1.4-1.4L9 16.2z\" />\n</svg>\n";
;// CONCATENATED MODULE: ./src/skins/assets/actionsIcon.svg
const actionsIcon_namespaceObject = "<svg fill=\"#FFFFFF\" viewBox=\"0 0 24 24\" width=\"18\" height=\"18\" xmlns=\"http://www.w3.org/2000/svg\">\n  <path d=\"M13.49 5.48c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm-3.6 13.9l1-4.4 2.1 2v6h2v-7.5l-2.1-2 .6-3c1.3 1.5 3.3 2.5 5.5 2.5v-2c-1.9 0-3.5-1-4.3-2.4l-1-1.6c-.4-.6-1-1-1.7-1-.3 0-.5.1-.8.1l-5.2 2.2v4.7h2v-3.4l1.8-.7-1.6 8.1-4.9-1-.4 2 7 1.4z\" />\n</svg>\n";
;// CONCATENATED MODULE: ./src/skins/DefaultSkin.js
/**
 *  File    : skins/DefaultSkin.js
 *  Created : 12/05/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */

/* global document */








// Use Webpack to import CSS and SVG files














/**
 * This is the default {@link module:skins/Skin.Skin Skin} used by JClic.js
 * @extends module:skins/Skin.Skin
 */
class DefaultSkin extends skins_Skin {
  /**
   * DefaultSkin constructor
   * @param {module:JClicPlayer.JClicPlayer} ps - The PlayStation (currently a {@link module:JClicPlayer.JClicPlayer JClicPlayer}) used to load and
   * realize the media objects needed tot build the Skin.
   * @param {string} [name] - The skin class name
   * @param {object} [options] - Optional parameter with additional options, used by subclasses
   * this skin. When `null` or `undefined`, a new one will be created.
   */
  constructor(ps, name = null, options = {}) {
    // DefaultSkin extends [Skin](Skin.html)
    super(ps, name, options);
    let msg = '';

    Font.loadGoogleFonts(this.cssFonts);

    // Create the main container for buttons, counters and message box
    this.$ctrlCnt = external_jquery_default()('<div/>', { class: 'JClicCtrlCnt unselectableText', role: 'navigation' });
    this.$div.append(this.$ctrlCnt);

    // Add `prev` button
    msg = getMsg('Previous activity');
    this.buttons.prev = external_jquery_default()('<button/>', { class: 'JClicBtn', title: msg, 'aria-label': msg })
      .append(external_jquery_default()(getSvg(this.prevIcon, this.iconWidth, this.iconHeight, this.iconFill)))
      .on('click', evt => {
        if (this.ps)
          this.ps.actions.prev.processEvent(evt);
      });
    this.$ctrlCnt.append(this.buttons.prev);

    // Add message box
    this.msgBox = new boxes_ActiveBox();
    this.msgBox.role = 'message';
    this.$msgBoxDiv = external_jquery_default()('<div/>', { class: 'JClicMsgBox' })
      .on('click', () => {
        this.msgBox.playMedia(ps);
        return false;
      });
    this.$ctrlCnt.append(this.$msgBoxDiv);

    // Add `next` button
    msg = getMsg('Next activity');
    this.buttons.next = external_jquery_default()('<button/>', { class: 'JClicBtn', title: msg, 'aria-label': msg })
      .append(external_jquery_default()(getSvg(this.nextIcon, this.iconWidth, this.iconHeight, this.iconFill)))
      .on('click', evt => {
        if (this.ps)
          this.ps.actions.next.processEvent(evt);
      });
    this.$ctrlCnt.append(this.buttons.next);

    // Add counters
    if (false !== this.ps.options.counters && false !== options.counters) {
      // Create counters
      msg = getMsg('Reports');
      const $countCnt = external_jquery_default()('<button/>', { class: 'JClicCountCnt', 'aria-label': msg })
        .on('click', evt => {
          if (this.ps)
            this.ps.actions.reports.processEvent(evt);
        });
      external_jquery_default().each(skins_Skin.prototype.counters, (name, _val) => {
        msg = getMsg(name);
        this.counters[name] = new skins_Counter(name, external_jquery_default()('<div/>', { class: 'JClicCounter', title: msg, 'aria-label': msg })
          .css({
            'background-image': `url(${svgToURI(this[name + 'Icon'], this.counterIconWidth, this.counterIconHeight, this.counterIconFill)})`,
            color: this.counterIconFill
          })
          .html('000')
          .appendTo($countCnt));
      });
      this.$ctrlCnt.append($countCnt);
    }

    // Add info button
    if (true === this.ps.options.info || true === options.info) {
      msg = getMsg('Information');
      this.buttons.info = external_jquery_default()('<button/>', { class: 'JClicBtn', title: msg, 'aria-label': msg })
        .append(external_jquery_default()(getSvg(this.infoIcon, this.iconWidth, this.iconHeight, this.iconFill)))
        .on('click', evt => {
          if (this.ps)
            this.ps.actions.info.processEvent(evt);
        });
      this.$ctrlCnt.append(this.buttons.info);
    }

    // Add reports button
    if (true === this.ps.options.reportsBtn || true === options.reportsBtn) {
      msg = getMsg('Reports');
      this.buttons.about = external_jquery_default()('<button/>', { class: 'JClicBtn', title: msg, 'aria-label': msg })
        .append(external_jquery_default()(getSvg(this.reportsIcon, this.iconWidth, this.iconHeight, this.iconFill)))
        .on('click', evt => {
          if (this.ps)
            this.ps.actions.reports.processEvent(evt);
        });
      this.$ctrlCnt.append(this.buttons.about);
    }

    // Add `full screen` button
    if (document && document.fullscreenEnabled) {
      msg = getMsg('Toggle full screen');
      this.buttons.fullscreen = external_jquery_default()('<button/>', { class: 'JClicBtn', title: msg, 'aria-label': msg })
        .append(external_jquery_default()('<img/>', { src: svgToURI(this.fullScreenIcon, this.iconWidth, this.iconHeight, this.iconFill) }))
        .on('click', () => {
          this.setScreenFull(null);
        });
      this.$ctrlCnt.append(this.buttons.fullscreen);
    }

    // Add `close` button
    if (typeof this.ps.options.closeFn === 'function') {
      msg = getMsg('Close');
      const closeFn = this.ps.options.closeFn;
      this.buttons.close = external_jquery_default()('<button/>', { class: 'JClicBtn', title: msg, 'aria-label': msg })
        .append(external_jquery_default()(getSvg(this.closeIcon, this.iconWidth, this.iconHeight, this.iconFill)))
        .on('click', () => {
          log('info', 'Closing the player');
          closeFn();
        });
      this.$ctrlCnt.append(this.buttons.close);
    }

    // Workaround for a bug in Edge and Explorer: SVG objects not implementing `blur` and `focus` methods
    // See: [https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8479637/]
    // This affects Polymer `iron-overlay-behavior`. See: [https://github.com/PolymerElements/iron-overlay-behavior/pull/211]
    let nilFunc = null;
    external_jquery_default().each(this.buttons, (_key, value) => {
      if (value && (typeof value[0].focus !== 'function' || typeof value[0].blur !== 'function')) {
        if (nilFunc === null)
          nilFunc = () => log('error', '"blur" and "focus" not defined for SVG objects in Explorer/Edge');
        value[0].focus = value[0].blur = nilFunc;
      }
    });
  }

  /**
   * Returns the CSS styles used by this skin. This method should be called only from
   * the `Skin` constructor, and overridded by subclasses if needed.
   * @param {string} media - A specific media size. Possible values are: 'default', 'half' and 'twoThirds'
   * @returns {string}
   */
  _getStyleSheets(media = 'default') {
    return `${super._getStyleSheets(media)}${media === 'default' ? this.mainCSS : media === 'half' ? this.mainCSSHalf : media === 'twoThirds' ? this.mainCSSTwoThirds : ''}`;
  }

  /**
   * Main method used to build the content of the skin. Resizes and places internal objects.
   * @override
   */
  doLayout() {
    // Call method on ancestor
    super.doLayout();

    // Set the fullScreen icon
    if (this.buttons.fullscreen)
      this.buttons.fullscreen.find('img').get(-1).src = svgToURI(
        this[(document && document.fullscreenElement) ? 'fullScreenExitIcon' : 'fullScreenIcon'],
        this.iconWidth, this.iconHeight, this.iconFill);
  }

  /**
   * Enables or disables the `tabindex` attribute of the main buttons. Useful when a modal dialog
   * overlay is active, to avoid direct access to controls not related with the dialog.
   * @param {boolean} status - `true` to make main controls navigable, `false` otherwise
   */
  enableMainButtons(status) {
    this.$ctrlCnt.find('.JClicBtn,.JClicCountCnt').attr('tabindex', status ? '0' : '-1');
  }
}

Object.assign(DefaultSkin.prototype, {
  /**
   * Class name of this skin. It will be used as a base selector in the definition of all CSS styles.
   * @name module:skins/DefaultSkin.DefaultSkin#skinId
   * @override
   * @type {string}
   */
  skinId: 'JClicDefaultSkin',
  /**
   * The HTML div where buttons, counters and message box are placed
   * @name module:skins/DefaultSkin.DefaultSkin#$ctrlCnt
   * @type {external:jQuery} */
  $ctrlCnt: null,
  /**
   * Space (pixels) between the components of this {@link module:skins/Skin.Skin Skin}
   * @name module:skins/DefaultSkin.DefaultSkin#margin
   * @type {number} */
  margin: 18,
  /**
   * Height of {@link module:skins/DefaultSkin.DefaultSkin#msgBox msgBox}
   * @name module:skins/DefaultSkin.DefaultSkin#msgBoxHeight
   * @type {number} */
  msgBoxHeight: 60,
  /**
   * Width of counters, in pixels
   * @name module:skins/DefaultSkin.DefaultSkin#countersWidth
   * @type {number} */
  countersWidth: 60,
  /**
   * Height of counters, in pixels
   * @name module:skins/DefaultSkin.DefaultSkin#countersHeight
   * @type {number} */
  countersHeight: 20,
  //
  //Buttons and other graphical resources used by this skin.
  //
  /**
   * Styles used in this skin
   * @name module:skins/DefaultSkin.DefaultSkin#mainCSS
   * @type {string} */
  mainCSS: main_namespaceObject,
  /**
   * Styles used in this skin, sized to half its regular size
   * @name module:skins/DefaultSkin.DefaultSkin#mainCSSHalf
   * @type {string} */
  mainCSSHalf: mainHalf_namespaceObject,
  /**
   * Styles used in this skin, sized to two thirds of its regular size
   * @name module:skins/DefaultSkin.DefaultSkin#mainCSSTwoThirds
   * @type {string} */
  mainCSSTwoThirds: mainTwoThirds_namespaceObject,
  /**
   * Fonts used in this skin
   * @name module:skins/DefaultSkin.DefaultSkin#cssFonts
   * @type {string[]} */
  cssFonts: ['Roboto'],
  //
  // Default settings for icons (can be overridden in subclasses):
  /**
   * Icon width
   * @name module:skins/DefaultSkin.DefaultSkin#iconWidth
   * @type {number} */
  iconWidth: 36,
  /**
   * Icon height
   * @name module:skins/DefaultSkin.DefaultSkin#iconHeight
   * @type {number} */
  iconHeight: 36,
  /**
   * Fill color for icons
   * @name module:skins/DefaultSkin.DefaultSkin#iconFill
   * @type {string} */
  iconFill: '#FFFFFF',
  //
  // SVG images for action buttons
  // Based on [Google Material design Icons](https://google.github.io/material-design-icons/)
  //
  /**
   * Icon for 'previous activity' button
   * @name module:skins/DefaultSkin.DefaultSkin#prevIcon
   * @type {string} */
  prevIcon: prevIcon_namespaceObject,
  /**
   * Icon for 'next activity' button
   * @name module:skins/DefaultSkin.DefaultSkin#nextIcon
   * @type {string} */
  nextIcon: nextIcon_namespaceObject,
  /**
   * Full screen on icon
   * @name module:skins/DefaultSkin.DefaultSkin#fullScreenIcon
   * @type {string} */
  fullScreenIcon: fullScreenIcon_namespaceObject,
  /**
   * Full screen off icon
   * @name module:skins/DefaultSkin.DefaultSkin#fullScreenExitIcon
   * @type {string} */
  fullScreenExitIcon: fullScreenExitIcon_namespaceObject,
  /**
   * Close button
   * @name module:skins/DefaultSkin.DefaultSkin#closeIcon
   * @type {string} */
  closeIcon: closeIcon_namespaceObject,
  /**
   * Info button
   * @name module:skins/DefaultSkin.DefaultSkin#infoIcon
   * @type {string} */
  infoIcon: infoIcon_namespaceObject,
  /**
   * Reports button
   * @name module:skins/DefaultSkin.DefaultSkin#reportsIcon
   * @type {string} */
  reportsIcon: reportsIcon_namespaceObject,
  //
  // Settings for counters:
  /**
   * Counter icon width
   * @name module:skins/DefaultSkin.DefaultSkin#counterIconWidth
   * @type {number} */
  counterIconWidth: 18,
  /**
   * Counter icon height
   * @name module:skins/DefaultSkin.DefaultSkin#counterIconHeight
   * @type {number} */
  counterIconHeight: 18,
  /**
   * Counter icon fill color
   * @name module:skins/DefaultSkin.DefaultSkin#counterIconFill
   * @type {string} */
  counterIconFill: '#FFFFFF',
  // Counters:
  /**
   * Time icon
   * @name module:skins/DefaultSkin.DefaultSkin#timeIcon
   * @type {string} */
  timeIcon: timeIcon_namespaceObject,
  /**
   * Score icon
   * @name module:skins/DefaultSkin.DefaultSkin#scoreIcon
   * @type {string} */
  scoreIcon: scoreIcon_namespaceObject,
  /**
   * Actions icon
   * @name module:skins/DefaultSkin.DefaultSkin#actionsIcon
   * @type {string} */
  actionsIcon: actionsIcon_namespaceObject,
});

// Register this class in the list of available skins
/* harmony default export */ const skins_DefaultSkin = (skins_Skin.registerClass('default', DefaultSkin));

;// CONCATENATED MODULE: ./src/skins/OrangeSkin.js
/**
 *  File    : skins/OrangeSkin.js
 *  Created : 04/07/2016
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */




/**
 * This is a variant of the default {@link module:skins/Skin.Skin Skin} used by JClic.js
 * It differs from {@link module:skins/DefaultSkin.DefaultSkin DefaultSkin} only in some colors
 * @extends module:skins/DefaultSkin.DefaultSkin
 */
class OrangeSkin extends skins_DefaultSkin {
  /**
   * OrangeSkin constructor
   * @param {module:JClicPlayer.JClicPlayer} ps - The PlayStation (currently a {@link module:JClicPlayer.JClicPlayer JClicPlayer}) used to load and
   * realize the media objects meeded tot build the Skin.
   * @param {string} [name] - The skin class name
   * @param {object} [options] - Optional parameter with additional options
   */
  constructor(ps, name = null, options = {}) {
    // OrangeSkin extends [DefaultSkin](DefaultSkin.html)
    super(ps, name, options);
  }

  /**
   * Returns the CSS styles used by this skin. This method should be called only from
   * the `Skin` constructor, and overridded by subclasses if needed.
   * @param {string} media - A specific media size. Possible values are: 'default', 'half' and 'twoThirds'
   * @returns {string}
   */
  _getStyleSheets(media = 'default') {
    return super._getStyleSheets(media) + (media === 'default' ? this.skinCSS : '');
  }
}

Object.assign(OrangeSkin.prototype, {
  /**
   * Class name of this skin. It will be used as a base selector in the definition of all CSS styles.
   * @name module:skins/OrangeSkin.OrangeSkin#skinId
   * @override
   * @type {string} */
  skinId: 'JClicOrangeSkin',
  /**
   * Styles used in this skin
   * @name module:skins/OrangeSkin.OrangeSkin#skinCSS
   * @type {string} */
  skinCSS: '.ID {background-color:#FF8B19;}'
});

/* harmony default export */ const skins_OrangeSkin = (skins_Skin.registerClass('orange', OrangeSkin));

;// CONCATENATED MODULE: ./src/skins/GreenSkin.js
/**
 *  File    : skins/GreenSkin.js
 *  Created : 04/07/2016
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */




/**
 * This is a variant of the default {@link module:skins/Skin.Skin Skin} used by JClic.js
 * It differs from {@link module:skins/DefaultSkin.DefaultSkin DefaultSkin} only in some colors
 * @extends module:skins/DefaultSkin.DefaultSkin
 */
class GreenSkin extends skins_DefaultSkin {
  /**
   * GreenSkin constructor
   * 
   * @param {module:JClicPlayer.JClicPlayer} ps - The PlayStation (currently a {@link module:JClicPlayer.JClicPlayer JClicPlayer}) used to load and
   * realize the media objects needed to build this Skin.
   * @param {string} [name] - The skin class name
   * @param {object} [options] - Optional parameter with additional options
   */
  constructor(ps, name = null, options = {}) {
    // GreenSkin extends [DefaultSkin](DefaultSkin.html)
    super(ps, name, options);
  }

  /**
   * Returns the CSS styles used by this skin. This method should be called only from
   * the `Skin` constructor, and overridded by subclasses if needed.
   * @param {string} media - A specific media size. Possible values are: 'default', 'half' and 'twoThirds'
   * @returns {string}
   */
  _getStyleSheets(media = 'default') {
    return super._getStyleSheets(media) + (media === 'default' ? this.skinCSS : '');
  }
}

Object.assign(GreenSkin.prototype, {
  /**
   * Class name of this skin. It will be used as a base selector in the definition of all CSS styles.
   * @name module:skins/GreenSkin.GreenSkin#skinId
   * @override
   * @type {string} */
  skinId: 'JClicGreenSkin',
  //
  // Buttons and other graphical resources used by this skin:
  /**
   * Fill color for icons
   * @name module:skins/GreenSkin.GreenSkin#iconFill
   * @override
   * @type {string} */
  iconFill: '#20640E',
  /**
   * Fill-in color for counters
   * @name module:skins/GreenSkin.GreenSkin#counterIconFill
   * @override
   * @type {string} */
  counterIconFill: '#20640E',
  /**
   * Styles used in this skin
   * @name module:skins/GreenSkin.GreenSkin#skinCSS
   * @type {string} */
  skinCSS: '.ID {background-color:#4AFF19;}'
});

// Register this class in the list of available skins
/* harmony default export */ const skins_GreenSkin = (skins_Skin.registerClass('green', GreenSkin));

;// CONCATENATED MODULE: ./src/skins/BlueSkin.js
/**
 *  File    : skins/BlueSkin.js
 *  Created : 04/07/2016
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */





/**
 * This is a variant of the default {@link module:skins/Skin.Skin Skin} used by JClic.js
 * It differs from {@link module:skins/DefaultSkin.DefaultSkin DefaultSkin} only in some colors
 * @extends module:skins/DefaultSkin.DefaultSkin
 */
class BlueSkin extends skins_DefaultSkin {
  /**
   * BlueSkin constructor
   * @param {module:JClicPlayer.JClicPlayer} ps - The PlayStation (currently a {@link module:JClicPlayer.JClicPlayer JClicPlayer}) used to load and
   * realize the media objects needed to build the Skin.
   * @param {string} [name] - The skin class name
   * @param {object} [options] - Optional parameter with additional options
   */
  constructor(ps, name = null, options = {}) {
    // BlueSkin extends [DefaultSkin](DefaultSkin.html)
    super(ps, name, options);
  }

  /**
   * Returns the CSS styles used by this skin. This method should be called only from
   * the `Skin` constructor, and overridded by subclasses if needed.
   * @param {string} media - A specific media size. Possible values are: 'default', 'half' and 'twoThirds'
   * @returns {string}
   */
  _getStyleSheets(media = 'default') {
    return super._getStyleSheets(media) + (media === 'default' ? this.skinCSS : '');
  }
}

Object.assign(BlueSkin.prototype, {
  /**
   * Class name of this skin. It will be used as a base selector in the definition of all CSS styles.
   * @name module:skins/BlueSkin.BlueSkin#skinId
   * @override
   * @type {string} */
  skinId: 'JClicBlueSkin',
  /**
   * Styles used in this skin
   * @name module:skins/BlueSkin.BlueSkin#skinCSS
   * @type {string} */
  skinCSS: '.ID {background-color:#1990FF;}',
});

// Register this class in the list of available skins
/* harmony default export */ const skins_BlueSkin = (skins_Skin.registerClass('blue', BlueSkin));

;// CONCATENATED MODULE: ./src/skins/assets/simple.css
const simple_namespaceObject = ".ID {\n  background-color: #888888;\n}\n\n.ID .JClicCtrlCnt {\n  margin: 9px;\n}\n\n.ID .JClicPlayerCnt {\n  margin: 0px 18px 18px;\n}\n\n.ID .JClicMsgBox {\n  flex-grow: 0;\n  margin: 0 18px 18px 18px;\n}\n";
;// CONCATENATED MODULE: ./src/skins/assets/simpleHalf.css
const simpleHalf_namespaceObject = ".ID .JClicCtrlCnt {\n  margin: 4px;\n}\n\n.ID .JClicPlayerCnt {\n  margin: 0px 9px 9px;\n}\n\n.ID .JClicMsgBox {\n  margin: 0 9px 9px 9px;\n}\n";
;// CONCATENATED MODULE: ./src/skins/assets/simpleTwoThirds.css
const simpleTwoThirds_namespaceObject = ".ID .JClicCtrlCnt {\n  margin: 6px;\n}\n\n.ID .JClicPlayerCnt {\n  margin: 0px 12px 12px;\n}\n\n.ID .JClicMsgBox {\n  margin: 0 12px 12px 12px;\n}\n";
;// CONCATENATED MODULE: ./src/skins/SimpleSkin.js
/**
 *  File    : skins/SimpleSkin.js
 *  Created : 04/07/2016
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */





// Use Webpack to import CSS and SVG files




/**
 * This is a variant of the default {@link module:skins/Skin.Skin Skin} used by JClic.js
 * It has the buttons at top, and don't has counters.
 * @extends module:skins/DefaultSkin.DefaultSkin
 */
class SimpleSkin extends skins_DefaultSkin {
  /**
   * SimpleSkin constructor
   * @param {module:JClicPlayer.JClicPlayer} ps - The PlayStation (currently a {@link module:JClicPlayer.JClicPlayer JClicPlayer}) used to load and
   * realize the media objects meeded tot build the Skin.
   * @param {string} [name] - The skin class name
   * @param {object} [options] - Optional parameter with additional options
   */
  constructor(ps, name = null, options = {}) {
    // OrangeSkin extends [DefaultSkin](DefaultSkin.html)
    super(ps, name, Object.assign({}, options, { counters: false, reportsBtn: true }));

    this.$ctrlCnt.detach().prependTo(this.$div);
    this.$msgBoxDiv.detach().appendTo(this.$div);
    // Add a spacing div in substitution of msgBox
    external_jquery_default()('<div/>').css({ 'flex-grow': 1 }).insertAfter(this.$ctrlCnt.children(':nth-child(2)'));
  }

  /**
   * Returns the CSS styles used by this skin. This method should be called only from
   * the `Skin` constructor, and overridded by subclasses if needed.
   * @param {string} media - A specific media size. Possible values are: 'default', 'half' and 'twoThirds'
   * @returns {string}
   */
  _getStyleSheets(media = 'default') {
    return `${super._getStyleSheets(media)}${media === 'default' ? this.skinCSS : media === 'half' ? this.skinCSSHalf : media === 'twoThirds' ? this.skinCSSTwoThirds : ''}`;
  }
}

Object.assign(SimpleSkin.prototype, {
  /**
   * Class name of this skin. It will be used as a base selector in the definition of all CSS styles.
   * @name module:skins/SimpleSkin.SimpleSkin#skinId
   * @override
   * @type {string} */
  skinId: 'JClicSimpleSkin',
  /**
   * Styles used in this skin
   * @name module:skins/SimpleSkin.SimpleSkin#skinCSS
   * @type {string} */
  skinCSS: simple_namespaceObject,
  skinCSSHalf: simpleHalf_namespaceObject,
  skinCSSTwoThirds: simpleTwoThirds_namespaceObject,
});

// Register this class in the list of available skins
/* harmony default export */ const skins_SimpleSkin = (skins_Skin.registerClass('simple', SimpleSkin));

;// CONCATENATED MODULE: ./src/skins/assets/mini.css
const mini_namespaceObject = ".ID {\n  background-color: #F4F4F4;\n}\n\n.ID .JClicPlayerCnt {\n  margin: 4px;\n}\n\n.ID .JClicCtrlCnt {\n  margin: 0 2px 4px 2px;\n}\n\n.ID .JClicMsgBox {\n  height: 25px;\n}\n";
;// CONCATENATED MODULE: ./src/skins/MiniSkin.js
/**
 *  File    : skins/MiniSkin.js
 *  Created : 05/07/2016
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */




// Use Webpack to import CSS and SVG files


/**
 * This is a variant of the default {@link module:skins/Skin.Skin Skin} used by JClic.js
 * It differs from {@link module:skins/DefaultSkin.DefaultSkin DefaultSkin} in colors and sizes
 * @extends module:skins/DefaultSkin.DefaultSkin
 */
class MiniSkin extends skins_DefaultSkin {
  /**
   * MiniSkin constructor
   *
   * @param {module:JClicPlayer.JClicPlayer} ps - The PlayStation (currently a {@link module:JClicPlayer.JClicPlayer JClicPlayer}) used to load and
   * realize the media objects meeded tot build the Skin.
   * @param {string} [name] - The skin class name
   * @param {object} [options] - Optional parameter with additional options
   */
  constructor(ps, name = null, options = {}) {
    // MiniSkin extends [DefaultSkin](DefaultSkin.html)
    super(ps, name, Object.assign({}, options, { counters: false, reportsBtn: true }));
  }

  /**
   * Returns the CSS styles used by this skin. This method should be called only from
   * the `Skin` constructor, and overridded by subclasses if needed.
   * @param {string} media - A specific media size. Possible values are: 'default', 'half' and 'twoThirds'
   * @returns {string}
   */
  _getStyleSheets(media = 'default') {
    return super._getStyleSheets(media) + (media === 'default' ? this.skinCSS : '');
  }
}

Object.assign(MiniSkin.prototype, {
  /**
   * Class name of this skin. It will be used as a base selector in the definition of all CSS styles.
   * @name MiniSkin#skinId
   * @override
   * @type {string}
   */
  skinId: 'JClicMiniSkin',
  // Buttons and other graphical resources used by this skin.
  //
  /**
   * Icon width
   * @name MiniSkin#iconWidth
   * @override
   * @type {number} */
  iconWidth: 18,
  /**
   * Icon height
   * @name MiniSkin#iconHeight
   * @override
   * @type {number} */
  iconHeight: 18,
  /**
   * Fill color for icons
   * @name MiniSkin#iconFill
   * @override
   * @type {string} */
  iconFill: '#080808',
  /**
   * Fill-in color for counters
   * @name MiniSkin#counterIconFill
   * @override
   * @type {string} */
  counterIconFill: '#080808',
  /**
   * Default margin between elements
   * @name MiniSkin#margin
   * @override
   * @type {number} */
  margin: 8,
  /**
   * Styles used in this skin
   * @name MiniSkin#skinCSS
   * @type {string} */
  skinCSS: mini_namespaceObject,
  /**
   * Styles used in this skin, sized to half its regular size.
   * (_null_ here because MiniSkin it's already very small)
   * @name MiniSkin#mainCSSHalf
   * @override
   * @type {string} */
  mainCSSHalf: '',
  /**
   * Styles used in this skin, sized to two thirds of its regular size
   * (_null_ here because MiniSkin it's already very small)
   * @name MiniSkin#mainCSSTwoThirds
   * @override
   * @type {string} */
  mainCSSTwoThirds: '',
});

// Register this class in the list of available skins
/* harmony default export */ const skins_MiniSkin = (skins_Skin.registerClass('mini', MiniSkin));

;// CONCATENATED MODULE: ./src/skins/EmptySkin.js
/**
 *  File    : skins/EmptySkin.js
 *  Created : 14/03/2017
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */




/**
 * A minimalist {@link module:skins/Skin.Skin Skin} for JClic.js with just the player, without messages, counters nor any button.
 * @extends module:skins/Skin.Skin
 */
class EmptySkin extends skins_Skin {

  /**
   * EmptySkin constructor
   *
   * @param {module:JClicPlayer.JClicPlayer} ps - The PlayStation (currently a {@link module:JClicPlayer.JClicPlayer JClicPlayer}) used to load and
   * realize the media objects needed tot build the Skin.
   * @param {string} [name] - The skin class name
   * @param {object} [options] - Optional parameter with additional options
   */
  constructor(ps, name = null, options = {}) {
    // EmptySkin extends [Skin](Skin.html)
    super(ps, name, options);
    this.msgBox = new boxes_ActiveBox();
    this.msgBox.role = 'message';
  }
  /**
   * Returns the CSS styles used by this skin. This method should be called only from
   * the `Skin` constructor, and overridded by subclasses if needed.
   * @param {string} media - A specific media size. Possible values are: 'default', 'half' and 'twoThirds'
   * @returns {string}
   */
  _getStyleSheets(media = 'default') {
    return super._getStyleSheets(media) + (media === 'default' ? this.mainCSS : '');
  }
}

Object.assign(EmptySkin.prototype, {
  /**
   * Class name of this skin. It will be used as a base selector in the definition of all CSS styles.
   * @name module:skins/EmptySkin.EmptySkin#skinId
   * @override
   * @type {string} */
  skinId: 'JClicEmptySkin',
  /**
   * Styles used in this skin
   * @name module:skins/EmptySkin.EmptySkin#skinCSS
   * @override
   * @type {string} */
  mainCSS: '.ID .JClicPlayerCnt {margin:0;}'
});

// Register this class in the list of available skins
/* harmony default export */ const skins_EmptySkin = (skins_Skin.registerClass('empty', EmptySkin));

;// CONCATENATED MODULE: ./src/skins/CustomSkin.js
/**
 *  File    : skins/CustomSkin.js
 *  Created : 12/02/2018
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */








/**
 * Custom {@link module:skins/Skin.Skin Skin} for JClic.js, built assembling specific cuts of a canvas (usually a PNG file) defined in an XML file
 * @extends module:skins/Skin.Skin
 */
class CustomSkin extends skins_Skin {

  /**
   * CustomSkin constructor
   *
   * @param {module:JClicPlayer.JClicPlayer} ps - The PlayStation (currently a {@link module:JClicPlayer.JClicPlayer JClicPlayer}) used to load and
   * realize the media objects needed tot build the Skin.
   * @param {string} [name] - The skin class name
   * @param {object} [options] - Optional parameter with additional options
   */
  constructor(ps, name = null, options = null) {
    // CustomSkin extends [Skin](Skin.html)
    super(ps, name, options);
    //console.log(this.options)

    this.$mainPanel = external_jquery_default()('<div/>', { class: 'JClicCustomMainPanel' });
    this.$gridPanel = external_jquery_default()('<div/>', { class: 'JClicGridPanel' });
    for (let i = 0; i < 9; i++)
      this.$gridPanel.append(external_jquery_default()('<div/>', { class: `JClicCell JClicCell${i + 1}` }));
    this.$mainPanel.append(this.$gridPanel);
    this.$playerCnt.detach().addClass('JClicPlayerCell').appendTo(this.$mainPanel);
    this.$div.prepend(this.$mainPanel);

    // Add buttons
    if (options.buttons) {
      Object.keys(options.buttons.button).forEach(k => {
        const k2 = k === 'about' ? 'reports' : k;
        const msg = getMsg(this.msgKeys[k2] || k2);
        this.buttons[k2] = external_jquery_default()('<button/>', { class: `JClicBtn JClicTransform Btn-${k2}`, title: msg, 'aria-label': msg, disabled: typeof this.msgKeys[k2] === 'undefined' })
          .on('click', evt => { if (ps.actions[k2]) ps.actions[k2].processEvent(evt); });
        this.$mainPanel.append(this.buttons[k2]);
      });
    }

    // Add message box
    if (options.rectangle.messages) {
      this.msgBox = new boxes_ActiveBox();
      this.msgBox.role = 'message';
      this.$msgBoxDiv = external_jquery_default()('<div/>', { class: 'JClicMsgBox' })
        .on('click', () => {
          this.msgBox.playMedia(ps);
          return false;
        });
      this.$mainPanel.append(this.$msgBoxDiv);
    }

    // Add counters
    if (false !== this.ps.options.counters && options.counters && options.counters.counter) {
      external_jquery_default().each(skins_Skin.prototype.counters, (name, _val) => {
        if (options.counters.counter[name]) {
          const msg = getMsg(name);
          this.counters[name] = new skins_Counter(name, external_jquery_default()('<div/>', { class: `JClicCounter JClicTransform Counter-${name}`, title: msg, 'aria-label': msg })
            .html('000')
            .appendTo(this.$mainPanel));
        }
      });
    }

    // Add progress animation
    if (options.progressAnimation) {
      this.$progressAnimation = external_jquery_default()('<div/>', { class: 'JClicProgressAnimation JClicTransform' });
      this.$mainPanel.append(this.$progressAnimation);
    }

  }

  /**
   * Enables or disables the `tabindex` attribute of the main buttons. Useful when a modal dialog
   * overlay is active, to avoid direct access to controls not related with the dialog.
   * @param {boolean} status - `true` to make main controls navigable, `false` otherwise
   */
  enableMainButtons(status) {
    this.$mainPanel.find('.JClicBtn').attr('tabindex', status ? '0' : '-1');
  }

  /**
   * Computes the CSS styles used by this skin in thre moodes: main, half ant twoThirds.
   * The resulting strings will be stored in `cssVariants`
   * @returns {string}
   */
  _computeStyleSheets() {
    const
      maxw = this.options.dimension.preferredSize.width,
      maxh = this.options.dimension.preferredSize.height;

    this.twoThirdsMedia = { width: maxw, height: maxh };
    this.halfMedia = {
      width: Math.round(2 * maxw / 3),
      height: Math.round(2 * maxh / 3)
    };

    // Panels:
    const
      ph0 = this.options.rectangle.frame.left,
      ph1 = ph0 + this.options.rectangle.player.left,
      ph2 = ph0 + this.options.slicer.left,
      ph3 = ph0 + this.options.slicer.right,
      ph4 = ph1 + this.options.rectangle.player.width,
      ph5 = ph0 + this.options.rectangle.frame.width,
      pv0 = this.options.rectangle.frame.top,
      pv1 = pv0 + this.options.rectangle.player.top,
      pv2 = pv0 + this.options.slicer.top,
      pv3 = pv0 + this.options.slicer.bottom,
      pv4 = pv1 + this.options.rectangle.player.height,
      pv5 = pv0 + this.options.rectangle.frame.height,
      imgElement = this.ps.project.mediaBag.getElement(this.options.image, true),
      imgUrl = imgElement.data && imgElement.data.src ? imgElement.data.src : '',
      box1 = imgElement.data ? getImgClipUrl(imgElement.data, new Rectangle(ph0, pv0, ph2 - ph0, pv2 - pv0)) : '',
      box2 = imgElement.data ? getImgClipUrl(imgElement.data, new Rectangle(ph2 - ph0, pv0, ph3 - ph2, pv2 - pv0)) : '',
      box3 = imgElement.data ? getImgClipUrl(imgElement.data, new Rectangle(ph3, pv0, ph5 - ph3, pv2 - pv0)) : '',
      box4 = imgElement.data ? getImgClipUrl(imgElement.data, new Rectangle(ph0, pv2 - pv0, ph2 - ph0, pv3 - pv2)) : '',
      box6 = imgElement.data ? getImgClipUrl(imgElement.data, new Rectangle(ph3 - ph0, pv2 - pv0, ph5 - ph3, pv3 - pv2)) : '',
      box7 = imgElement.data ? getImgClipUrl(imgElement.data, new Rectangle(ph0, pv3 - pv0, ph2 - ph0, pv5 - pv3)) : '',
      box8 = imgElement.data ? getImgClipUrl(imgElement.data, new Rectangle(ph2 - ph0, pv3 - pv0, ph3 - ph2, pv5 - pv3)) : '',
      box9 = imgElement.data ? getImgClipUrl(imgElement.data, new Rectangle(ph3, pv3 - pv0, ph5 - ph3, pv5 - pv3)) : '';

    let css = `
.ID .JClicCustomMainPanel {flex-grow:1;position:relative;background-color: ${checkColor(this.options.color.fill.value)};}
.ID .JClicGridPanel {position:absolute;width:100%;height:100%;display:grid;grid-template-columns:${ph2 - ph0}px 1fr ${ph5 - ph3}px;grid-template-rows:${pv2 - pv0}px 1fr ${pv5 - pv3}px;}
.ID .JClicCell {background-repeat:no-repeat;background-size:contain;}
.ID .JClicPlayerCell {position:absolute;top:${pv1 - pv0}px;right:${ph5 - ph4}px;bottom:${pv5 - pv4}px;left:${ph1 - ph0}px;}
.ID .JClicCell1 {background-image:url(${box1});}
.ID .JClicCell2 {background-image:url(${box2});background-repeat:repeat-x;}
.ID .JClicCell3 {background-image:url(${box3});}
.ID .JClicCell4 {background-image:url(${box4});background-repeat:repeat-y;}
.ID .JClicCell5 {}
.ID .JClicCell6 {background-image:url(${box6});background-repeat:repeat-y;}
.ID .JClicCell7 {background-image:url(${box7});}
.ID .JClicCell8 {background-image:url(${box8});background-repeat:repeat-x;}
.ID .JClicCell9 {background-image:url(${box9});}`;

    let cssHalf = `
.ID .JClicGridPanel {grid-template-columns:${Math.round((ph2 - ph0) / 2)}px 1fr ${Math.round((ph5 - ph3) / 2)}px;grid-template-rows:${Math.round((pv2 - pv0) / 2)}px 1fr ${Math.round((pv5 - pv3) / 2)}px;}
.ID .JClicPlayerCell {top:${Math.round((pv1 - pv0) / 2)}px;right:${Math.round((ph5 - ph4) / 2)}px;bottom:${Math.round((pv5 - pv4) / 2)}px;left:${Math.round((ph1 - ph0) / 2)}px;}
.ID .JClicTransform {transform: scale(0.5);}`;

    let cssTwoThirds = `
.ID .JClicGridPanel {grid-template-columns:${Math.round(2 * (ph2 - ph0) / 3)}px 1fr ${Math.round(2 * (ph5 - ph3) / 3)}px;grid-template-rows:${Math.round(2 * (pv2 - pv0) / 3)}px 1fr ${Math.round(2 * (pv5 - pv3) / 3)}px;}
.ID .JClicPlayerCell {top:${Math.round(2 * (pv1 - pv0) / 3)}px;right:${Math.round(2 * (ph5 - ph4) / 3)}px;bottom:${Math.round(2 * (pv5 - pv4) / 3)}px;left:${Math.round(2 * (ph1 - ph0) / 3)}px;}
.ID .JClicTransform {transform: scale(0.666);}`;

    // Buttons:
    if (this.options.buttons) {
      const bt = this.options.buttons;
      let wBase = 30, hBase = 30, offsetBase = {};
      if (bt.settings) {
        if (bt.settings.dimension) {
          wBase = bt.settings.dimension.width || wBase;
          hBase = bt.settings.dimension.height || hBase;
        }
        if (bt.settings.offset)
          Object.assign(offsetBase, bt.settings.offset);
      }
      Object.keys(this.options.buttons.button).forEach(k => {
        const
          btn = bt.button[k],
          k2 = k === 'about' ? 'reports' : k;
        let w = wBase, h = hBase, offset = offsetBase;
        if (btn.settings) {
          if (btn.settings.dimension) {
            w = btn.settings.dimension.width || w;
            h = btn.settings.dimension.height || h;
          }
          if (btn.settings.offset)
            offset = Object.assign({}, offsetBase, btn.settings.offset);
        }
        const
          x = btn.point.pos.left,
          xp = x < ph2 ? `left:${x}` : `right:${ph5 - x - w}`,
          xpHalf = x < ph2 ? `left:${Math.round(x / 2 - w / 4)}` : `right:${Math.round((ph5 - x - w) / 2 - w / 4)}`,
          xpTwoThirds = x < ph2 ? `left:${Math.round(2 * x / 3 - w / 6)}` : `right:${Math.round(2 * (ph5 - x - w) / 3 - w / 6)}`,
          y = btn.point.pos.top,
          yp = y < pv2 ? `top:${y}` : `bottom:${pv5 - y - h}`,
          ypHalf = y < pv2 ? `top:${Math.round(y / 2 - h / 4)}` : `bottom:${Math.round((pv5 - y - h) / 2 - h / 4)}`,
          ypTwoThirds = y < pv2 ? `top:${Math.round(2 * y / 3 - h / 6)}` : `bottom:${Math.round(2 * (pv5 - y - h) / 3 - h / 6)}`,
          xs = btn.point.source.left,
          ys = btn.point.source.top;
        css += `.ID .Btn-${k2} {position:absolute;${xp}px;${yp}px;width:${w}px;height:${h}px;background:url(${imgUrl}) !important;background-position:-${xs}px -${ys}px !important;}\n`;
        cssHalf += `.ID .Btn-${k2} {${xpHalf}px;${ypHalf}px;}\n`;
        cssTwoThirds += `.ID .Btn-${k2} {${xpTwoThirds}px;${ypTwoThirds}px;}\n`;
        if (offset.active)
          css += `.ID .Btn-${k2}:active {background-position:-${xs + offset.active.right}px -${ys + offset.active.down}px !important;}\n`;
        if (offset.over)
          css += `.ID .Btn-${k2}:hover {background-position:-${xs + offset.over.right}px -${ys + offset.over.down}px !important;}\n`;
        if (offset.disabled)
          css += `.ID .Btn-${k2}:disabled {background-position:-${xs + offset.disabled.right}px -${ys + offset.disabled.down}px !important;}\n`;
      });
    }

    // Counters:
    if (this.options.counters && this.options.counters.settings) {
      const cnt = this.options.counters;
      let wBase = 35, hBase = 20;
      if (cnt.settings.dimension && cnt.settings.dimension.counter) {
        wBase = (cnt.settings.dimension.counter.width || wBase);
        hBase = cnt.settings.dimension.counter.height || hBase;
      }
      let wLb = 37, hLb = 14;
      if (cnt.settings.dimension && cnt.settings.dimension.label) {
        wLb = (cnt.settings.dimension.label.width || wLb);
        hLb = cnt.settings.dimension.label.height || hLb;
      }
      let bColor = 'black';
      if (cnt.style && cnt.style.color && cnt.style.color.foreground)
        bColor = checkColor(cnt.style.color.foreground.value || bColor);
      let lbFntSize = hLb - 4;
      let lbFntFamily = 'Roboto';
      if (cnt.style && cnt.style.font && cnt.style.font.label) {
        lbFntSize = Math.max(8, cnt.style.font.label.size || lbFntSize);
        lbFntFamily = `${cnt.style.font.label.family || 'Roboto'},Roboto,sans-serif`;
      }

      css += `.ID .JClicCounter {font-size:${hBase - 2}px;color:${bColor}}\n`;
      Object.keys(this.options.counters.counter).forEach(k => {
        const
          counter = cnt.counter[k];
        let w = wBase, h = hBase;
        const
          x = counter.point.counter.left,
          xl = counter.point.label.left || (x - Math.round((wLb - wBase) / 2)),
          xp = x < ph2 ? `left:${x}` : `right:${ph5 - x - w}`,
          xpHalf = x < ph2 ? `left:${Math.round(x / 2 - w / 4)}` : `right:${Math.round((ph5 - x - w) / 2 - w / 4)}`,
          xpTwoThirds = x < ph2 ? `left:${Math.round(2 * x / 3 - w / 6)}` : `right:${Math.round(2 * (ph5 - x - w) / 3 - w / 6)}`,
          y = counter.point.counter.top,
          yl = counter.point.label.top || (y - hLb),
          yp = y < pv2 ? `top:${y}` : `bottom:${pv5 - y - h}`,
          ypHalf = y < pv2 ? `top:${Math.round(y / 2 - h / 4)}` : `bottom:${Math.round((pv5 - y - h) / 2 - h / 4)}`,
          ypTwoThirds = y < pv2 ? `top:${Math.round(2 * y / 3 - h / 6)}` : `bottom:${Math.round(2 * (pv5 - y - h) / 3 - h / 6)}`;
        // counter:
        css += `.ID .Counter-${k} {position:absolute;${xp}px;${yp}px;width:${w}px;height:${h}px;line-height:${h}px;}\n`;
        // label:
        css += `.ID .Counter-${k}:before {content:"${getMsg(k)}";font-size:${lbFntSize}px;font-family:${lbFntFamily};width:${wLb}px;height:${hLb}px;line-height:${hLb}px;position:absolute;top:${yl - y}px;left:${xl - x}px;}`;
        // reduced sizes:
        cssHalf += `.ID .Counter-${k} {${xpHalf}px;${ypHalf}px;}\n`;
        cssTwoThirds += `.ID .Counter-${k} {${xpTwoThirds}px;${ypTwoThirds}px;}\n`;
      });
    }

    // Progress animation:
    if (this.options.progressAnimation) {
      const pa = this.options.progressAnimation;
      let w = 30, h = 30;
      if (pa.dimension) {
        w = pa.dimension.width || w;
        h = pa.dimension.height || h;
      }
      const
        x = pa.point.pos.left,
        xp = x < ph2 ? `left:${x}` : `right:${ph5 - x - w}`,
        xpHalf = x < ph2 ? `left:${Math.round(x / 2 - w / 4)}` : `right:${Math.round((ph5 - x - w) / 2 - w / 4)}`,
        xpTwoThirds = x < ph2 ? `left:${Math.round(2 * x / 3 - w / 6)}` : `right:${Math.round(2 * (ph5 - x - w) / 3 - w / 6)}`,
        y = pa.point.pos.top,
        yp = y < pv2 ? `top:${y}` : `bottom:${pv5 - y - h}`,
        ypHalf = y < pv2 ? `top:${Math.round(y / 2 - h / 4)}` : `bottom:${Math.round((pv5 - y - h) / 2 - h / 4)}`,
        ypTwoThirds = y < pv2 ? `top:${Math.round(2 * y / 3 - h / 6)}` : `bottom:${Math.round(2 * (pv5 - y - h) / 3 - h / 6)}`,
        xs = pa.point.source.left,
        ys = pa.point.source.top;
      css += `.ID .JClicProgressAnimation {position:absolute;${xp}px;${yp}px;width:${w}px;height:${h}px;background:url(${imgUrl});background-position:-${xs}px -${ys}px;}\n`;
      cssHalf += `.ID .JClicProgressAnimation {${xpHalf}px;${ypHalf}px;}\n`;
      cssTwoThirds += `.ID .JClicProgressAnimation {${xpTwoThirds}px;${ypTwoThirds}px;}\n`;

      if (pa.frames && pa.direction) {
        const
          dx = (pa.step || w) * (pa.direction === 'right' ? 1 : pa.direction === 'left' ? -1 : 0),
          dy = (pa.step || h) * (pa.direction === 'down' ? 1 : pa.direction === 'up' ? -1 : 0);
        css += `\n@keyframes anim {100% {background-position:${(xs + dx * pa.frames) * -1}px ${(ys + dy * pa.frames) * -1}px;}}\n.ID .JClicProgressAnimation {animation: anim ${pa.frames * pa.delay}ms steps(${pa.frames}) infinite;}`;
      }
    }

    // Messages box:
    if (this.options.rectangle.messages) {
      const
        bx = this.options.rectangle.messages,
        left = ph0 + bx.left,
        right = ph5 - bx.width - bx.left - ph0,
        tb = bx.top < pv2 ? `top:${bx.top}` : `bottom:${pv5 - bx.height - bx.top}`,
        tbHalf = bx.top < pv2 ? `top:${Math.round(bx.top / 2)}` : `bottom:${Math.round((pv5 - bx.height - bx.top) / 2)}`,
        tbTwoThirds = bx.top < pv2 ? `top:${Math.round(2 * bx.top / 3)}` : `bottom:${Math.round(2 * (pv5 - bx.height - bx.top) / 3)}`;

      css += `.ID .JClicMsgBox {position:absolute;left:${left}px;right:${right}px;height:${bx.height}px;${tb}px;}`;
      cssHalf += `.ID .JClicMsgBox {left:${Math.round(left / 2)}px;right:${Math.round(right / 2)}px;height:${Math.round(bx.height / 2)}px;${tbHalf}px;}`;
      cssTwoThirds += `.ID .JClicMsgBox {left:${Math.round(2 * left / 3)}px;right:${Math.round(2 * right / 3)}px;height:${Math.round(2 * bx.height / 3)}px;${tbTwoThirds}px;}`;
    }

    // TODO: Implement status messages?

    // Store results in `cssVariants`
    this.cssVariants = {
      default: this.mainCSS + css,
      half: cssHalf,
      twoThirds: cssTwoThirds
    };
  }

  /**
   * Returns the CSS styles used by this skin. This method should be called only from
   * the `Skin` constructor, and overridded by subclasses if needed.
   * @param {string} media - A specific media size. Possible values are: 'default', 'half' and 'twoThirds'
   * @override
   * @returns {string}
   */
  _getStyleSheets(media = 'default') {
    if (!this.cssVariants)
      this._computeStyleSheets();
    return `${super._getStyleSheets(media)}${this.cssVariants[media] || ''}`;
  }

  /**
   * Sets/unsets the 'wait' state
   * @override
   * @param {boolean} status - Whether to set or unset the wait status. When `undefined`, the
   * `waitCursorCount` member is evaluated to decide if the wait state should be activated or deactivated.
   */
  setWaitCursor(status) {
    super.setWaitCursor(status);
    if (this.$progressAnimation)
      this.$progressAnimation.css('animation-play-state', this.waitCursorCount > 0 ? 'running' : 'paused');
  }
}

Object.assign(CustomSkin.prototype, {
  /**
   * Class name of this skin. It will be used as a base selector in the definition of all CSS styles.
   * @name module:skins/CustomSkin.CustomSkin#skinId
   * @override
   * @type {string} */
  skinId: 'JClicCustomSkin',
  /**
   * The name of the image file to be used as a base of this skin.
   * @name module:skins/CustomSkin.CustomSkin#image
   * @type {string} */
  image: null,
  /**
   * Styles used in this skin
   * @name module:skins/CustomSkin.CustomSkin#skinCSS
   * @override
   * @type {string} */
  mainCSS: '\
.ID .JClicPlayerCnt {margin:0;}\
.ID .JClicBtn:focus {outline:0;}\
.ID .JClicCounter {font-family:Roboto,sans-serif;text-align:center;}',
  /**
   * Specifc styles (`default`, `half` and `twoThirds`) computed at run-time,
   * based on the provided XML file
   * @name module:skins/CustomSkin.CustomSkin#cssVariants
   * @type {object} */
  cssVariants: null,
  /**
   * Key ids of currently supported buttons, associated with its helper literal
   * @name module:skins/CustomSkin.CustomSkin#msgKeys
   * @type {object} */
  msgKeys: {
    next: 'Next activity',
    prev: 'Previous activity',
    info: 'Information',
    help: 'Help',
    reports: 'Reports',
    // TODO: Implement audio on/off!
    audio: 'Audio on/off',
    reset: 'Reset activity',
  },
  /**
   * Graphic indicator of loading progress
   * @name module:skins/CustomSkin.Skin#$progressAnimation
   * @type {external:jQuery} */
  $progressAnimation: null,
});

// Register this class in the list of available skins
/* harmony default export */ const skins_CustomSkin = (skins_Skin.registerClass('custom', CustomSkin));

;// CONCATENATED MODULE: ./src/shapers/Rectangular.js
/**
 *  File    : shapers/Rectangular.js
 *  Created : 19/05/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Catalan Educational Telematic Network (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */




/**
 *
 * This is the simplest {@link module:shapers/Shaper.Shaper Shaper}. It divides the graphic object in a set of rectangular
 * shapes distributed in the specified number of rows and columns.
 * @extends module:shapers/Shaper.Shaper
 */
class Rectangular extends shapers_Shaper {
  /**
   * Rectangular constructor
   * @param {number} nx - Number of columns
   * @param {number} ny - Number of rows
   */
  constructor(nx, ny) {
    super(nx, ny);
  }

  /**
   * Builds the rectangular shapes based on the number of rows and columns
   * @override
   */
  buildShapes() {
    const
      w = 1 / this.nCols,
      h = 1 / this.nRows;
    for (let y = 0; y < this.nRows; y++) {
      for (let x = 0; x < this.nCols; x++) {
        this.shapeData[y * this.nCols + x] = new Rectangle(new Point(x * w, y * h), new Dimension(w, h));
      }
    }
    this.initiated = true;
  }
}

Object.assign(Rectangular.prototype, {
  /**
   * Overrides same flag in {@link module:/shapers/Shaper.Shaper#rectangularShapes Shaper#rectangularShapes}
   * @name module:shapers/Rectangular.Rectangular#rectangularShapes
   * @override
   * @type {boolean} */
  rectangularShapes: true,
});

// Register this class in the list of known shapers
/* harmony default export */ const shapers_Rectangular = (shapers_Shaper.registerClass('@Rectangular', Rectangular));

;// CONCATENATED MODULE: ./src/shapers/Holes.js
/**
 *  File    : shapers/Holes.js
 *  Created : 20/05/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */



/**
 * This {@link module:shapers/Shaper.Shaper Shaper} consists of a set of arbitrary shapes placed over a main rectangle that
 * acts as a enclosure.
 * The components can be of type {@link module:AWT.Rectangle}, {@link module:AWT.Ellipse} or {@link module:AWT.Path}.
 * This components have internal dimension values relative to the horizontal and vertical
 * sizes of the enclosure. Its values (always between 0 and 1) must be scaled to real sizes
 * of graphic objects.
 * @extends module:shapers/Shaper.Shaper
 */
class Holes extends shapers_Shaper {
  /**
   * Holes constructor
   * @param {number} nx - Not used
   * @param {number} ny - Not used
   */
  constructor(nx, ny) {
    super(1, 1);
    this.customShapes = true;
    this.nCols = nx;
    this.nRows = ny;
    this.showEnclosure = true;
  }

  /**
   * Shapes are already loaded by {@link module:shapers/Shaper.Shaper Shaper}, so this function just sets `initiated` to `true`
   * @override
   */
  buildShapes() {
    if (this.nCells > 0)
      this.initiated = true;
  }

  /**
   * Gets the rectangle that contains all shapes
   * @override
   * @returns {module:AWT.Rectangle}
   */
  getEnclosingShapeData() {
    return this.showEnclosure ? (this.enclosing || super.getEnclosingShapeData()) : null;
  }
}

// Register this class in the list of known shapers
/* harmony default export */ const shapers_Holes = (shapers_Shaper.registerClass('@Holes', Holes));

;// CONCATENATED MODULE: ./src/shapers/JigSaw.js
/**
 *  File    : shapers/JigSaw.js
 *  Created : 01/04/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */




/**
 *
 * This {@link module:shapers/Shaper.Shaper Shaper} returns a set of rectangular shapes with teeth and slots that fit between them.
 * @extends module:shapers/Shaper.Shaper
 */
class JigSaw extends shapers_Shaper {
  /**
   * JigSaw constructor
   * @param {number} nx - Number of columns
   * @param {number} ny - Number of rows
   */
  constructor(nx, ny) {
    super(nx, ny);
  }

  /**
   * Builds the jigsaw shapes based on the number of rows and columns
   * @override
   */
  buildShapes() {
    // Create two two-dimension arrays for storing the type of horizontal and vertical lines
    let hLineType = [], vLineType = [];
    for (let i = 0; i <= this.nRows; i++) {
      hLineType[i] = [];
      vLineType[i] = [];
    }

    for (let row = 0; row < this.nRows; row++) {
      for (let col = 0; col < this.nCols; col++) {
        hLineType[row][col] = row === 0 ? 0 : 1 + (this.randomLines ? Math.round(Math.random() * 9) : row + col) % 2;
        vLineType[row][col] = col === 0 ? 0 : 1 + (this.randomLines ? Math.round(Math.random() * 9) : col + row + 1) % 2;
        if (col === this.nCols - 1)
          vLineType[row][col + 1] = 0;
        if (row === this.nRows - 1)
          hLineType[row + 1][col] = 0;
      }
    }

    const w = 1 / this.nCols, h = 1 / this.nRows;
    for (let r = 0; r < this.nRows; r++) {
      for (let c = 0; c < this.nCols; c++) {
        const x = w * c;
        const y = h * r;
        const sd = new Path([new PathStroke('M', [x, y])]);
        this.hLine(sd, hLineType[r][c], x + 0, y + 0, w, h, false);
        this.vLine(sd, vLineType[r][c + 1], x + w, y + 0, w, h, false);
        this.hLine(sd, hLineType[r + 1][c], x + w, y + h, w, h, true);
        this.vLine(sd, vLineType[r][c], x + 0, y + h, w, h, true);
        sd.addStroke(new PathStroke('X'));
        sd.calcEnclosingRect();
        // Save the Path in `shapeData`
        this.shapeData[r * this.nCols + c] = sd;
      }
    }
    this.initiated = true;
  }

  /**
   * Adds an horizontal line to the provided path
   * @param {module:AWT.Path} sd - The Path to which the line will be added
   * @param {number} type - Type  of tooth: 0 is flat (no tooth), 1 means tooth up, and 2 means tooth down
   * @param {number} x - X coordinate of the starting point
   * @param {number} y - Y coordinate of the starting point
   * @param {number} w - Width of the piece
   * @param {number} h - Height of the piece
   * @param {boolean} inv - The line must be drawn right to left
   */
  hLine(sd, type, x, y, w, h, inv) {
    const
      kx = inv ? -1 : 1,
      ky = type === 1 ? 1 : -1;

    if (type === 0)
      // Flat line
      sd.addStroke(new PathStroke('L', [x + w * kx, y]));
    else {
      const x0 = x + (w - w * this.baseWidthFactor) / 2 * kx;
      const wb = w * this.baseWidthFactor * kx;
      // Approximation to the tooth:
      sd.addStroke(new PathStroke('L', [x0, y]));
      // The tooth:
      const hb = h * this.toothHeightFactor * ky;
      sd.addStroke(new PathStroke('L', [x0, y + hb]));
      sd.addStroke(new PathStroke('L', [x0 + wb, y + hb]));
      sd.addStroke(new PathStroke('L', [x0 + wb, y]));
      // Draw the remaining of the line
      sd.addStroke(new PathStroke('L', [x + w * kx, y]));
    }
  }

  /**
   *
   * Adds a vertical line to the provided path
   * @param {module:AWT.Path} sd - The Path to which the line will be added
   * @param {number} type - Type  of tooth: 0 is flat (no tooth), 1 means tooth right, and 2 means tooth left
   * @param {number} x - X coordinate of the starting point
   * @param {number} y - Y coordinate of the starting point
   * @param {number} w - Width of the piece
   * @param {number} h - Height of the piece
   * @param {boolean} inv - The line must be drawn bottom to top
   */
  vLine(sd, type, x, y, w, h, inv) {
    const
      ky = inv ? -1 : 1,
      kx = type === 1 ? 1 : -1;

    if (type === 0) {
      // Flat line
      sd.addStroke(new PathStroke('L', [x, y + h * ky]));
    } else {
      const y0 = y + (h - h * this.baseWidthFactor) / 2 * ky;
      const hb = h * this.baseWidthFactor * ky;
      // Approximation to the tooth:
      sd.addStroke(new PathStroke('L', [x, y0]));
      // The tooth:
      const wb = w * this.toothHeightFactor * kx;
      sd.addStroke(new PathStroke('L', [x + wb, y0]));
      sd.addStroke(new PathStroke('L', [x + wb, y0 + hb]));
      sd.addStroke(new PathStroke('L', [x, y0 + hb]));
      // Draw the remaining line
      sd.addStroke(new PathStroke('L', [x, y + h * ky]));
    }
  }
}

// Register this class in the list of known shapers
/* harmony default export */ const shapers_JigSaw = (shapers_Shaper.registerClass('@JigSaw', JigSaw));

;// CONCATENATED MODULE: ./src/shapers/TriangularJigSaw.js
/**
 *  File    : shapers/TriangularJigSaw.js
 *  Created : 25/05/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */





/**
 * This {@link module:shapers/Shaper.Shaper Shaper} returns a set of rectangular shapes with triangular teeth and slots that
 * fit between them.
 * @extends module:shapers/JigSaw.JigSaw
 */
class TriangularJigSaw extends shapers_JigSaw {
  /**
   * TriangularJigSaw constructor
   * @param {number} nx - Number of columns
   * @param {number} ny - Number of rows
   */
  constructor(nx, ny) {
    super(nx, ny);
  }

  /**
   * Overrides {@link module:shapers/JigSaw.JigSaw#hLine}
   * @override
   * @param {module:AWT.Path} sd - The Path to which the line will be added
   * @param {number} type - Type  of tooth: 0 is flat (no tooth), 1 means tooth up, and 2 means tooth down
   * @param {number} x - X coordinate of the starting point
   * @param {number} y - Y coordinate of the starting point
   * @param {number} w - Width of the piece
   * @param {number} h - Height of the piece
   * @param {boolean} inv - The line must be drawn right to left
   */
  hLine(sd, type, x, y, w, h, inv) {
    const
      kx = inv ? -1 : 1,
      ky = type === 1 ? 1 : -1;

    if (type === 0)
      // Flat line
      sd.addStroke(new PathStroke('L', [x + w * kx, y]));
    else {
      const x0 = x + (w - w * this.baseWidthFactor) / 2 * kx;
      const wb = w * this.baseWidthFactor * kx;
      // Approximation to the tooth:
      sd.addStroke(new PathStroke('L', [x0, y]));
      // This is the tooth:
      const hb = h * this.toothHeightFactor * ky;
      sd.addStroke(new PathStroke('L', [x0 + wb / 2, y + hb]));
      sd.addStroke(new PathStroke('L', [x0 + wb, y]));
      // Draw the remaining line
      sd.addStroke(new PathStroke('L', [x + w * kx, y]));
    }
  }

  /**
   * Overrides {@link module:shapers/JigSaw.JigSaw#vLine}
   * @override
   * @param {module:AWT.Path} sd - The Path to which the line will be added
   * @param {number} type - Type  of tooth: 0 is flat (no tooth), 1 means tooth right, and 2 means tooth left
   * @param {number} x - X coordinate of the starting point
   * @param {number} y - Y coordinate of the starting point
   * @param {number} w - Width of the piece
   * @param {number} h - Height of the piece
   * @param {boolean} inv - The line must be drawn bottom to top
   */
  vLine(sd, type, x, y, w, h, inv) {
    const
      ky = inv ? -1 : 1,
      kx = type === 1 ? 1 : -1;

    if (type === 0)
      // Flat line
      sd.addStroke(new PathStroke('L', [x, y + h * ky]));
    else {
      const
        y0 = y + (h - h * this.baseWidthFactor) / 2 * ky,
        hb = h * this.baseWidthFactor * ky;

      // Approximation to the tooth:
      sd.addStroke(new PathStroke('L', [x, y0]));
      // This is the tooth:
      const wb = w * this.toothHeightFactor * kx;
      sd.addStroke(new PathStroke('L', [x + wb, y0 + hb / 2]));
      sd.addStroke(new PathStroke('L', [x, y0 + hb]));
      // Draw the remaining line
      sd.addStroke(new PathStroke('L', [x, y + h * ky]));
    }
  }
}

// Register this class in the list of known shapers
/* harmony default export */ const shapers_TriangularJigSaw = (shapers_Shaper.registerClass('@TriangularJigSaw', TriangularJigSaw));

;// CONCATENATED MODULE: ./src/shapers/ClassicJigSaw.js
/**
 *  File    : shapers/ClassicJigSaw.js
 *  Created : 25/05/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */





/**
 * This is the classic {@link module:shapers/JigSaw.JigSaw JigSaw} {@link module:shapers/Shaper.Shaper Shaper} used in puzzle toys, where teeth and slots
 * are shaped by Bézier curves.
 * @extends module:shapers/JigSaw.JigSaw
 */
class ClassicJigSaw extends shapers_JigSaw {
  /**
   * ClassicJigSaw constructor
   * @param {number} nx - Number of columns
   * @param {number} ny - Number of rows
   */
  constructor(nx, ny) {
    super(nx, ny);
  }

  /**
   * Overrides {@link module:shapers/JigSaw.JigSaw#hLine}
   * @override
   * @param {module:AWT.Path} sd - The Path to which the line will be added
   * @param {number} type - Type  of tooth: 0 is flat (no tooth), 1 means tooth up, and 2 means tooth down
   * @param {number} x - X coordinate of the starting point
   * @param {number} y - Y coordinate of the starting point
   * @param {number} w - Width of the piece
   * @param {number} h - Height of the piece
   * @param {boolean} inv - The line must be drawn right to left
   */
  hLine(sd, type, x, y, w, h, inv) {
    const
      kx = inv ? -1 : 1,
      ky = type === 1 ? 1 : -1;

    if (type === 0)
      // Flat line
      sd.addStroke(new PathStroke('L', [x + w * kx, y]));
    else {
      const
        x0 = x + (w - w * this.baseWidthFactor) / 2 * kx,
        wb = w * (this.baseWidthFactor / 12) * kx;

      // Approximation to the tooth:
      sd.addStroke(new PathStroke('L', [x0, y]));
      // This is the tooth:
      const hb = h * this.toothHeightFactor * ky / 8;
      sd.addStroke(new PathStroke('B', [x0 + 4 * wb, y, x0 + 6 * wb, y - hb, x0 + 4 * wb, y - 3 * hb]));
      sd.addStroke(new PathStroke('B', [x0 + 2 * wb, y - 5 * hb, x0 + 10 * wb, y - 5 * hb, x0 + 8 * wb, y - 3 * hb]));
      sd.addStroke(new PathStroke('B', [x0 + 6 * wb, y - 1 * hb, x0 + 8 * wb, y, x0 + 12 * wb, y]));
      // Draw the remaining line
      sd.addStroke(new PathStroke('L', [x + w * kx, y]));
    }
  }

  /**
   * Overrides {@link module:shapers/JigSaw.JigSaw#vLine}
   * @override
   * @param {module:AWT.Path} sd - The Path to which the line will be added
   * @param {number} type - Type  of tooth: 0 is flat (no tooth), 1 means tooth right, and 2 means tooth left
   * @param {number} x - X coordinate of the starting point
   * @param {number} y - Y coordinate of the starting point
   * @param {number} w - Width of the piece
   * @param {number} h - Height of the piece
   * @param {boolean} inv - The line must be drawn bottom to top
   */
  vLine(sd, type, x, y, w, h, inv) {
    const
      ky = inv ? -1 : 1,
      kx = type === 1 ? 1 : -1;

    if (type === 0)
      // Flat line
      sd.addStroke(new PathStroke('L', [x, y + h * ky]));
    else {
      const
        y0 = y + (h - h * this.baseWidthFactor) / 2 * ky,
        hb = h * this.baseWidthFactor / 12 * ky;

      // Approximation to the tooth:
      sd.addStroke(new PathStroke('L', [x, y0]));
      // This is the tooth:
      const wb = w * this.toothHeightFactor * kx / 8;
      sd.addStroke(new PathStroke('B', [x, y0 + 4 * hb, x - wb, y0 + 6 * hb, x - 3 * wb, y0 + 4 * hb]));
      sd.addStroke(new PathStroke('B', [x - 5 * wb, y0 + 2 * hb, x - 5 * wb, y0 + 10 * hb, x - 3 * wb, y0 + 8 * hb]));
      sd.addStroke(new PathStroke('B', [x - 1 * wb, y0 + 6 * hb, x, y0 + 8 * hb, x, y0 + 12 * hb]));
      // Draw the remaining line
      sd.addStroke(new PathStroke('L', [x, y + h * ky]));
    }
  }
}

Object.assign(ClassicJigSaw.prototype, {
  /**
   * ClassicJigSaw needs a biggest base width
   * @name module:shapers/ClassicJigSaw.ClassicJigSaw#baseWidthFactor
   * @type {number} */
  baseWidthFactor: 3.0 / 4,
  /**
   * ClassicJigSaw needs a biggest base height factor
   * @name module:shapers/ClassicJigSaw.ClassicJigSaw#toothHeightFactor
   * @type {number} */
  toothHeightFactor: 3.0 / 5,
});

// Register this class in the list of known shapers
/* harmony default export */ const shapers_ClassicJigSaw = (shapers_Shaper.registerClass('@ClassicJigSaw', ClassicJigSaw));

;// CONCATENATED MODULE: ./src/automation/arith/Arith.js
/**
 *  File    : automation/arith/Arith.js
 *  Created : 28/05/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */

/* global Intl */





//
// Miscellaneous constants used by Arith:
const
  NMAXLOOPS = 60,
  OPSTR = ['+', '-', String.fromCharCode(215), ':'],
  RES = -12345,
  // Use comma as a decimal separator, based on current locale settings
  // See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl
  DOTASCOMMA = Intl && Intl.NumberFormat().format(1.1).indexOf(',') > 0;

/**
 * Arith provides randomly generated mental arithmetics operations, ready to be used in JClic activities.
 *
 * The operations can be additions, subtractions, multiplications or divides. The unknown of these
 * operations can be the result of the operation (`A op B = ?`), any of the two operators
 * (`A op ? = C` or `? op B = C`) or also the operator itself (`A ? B = C`).
 * @extends module:automation/AutoContentProvider.AutoContentProvider
 */
class Arith extends automation_AutoContentProvider {
  /**
   * Arith constructor
   */
  constructor() {
    super();
    this.className = '@arith.Arith';
    this.numericContent = true;
    this.opA = new Arith.Operator();
    this.opB = new Arith.Operator();
  }

  /**
   * Formats the number with a fixed number of decimals, optionally filling the result with leading
   * zeroes to have a fixed number of digits.
   * @param {number} val - The value to format
   * @param {number} dec - Number of decimals
   * @param {number} pre - Minimal number of digits before dot.
   * @returns {string}
   */
  static DecFormat(val, dec, pre) {
    let result = val.toFixed(dec);
    if (pre) {
      let n = result.indexOf('.');
      if (n < 0)
        n = result.length;
      for (; n < pre; n++)
        result = `0${result}`;
    }
    return result;
  }

  /**
   * Loads the object settings from a specific JQuery XML element
   * @override
   * @param {external:jQuery} $xml - The XML element to parse
   */
  setProperties($xml) {
    $xml.children().each((_n, child) => {
      const $node = external_jquery_default()(child);
      let xNum = '';
      switch (child.nodeName) {
        case 'operand':
          switch ($node.attr('id')) {
            case 'A':
              this.opA.setProperties($node);
              break;
            case 'B':
              this.opB.setProperties($node);
              break;
          }
          break;
        case 'operations':
          this.use_add = getBoolean($node.attr('plus'));
          this.use_subst = getBoolean($node.attr('minus'));
          this.use_mult = getBoolean($node.attr('multiply'));
          this.use_div = getBoolean($node.attr('divide'));
          break;
        case 'unknown':
          this.exp_abx = getBoolean($node.attr('result'));
          this.exp_xbc = getBoolean($node.attr('first'));
          this.exp_axc = getBoolean($node.attr('last'));
          this.exp_axbc = getBoolean($node.attr('operand'));
          this.exp_caxb = getBoolean($node.attr('inverse'));
          break;
        case 'result':
          xNum = $node.attr('from');
          this.resultLimInf = getNumber(xNum === 'x' ? 0 : xNum, this.resultLimInf);
          xNum = $node.attr('to');
          this.resultLimSup = getNumber(xNum === 'x' ? 0 : xNum, this.resultLimSup);
          this.resultCarry = getBoolean($node.attr('notCarry'), this.resultCarry);
          this.resultNoDup = !getBoolean($node.attr('duplicates'), !this.resultNoDup);
          let s = $node.attr('order');
          this.resultOrder = s === 'ascending' ? 'SORTASC' : s === 'descending' ? 'SORTDESC' : 'NOSORT';
          s = $node.attr('condition');
          this.opCond = s === 'firstBig' ? 'AGB' : s === 'lastBig' ? 'BGA' : 'INDIF';
          break;
      }
    });
    return this;
  }

  /**
   * Gets a object with the basic attributes needed to rebuild this instance excluding functions,
   * parent references, constants and also attributes retaining the default value.
   * The resulting object is commonly usued to serialize elements in JSON format.
   * @returns {object} - The resulting object, with minimal attrributes
   */
  getAttributes() {
    return getAttr(this, [
      'className',
      'opA', 'opB', // Operator
      'use_add', 'use_subst', 'use_mult', 'use_div',
      'exp_abx|true', 'exp_axc|false', 'exp_xbc|false', 'exp_axbc|false', 'exp_caxb|false',
      'resultLimInf|0', 'resultLimSup|9999', 'resultCarry|false', 'resultNoDup|false', 'resultOrder|NOSORT',
      'opCond|INDIF'
    ]);
  }

  /**
   * Reads the properties of this Arith object from a dataset
   * @param {object} data - The data object to be parsed
   * @returns {object}
   */
  setAttributes(data) {
    return setAttr(this, data, [
      'className',
      { key: 'opA', fn: Arith.Operator },
      { key: 'opB', fn: Arith.Operator },
      'use_add', 'use_subst', 'use_mult', 'use_div',
      'exp_abx', 'exp_axc', 'exp_xbc', 'exp_axbc', 'exp_caxb',
      'resultLimInf', 'resultLimSup', 'resultCarry', 'resultNoDup', 'resultOrder',
      'opCond',
    ]);
  }

  /**
   * Fills the `n` parameter (an {@link module:automation/arith/Arith.Num Num}) with a value in accordance with the
   * specifications of `op` (an {@link module:automation/arith/Arith.Operator Operator}), between two limits.
   * @param {module:automation/arith/Arith.Num} n - The number
   * @param {module:automation/arith/Arith.Operator} op - The operator
   * @param {number} limInf2 - Lower limit
   * @param {number} limSup2 - Upper limit
   * @returns {boolean} - `true` if all was OK
   */
  genNum(n, op, limInf2, limSup2) {
    let solved = false;
    n.c = op.numDec;
    const exp = n.c === 0 ? 1 : n.c === 1 ? 10 : 100;

    let ls = op.limSup;
    if (limSup2 !== RES && limSup2 < ls)
      ls = limSup2;
    let li = op.limInf;
    if (limInf2 !== RES && limInf2 > li)
      li = limInf2;

    if (op.fromList > 0) {
      n.vf = op.lst[Math.floor(Math.random() * op.fromList)];
      solved = true;
    }
    if (!solved) {
      const r = Math.floor(Math.random() * 100);
      if (op.wZero && r <= 10) {
        n.vf = 0;
        solved = true;
      } else if (op.wOne && r > 10 && r <= 20) {
        n.vf = 1;
        solved = true;
      } else if (op.wMinusOne && r > 20 && r <= 30) {
        n.vf = -1;
        solved = true;
      }
    }
    if (!solved) {
      if (li > ls) {
        const k = li;
        li = ls;
        ls = k;
      }
      let rang = Math.floor(ls - li + 1);
      if (rang < 0)
        rang = 1;
      let v = (Math.floor(Math.random() * rang) + li) * exp;
      if (exp > 1)
        v += Math.floor(Math.random() * exp);
      n.vf = v / exp;
    }
    return true;
  }

  /**
   * Fills the provided {@link module:automation/arith/Arith.Operator Operator} with real values
   * @param {module:automation/arith/Arith.Operator} o - The operator to use to generate the operation
   * @returns {boolean} - `true` if all was OK
   */
  genOp(o) {
    let i, ri2, rs2, q, va, vb, bufa, bufb;
    const
      ops = [],
      rlinf = this.resultLimInf,
      rlsup = this.resultLimSup;

    let nops = 0;
    if (this.use_add)
      ops[nops++] = 'SUM';
    if (this.use_subst)
      ops[nops++] = 'REST';
    if (this.use_mult)
      ops[nops++] = 'MULT';
    if (this.use_div)
      ops[nops++] = 'DIV';

    const op = ops[Math.floor(Math.random() * nops)];
    switch (op) {
      case 'SUM':
        for (i = 0; i < NMAXLOOPS; i++) {
          this.genNum(o.numA, this.opA, this.RES, rlsup);
          ri2 = o.numA.vf < rlinf ? rlinf - Math.floor(o.numA.vf) : this.RES;
          rs2 = rlsup - Math.floor(o.numA.vf);
          switch (this.opCond) {
            case 'AGB':
              if (rs2 === this.RES || rs2 > o.numA.vf)
                rs2 = Math.floor(o.numA.vf);
              break;
            case 'BGA':
              if (ri2 === this.RES || ri2 < o.numA.vf)
                ri2 = Math.floor(o.numA.vf);
              break;
          }
          this.genNum(o.numB, this.opB, ri2, rs2);
          o.numR.vf = o.numA.vf + o.numB.vf;
          if (o.numR.vf >= rlinf && o.numR.vf <= rlsup)
            break;
        }
        o.numR.c = o.numA.c > o.numB.c ? o.numA.c : o.numB.c;
        o.op = 0;
        if (this.resultCarry && o.numA.vf > 0 && o.numB.vf > 0) {
          q = o.numR.c === 2 ? 100 : o.numR.c === 1 ? 10 : 1;

          bufa = Arith.DecFormat(Math.floor(o.numA.vf * q + 0.5), 0, 10).split('');
          bufb = Arith.DecFormat(Math.floor(o.numB.vf * q + 0.5), 0, 10).split('');
          for (i = 0; i < 10; i++)
            if (bufa[i] !== '0' || bufb[i] !== '0')
              break;
          for (; i < 10; i++) {
            va = parseInt(bufa[i]);
            vb = parseInt(bufb[i]);
            if (va + vb < 10)
              continue;
            while (va + vb > 9) {
              if (va > vb)
                va = va > 0 ? Math.floor(Math.random() * va) : 0;
              else
                vb = vb > 0 ? Math.floor(Math.random() * vb) : 0;
            }
            bufa[i] = va.toFixed(0);
            bufb[i] = vb.toFixed(0);
          }

          o.numA.vf = parseInt(bufa.join('')) / q;
          o.numB.vf = parseInt(bufb.join('')) / q;
          // Corrected 2019/02/11: Factors should be multiplied by 'q'!
          // INCORRECT: o.numR.vf = Math.floor(o.numA.vf + o.numB.vf + 0.5) / q
          o.numR.vf = Math.floor(o.numA.vf * q + o.numB.vf * q + 0.5) / q;
        }
        break;

      case 'REST':
        for (i = 0; i < NMAXLOOPS; i++) {
          this.genNum(o.numA, this.opA, rlinf, this.RES);
          ri2 = o.numA.vf > rlsup ? Math.floor(o.numA.vf - rlsup) : this.RES;
          rs2 = Math.floor(o.numA.vf - rlinf);
          switch (this.opCond) {
            case 'AGB':
              if (rs2 === this.RES || rs2 > o.numA.vf)
                rs2 = Math.floor(o.numA.vf);
              break;
            case 'BGA':
              if (ri2 === this.RES || ri2 < o.numA.vf)
                ri2 = Math.floor(o.numA.vf);
              break;
          }
          this.genNum(o.numB, this.opB, ri2, rs2);
          o.numR.vf = o.numA.vf - o.numB.vf;
          if (o.numR.vf >= rlinf && o.numR.vf <= rlsup)
            break;
        }
        o.numR.c = o.numA.c > o.numB.c ? o.numA.c : o.numB.c;
        o.op = 1;
        if (this.resultCarry && o.numA.vf > 0 && o.numB.vf > 0 && o.numA.vf >= o.numB.vf) {
          q = o.numR.c === 2 ? 100 : o.numR.c === 1 ? 10 : 1;
          bufa = Arith.DecFormat(Math.floor(o.numA.vf * q + 0.5), 0, 10).split('');
          bufb = Arith.DecFormat(Math.floor(o.numB.vf * q + 0.5), 0, 10).split('');
          for (i = 0; i < 10; i++)
            if (bufb[i] !== '0')
              break;
          for (; i < 10; i++) {
            va = parseInt(bufa[i]);
            vb = parseInt(bufb[i]);
            if (va >= vb)
              continue;
            vb = va > 0 ? Math.floor(Math.random() * va) : 0;
            bufb[i] = vb.toFixed(0);
          }

          o.numA.vf = parseInt(bufa.join('')) / q;
          o.numB.vf = parseInt(bufb.join('')) / q;
          // Corrected 2019/02/11: Factors should be multiplied by 'q'!
          // o.numR.vf = Math.floor(o.numA.vf - o.numB.vf + 0.5) / q
          o.numR.vf = Math.floor(o.numA.vf * q - o.numB.vf * q + 0.5) / q;
        }
        break;

      case 'MULT':
        for (i = 0; i < NMAXLOOPS; i++) {
          this.genNum(o.numA, this.opA, this.RES, this.RES);
          ri2 = this.opB.limInf;
          rs2 = this.opB.limSup;
          switch (this.opCond) {
            case 'AGB':
              if (rs2 > o.numA.vf)
                rs2 = Math.floor(o.numA.vf);
              break;
            case 'BGA':
              if (ri2 < o.numA.vf)
                ri2 = Math.floor(o.numA.vf);
              break;
          }
          this.genNum(o.numB, this.opB, ri2, rs2);
          o.numR.vf = o.numA.vf * o.numB.vf;
          if (o.numR.vf >= rlinf && o.numR.vf <= rlsup)
            break;
        }
        o.numR.c = o.numA.c + o.numB.c;
        o.op = 2;
        break;

      case 'DIV':
        for (i = 0; i < NMAXLOOPS; i++) {
          this.genNum(o.numA, this.opA, this.RES, this.RES);
          ri2 = this.opB.limInf;
          rs2 = this.opB.limSup;
          switch (this.opCond) {
            case 'AGB':
              if (rs2 > o.numA.vf)
                rs2 = Math.floor(o.numA.vf);
              break;
            case 'BGA':
              if (ri2 < o.numA.vf)
                ri2 = Math.floor(o.numA.vf);
              break;
          }
          this.genNum(o.numB, this.opB, ri2, rs2);
          if (o.numB.vf !== 0 &&
            Math.abs(o.numA.vf) >= Math.abs(o.numB.vf) &&
            (o.numR.vf = o.numA.vf / o.numB.vf) >= rlinf &&
            o.numR.vf <= rlsup)
            break;
        }
        if (o.numB.vf === 0)
          o.numB.vf = 1;
        o.numR.vf = o.numA.vf / o.numB.vf;
        i = o.numA.c - o.numB.c;
        q = Math.pow(10, i);
        o.numA.vf *= q;
        o.numR.vf *= q;
        o.numR.vf = Math.floor(o.numR.vf);
        o.numA.vf = o.numR.vf * o.numB.vf;
        o.numA.vf /= q;
        o.numR.vf /= q;
        o.numR.c = i > 0 ? i : 0;
        o.op = 3;
        break;

      default:
        return false;
    }
    return true;
  }

  /**
   * Fills the provided ActiveBagContentKit with randomly generated operations
   * @override
   * @param {module:automation/AutoContentProvider.ActiveBagContentKit} kit - The composite object to be filled with data.
   * @returns {boolean} - `true` if all was OK
   */
  process(kit) {
    let nRows = kit.nRows,
      nCols = kit.nCols,
      content = kit.content, //Array of ActiveBagContent
      useIds = kit.useIds,
      i, j, k,
      o, op = [], // Array of Arith.Operation
      tipus = [],
      numTipus, tipX,
      tipInv = this.exp_caxb,
      va = '', vb = '', vc = '', operator = '',
      stra = [], strb = [], strc = [],
      nColsB = nCols, nRowsB = nRows,
      nCells = nRows * nCols,
      ass = null;

    if (nRows <= 0 || nCols <= 0 ||
      content === null || content.length < 1 || content[0] === null)
      return false;

    if (nCells < 2)
      return false;

    numTipus = 0;
    if (this.exp_abx)
      tipus[numTipus++] = 'ABX';
    if (this.exp_axc)
      tipus[numTipus++] = 'AXC';
    if (this.exp_xbc)
      tipus[numTipus++] = 'XBC';
    if (this.exp_axbc)
      tipus[numTipus++] = 'AXBC';
    if (numTipus === 0)
      return false;

    for (i = 0; i < nCells; i++) {
      o = new Arith.Operation();
      for (j = 0; j < NMAXLOOPS; j++) {
        this.genOp(o);
        if (this.resultNoDup) {
          for (k = 0; k < i; k++) {
            if (o.numR.vf === op[k].numR.vf)
              break;
          }
          if (k === i)
            break;
        } else
          break;
      }
      op[i] = o;
    }

    if (this.resultOrder !== 0) {
      for (i = nCells - 1; i > 0; i--) {
        for (j = 0; j < i; j++) {
          if (this.resultOrder === 'SORTASC' && op[j].numR.vf > op[j + 1].numR.vf ||
            this.resultOrder === 'SORTDESC' && op[j].numR.vf < op[j + 1].numR.vf) {
            // Switch values
            o = op[j];
            op[j] = op[j + 1];
            op[j + 1] = o;
          }
        }
      }
    }

    for (i = 0; i < nCells; i++) {
      tipX = tipus[Math.floor(Math.random() * numTipus)];
      va = Arith.DecFormat(op[i].numA.vf, op[0].numA.c);
      vb = Arith.DecFormat(op[i].numB.vf, op[0].numB.c);
      vc = Arith.DecFormat(op[i].numR.vf, op[0].numR.c);
      operator = OPSTR[op[i].op];

      // Use the special blank space ASCII 160 (\xA0) instead of regular blank spaces

      if (tipInv)
        strc[i] = `${vc}\xA0=\xA0${va}\xA0${operator}\xA0${vb}`;
      else
        strc[i] = `${va}\xA0${operator}\xA0${vb}\xA0=\xA0${vc}`;

      switch (tipX) {
        case 'AXC':
          strb[i] = vb;
          stra[i] = tipInv ? `${vc}\xA0=\xA0${va}\xA0${operator}\xA0?` : `${va}\xA0${operator}\xA0?\xA0=\xA0${vc}`;
          break;

        case 'XBC':
          strb[i] = va;
          stra[i] = tipInv ? `${vc}\xA0=\xA0?\xA0${operator}\xA0${vb}` : `?\xA0${operator}\xA0${vb}\xA0=\xA0${vc}`;
          break;

        case 'AXBC':
          strb[i] = operator;
          stra[i] = tipInv ? `${vc}\xA0=\xA0${va}\xA0?\xA0${vb}` : `${va}\xA0?\xA0${vb}\xA0=\xA0${vc}`;
          break;

        default:
          strb[i] = vc;
          stra[i] = tipInv ? `?\xA0=\xA0${va}\xA0${operator}\xA0${vb}` : `${va}\xA0${operator}\xA0${vb}\xA0=`;
          break;
      }
    }

    if (useIds) {
      ass = [];
      let strbx = [];
      k = 0;
      for (i = 0; i < nCells; i++) {
        for (j = 0; j < k; j++)
          if (strb[i] === strbx[j])
            break;
        if (j === k) {
          strbx[k] = strb[i];
          ass[i] = k;
          k++;
        } else
          ass[i] = j;
      }

      strb = [];
      for (i = 0; i < k; i++)
        strb[i] = strbx[i];

      if (nRowsB * nColsB !== k) {
        let distH = false;
        switch (k) {
          case 6:
            nRowsB = distH ? 2 : 3;
            nColsB = distH ? 3 : 2;
            break;

          case 8:
            nRowsB = distH ? 2 : 4;
            nColsB = distH ? 4 : 2;
            break;

          case 9:
            nRowsB = 3;
            nColsB = 3;
            break;

          case 10:
            nRowsB = distH ? 2 : 5;
            nColsB = distH ? 5 : 2;
            break;

          case 12:
            nRowsB = distH ? 3 : 4;
            nColsB = distH ? 4 : 3;
            break;

          case 14:
            nRowsB = distH ? 2 : 7;
            nColsB = distH ? 7 : 2;
            break;

          case 15:
            nRowsB = distH ? 3 : 5;
            nColsB = distH ? 3 : 5;
            break;

          case 16:
            nRowsB = 4;
            nColsB = 4;
            break;

          case 18:
            nRowsB = distH ? 6 : 3;
            nColsB = distH ? 3 : 6;
            break;

          case 20:
            nRowsB = distH ? 4 : 5;
            nColsB = distH ? 5 : 4;
            break;

          default:
            nRowsB = distH ? 1 : k;
            nColsB = distH ? k : 1;
            break;
        }
      }
    }

    // Added 2019/02/11
    // Use comma instead of dot for decimal separator, accordingly to current locale
    if (DOTASCOMMA) {
      function replaceDot(s) { return s.replace(/\./g, ','); }
      stra = stra.map(replaceDot);
      strb = strb.map(replaceDot);
      strc = strc.map(replaceDot);
    }

    content[0].setTextContent(stra, nCols, nRows);
    if (ass !== null)
      content[0].setIds(ass);
    if (content.length > 1 && content[1] !== null) {
      content[1].setTextContent(strb, nColsB, nRowsB);
      content[1].getShaper().reset(nColsB, nRowsB);
    }
    if (content.length > 2 && content[2] !== null)
      content[2].setTextContent(strc, nCols, nRows);

    return true;
  }
}

Object.assign(Arith.prototype, {
  //
  // Operations use two operators:
  /**
   * First operator
   * @name module:automation/arith/Arith.Arith#opA
   * @type {module:automation/arith/Arith.Operator} */
  opA: null,
  /**
   * Second operator
   * @name module:automation/arith/Arith.Arith#opB
   * @type {module:automation/arith/Arith.Operator} */
  opB: null,
  /**
   * Allow additions
   * @name module:automation/arith/Arith.Arith#use_add
   * @type {boolean} */
  use_add: true,
  /**
   * Allow subtractions
   * @name module:automation/arith/Arith.Arith#use_subst
   * @type {boolean} */
  use_subst: false,
  /**
   * Allow multiplications
   * @name module:automation/arith/Arith.Arith#use_mult
   * @type {boolean} */
  use_mult: false,
  /**
   * Allow divides
   * @name module:automation/arith/Arith.Arith#use_div
   * @type {boolean} */
  use_div: false,
  /**
   * Allow expressions of type `A op B = X`
   * @name module:automation/arith/Arith.Arith#exp_abx
   * @type {boolean} */
  exp_abx: true,
  /**
   * Allow expressions of type `A op X = C`
   * @name module:automation/arith/Arith.Arith#exp_axc
   * @type {boolean} */
  exp_axc: false,
  /**
   * Allow expressions of type `X op B = C`
   * @name module:automation/arith/Arith.Arith#exp_xbc
   * @type {boolean} */
  exp_xbc: false,
  /**
   * Allow expressions of type `A x B = C`
   * @name module:automation/arith/Arith.Arith#exp_axbc
   * @type {boolean} */
  exp_axbc: false,
  /**
   * Allow inverse expressions, like `C = A op B`
   * @name module:automation/arith/Arith.Arith#exp_caxb
   * @type {boolean} */
  exp_caxb: false,
  /**
   * Lower limit of the result
   * @name module:automation/arith/Arith.Arith#resultLimInf
   * @type {number} */
  resultLimInf: 0,
  /**
   * Upper limit of the result
   * @name module:automation/arith/Arith.Arith#resultLimSup
   * @type {number} */
  resultLimSup: 9999,
  /**
   * Allow carry operations
   * @see {@link https://en.wikipedia.org/wiki/Carry_(arithmetic)}
   * @name module:automation/arith/Arith.Arith#resultCarry
   * @type {boolean} */
  resultCarry: false,
  /**
   * Avoid operations with the same result
   * @name module:automation/arith/Arith.Arith#resultNoDup
   * @type {boolean} */
  resultNoDup: false,
  /**
   * Type of sorting of results. Possible values are: 'NOSORT', 'SORTASC' and 'SORTDESC'
   * @name module:automation/arith/Arith.Arith#resultOrder
   * @type {string} */
  resultOrder: 'NOSORT',
  /**
   * Sorting of the operands in commutative operations. Possible values are: 'AGB' (_A greater than B_),
   * 'BGA' (_B greater tan A_) and 'INDIF' (default)
   * @name module:automation/arith/Arith.Arith#opCond
   * @type {string} */
  opCond: 'INDIF',
});

/**
 * Operator is an Utility class used by Arith to encapsulate the properties and methods related
 * to the members of the operations.
 */
Arith.Operator = class {
  constructor() {
  }

  /**
   * Loads Operator settings from a specific JQuery XML element
   * @param {external:jQuery} $xml - The XML element to parse
   */
  setProperties($xml) {
    // Read attributes
    attrForEach($xml.get(0).attributes, (name, val) => {
      switch (name) {
        case 'decimals':
          this.numDec = Number(val);
          break;

        case 'values':
          this.lst = val.split(' ').map(v => Number(v));
          this.fromList = this.lst.length;
          break;

        case 'from':
          this.limInf = Number(val === 'x' ? 0 : val);
          break;

        case 'to':
          this.limSup = Number(val === 'x' ? 0 : val);
          break;
      }

      $xml.children().each((_n, child) => {
        const $node = external_jquery_default()(child);
        switch (child.nodeName) {
          case 'include':
            this.wZero = getBoolean($node.attr('zero'));
            this.wOne = getBoolean($node.attr('one'));
            this.wMinusOne = getBoolean($node.attr('minusOne'));
            break;
        }
      });
    });
    return this;
  }

  /**
   * Gets a object with the basic attributes needed to rebuild this instance excluding functions,
   * parent references, constants and also attributes retaining the default value.
   * The resulting object is commonly usued to serialize elements in JSON format.
   * @returns {object} - The resulting object, with minimal attrributes
   */
  getAttributes() {
    return getAttr(this, [
      'limInf', 'limSup',
      'numDec|0',
      'wZero|false', 'wOne|false', 'wMinusOne|false',
      'fromList|0', 'lst',
    ]);
  }

  /**
   * Reads the properties of this operator from a dataset
   * @param {object} data - The data object to be parsed
   * @returns {module:automation/arith/Arith.Arith}
   */
  setAttributes(data) {
    return setAttr(this, data, [
      'limInf', 'limSup',
      'numDec',
      'wZero', 'wOne', 'wMinusOne',
      'fromList', 'lst',
    ]);
  }
};

Object.assign(Arith.Operator.prototype, {
  /**
   * Lower limit
   * @name module:automation/arith/Arith.Arith.Operator#limInf
   * @type {number} */
  limInf: 0,
  /**
   * Upper limit
   * @name module:automation/arith/Arith.Arith.Operator#limSup
   * @type {number} */
  limSup: 10,
  /**
   * Number of decimal places
   * @name module:automation/arith/Arith.Arith.Operator#numDec
   * @type {number} */
  numDec: 0,
  /**
   * Including 0
   * @name module:automation/arith/Arith.Arith.Operator#wZero
   * @type {boolean} */
  wZero: false,
  /**
   * Including 1
   * @name module:automation/arith/Arith.Arith.Operator#wOne
   * @type {boolean} */
  wOne: false,
  /**
   * Including -1
   * @name module:automation/arith/Arith.Arith.Operator#wMinusOne
   * @type {boolean} */
  wMinusOne: false,
  /**
   * Take values from list. This member stores the list length.
   * @name module:automation/arith/Arith.Arith.Operator#fromList
   * @type {number} */
  fromList: 0,
  /**
   * The list of possible values
   * @name module:automation/arith/Arith.Arith.Operator#lst
   * @type {number[]} */
  lst: [],
});

Arith.Num = class {
  constructor() {
    this.vf = 0.0; // The number value
    this.c = 0; // Number of decimals to be used when representing the number
  }

  format() {
    return Arith.DecFormat(this.vf, this.c);
  }
};

Arith.Operation = class {
  constructor() {
    this.numA = new Arith.Num();
    this.numB = new Arith.Num();
    this.numR = new Arith.Num();
    this.op = 0;
  }
};

// Register class in AutoContentProvider.CLASSES
/* harmony default export */ const arith_Arith = (automation_AutoContentProvider.registerClass('@arith.Arith', Arith));

;// CONCATENATED MODULE: ./src/activities/text/TextActivityBase.js
/**
 *  File    : activities/text/TextActivityBase.js
 *  Created : 16/05/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */

/* global window */







/**
 * This class and its visual component {@link module:activities/text/TextActivityBase.TextActivityBasePanel TextActivityBasePanel} are the base for text
 * activities like {@link module:activities/text/FillInBlanks.FillInBlanks FillInBlanks}, {@link module:activities/text/IdentifyText.IdentifyText IdentifyText}, {@link module:activities/text/OrderText.OrderText OrderText} and {@link module:activities/text/Complete.Complete Complete}.
 * @extends module:Activity.Activity
 */
class TextActivityBase extends Activity {
  /**
   * TextActivityBase constructor
   * @param {module:project/JClicProject.JClicProject} project - The project to which this activity belongs
   */
  constructor(project) {
    super(project);
  }

  /**
   * Retrieves the minimum number of actions needed to solve this activity
   * @override
   * @returns {number}
   */
  getMinNumActions() {
    return this.document ? this.document.numTargets : 0;
  }
}

Object.assign(TextActivityBase.prototype, {
  /**
   * This is the object used to evaluate user's answers in text activities.
   * @name module:activities/text/TextActivityBase.TextActivityBase#ev
   * @type {module:activities/text/Evaluator.Evaluator} */
  ev: null,
  /**
   * This is the label used by text activities for the `check` button, when present.
   * @name module:activities/text/TextActivityBase.TextActivityBase#checkButtonText
   * @type {string} */
  checkButtonText: null,
  /**
   * When `true`, a text will be shown before the beginning of the activity.
   * @name module:activities/text/TextActivityBase.TextActivityBase#prevScreen
   * @type {boolean} */
  prevScreen: false,
  /**
   * Optional text to be shown before the beginning of the activity. When `null`, this text is
   * the main document.
   * @name module:activities/text/TextActivityBase.TextActivityBase#prevScreenText
   * @type {string} */
  prevScreenText: null,
  /**
   * The style of the optional text to be shown before the beginning of the activity.
   * @name module:activities/text/TextActivityBase.TextActivityBase#prevScreenStyle
   * @type {module:boxes/BoxBase.BoxBase} */
  prevScreenStyle: null,
  /**
   * Maximum amount of time for showing the previous document.
   * @name module:activities/text/TextActivityBase.TextActivityBase#prevScreenMaxTime
   * @type {number} */
  prevScreenMaxTime: -1,
});

/**
 * The {@link module:Activity.ActivityPanel ActivityPanel} where text activities (based on {@link module:activities/text/TextActivityBase.TextActivityBase TextActivityBase}) are played.
 * @extends module:Activity.ActivityPanel
 */
//export class TextActivityBasePanel extends Activity.Panel {
class TextActivityBasePanel extends ActivityPanel {
  /**
   * TextActivityBasePanel constructor
   * @param {module:Activity.Activity} act - The {@link module:Activity.Activity Activity} to which this Panel belongs
   * @param {module:JClicPlayer.JClicPlayer} ps - Any object implementing the methods defined in the
   * [PlayStation](http://projectestac.github.io/jclic/apidoc/edu/xtec/jclic/PlayStation.html) Java interface.
   * @param {external:jQuery} [$div] - The jQuery DOM element where this Panel will deploy
   */
  constructor(act, ps, $div) {
    super(act, ps, $div);
    this.targets = [];
  }

  /**
   * Fills a jQuery DOM element (usually a 'div') with the specified {@link module:activities/text/TextActivityDocument.TextActivityDocument TextActivityDocument}.
   * @param {external:jQuery} $div - The jQuery DOM object to be filled with the document.
   * @param {module:activities/text/TextActivityDocument.TextActivityDocument} doc - The document
   */
  setDocContent($div, doc) {

    // Empties the container of any pre-existing content
    // and sets the background and other attributes indicated by the main
    // style of the document.
    // It also sets the 'overflow' CSS attribute to 'auto', which will display a
    // vertical scroll bar when needed
    $div.empty().css(doc.style['default'].css).css({ display: 'flex', 'flex-direction': 'column' });

    const $scroller = external_jquery_default()('<div/>').css({ 'flex-grow': 1, overflow: 'auto' });
    const $doc = external_jquery_default()('<div/>', { class: 'JClicTextDocument' }).css({ 'padding': 4 }).css(doc.style['default'].css);

    let currentPStyle = null;
    const popupSpans = [];

    //
    // Process paragraphs
    doc.p.forEach(p => {
      // Creates a new DOM paragraph
      const $p = external_jquery_default()('<p/>').css({ margin: 0 });
      let empty = true;

      // Check if the paragraph has its own style
      if (p.style) {
        currentPStyle = doc.style[p.style].css;
        $p.css(currentPStyle);
      } else
        currentPStyle = null;

      // Check if the paragraph has a special alignment
      if (p.Alignment) {
        const al = Number(p.Alignment);
        $p.css({ 'text-align': al === 1 ? 'center' : al === 2 ? 'right' : 'left' });
      }

      // Process the paragraph elements
      p.elements.forEach(element => {
        // Elements will be inserted as 'span' DOM elements, or as simple text if they don't
        // have specific attributes.
        let $span;
        switch (element.objectType) {
          case 'text':
            const parsedText = external_jquery_default()('<span/>').html(element.text).text();
            const fragments = this.spanText
              ? stringToWords(parsedText)
              : [{ text: parsedText, sep: '' }];
            fragments.forEach(({ text, sep }) => {
              let initialCSS = { ...this.act.document.style['default'].css };
              if (element?.attr?.style)
                initialCSS = { ...initialCSS, ...doc.style[element.attr.style].css };
              if (element?.attr?.css)
                initialCSS = { ...initialCSS, ...element.attr.css };
              const txtBlocs = this.spanChars ? [...text] : [text];
              txtBlocs.forEach((str) => {
                if (element.attr) {
                  // Text uses a specific style and/or individual attributes
                  $span = external_jquery_default()('<span/>').html(str).css(initialCSS);
                  // Save initialCSS for later use
                  $span.initialCSS = initialCSS;
                  $p.append(this.$createSpanElement($span));
                } else {
                  if (this.spanText) {
                    $span = external_jquery_default()('<span/>').html(str);
                    $p.append(this.$createSpanElement($span));
                  }
                  else
                    $p.append(str);
                }
              });
              if (sep !== '')
                $p.append(sep);
            });
            break;

          case 'cell':
            // Create a new ActiveBox based on this ActiveBoxContent
            $span = external_jquery_default()('<span/>');
            const box = boxes_ActiveBox.createCell($span.css({ position: 'relative' }), element);
            $span.css({ 'display': 'inline-block', 'vertical-align': 'middle' });
            if (element.mediaContent) {
              $span.on('click', event => {
                event.preventDefault();
                this.ps.stopMedia(1);
                box.playMedia(this.ps);
                return false;
              });
            }
            $p.append($span);
            break;

          case 'target':
            $span = external_jquery_default()('<span/>');
            if (this.showingPrevScreen) {
              $span.text(element.text);
              $p.append($span);
              break;
            }

            const target = element;
            let $popup = null;
            // Process target popups
            if (target.infoMode !== 'no_info' && target.popupContent) {
              $popup = external_jquery_default()('<span/>').css({ position: 'absolute', 'padding-top': '2pt', display: 'none' });
              // Create a new ActiveBox based on popupContent
              const popupBox = boxes_ActiveBox.createCell($popup, target.popupContent);
              if (target.popupContent.mediaContent) {
                $popup.on('click', event => {
                  event.preventDefault();
                  this.ps.stopMedia(1);
                  if (popupBox)
                    popupBox.playMedia(this.ps);
                  else if (target.popupContent.mediaContent)
                    this.ps.playMedia(target.popupContent.mediaContent);
                  return false;
                });
              }
              target.$popup = $popup;
              // Save for later setting of top-margin
              popupSpans.push({ p: $p, span: $popup, box: popupBox });
            }

            $span = this.$createTargetElement(target, $span);
            target.num = this.targets.length;
            target.pos = target.num;
            this.targets.push(target);
            if ($span) {
              $span.css(doc.style['default'].css);
              if (currentPStyle)
                $span.css(currentPStyle);
              if (this.targetsMarked) {
                if (target.attr) {
                  // Default style name for targets is 'target'
                  if (!target.attr.style)
                    target.attr.style = 'target';
                  $span.css(doc.style[target.attr.style].css);
                  // Check if target has specific attributes
                  if (target.attr.css)
                    $span.css(target.attr.css);
                } else if (doc.style['target'])
                  $span.css(doc.style['target'].css);
              } else {
                target.targetStatus = 'HIDDEN';
              }

              // Catch on-demand popups with `F1`, cancel with `Escape`
              if ($popup !== null && target.infoMode === 'onDemand') {
                $span.keydown(ev => {
                  if (ev.key === target.popupKey) {
                    ev.preventDefault();
                    this.showPopup($popup, target.popupMaxTime, target.popupDelay);
                  } else if (ev.key === 'Escape') {
                    ev.preventDefault();
                    this.showPopup(null);
                  }
                });
              }
            }

            if ($popup && $span) {
              if (target.isList)
                $p.append($span).append($popup);
              else
                $p.append($popup).append($span);
            } else if ($span)
              $p.append($span);

            target.$p = $p;
            break;
        }
        empty = false;
      });
      if (empty)
        // Don't leave paragraphs empty
        $p.html('&nbsp;');

      // Adds the paragraph to the DOM element
      $doc.append($p);
    });

    $div.append($scroller.append($doc));

    if (this.act.checkButtonText && !this.showingPrevScreen) {
      this.$checkButton = external_jquery_default()('<button/>', { class: 'StockBtn' })
        .html(this.act.checkButtonText)
        .css({ width: '100%', 'flex-shrink': 0 })
        .on('click', () => this.evaluatePanel());
      $div.append(this.$checkButton);
    }

    // Place popups below its target baseline
    popupSpans.forEach(pspan => pspan.span.css({ 'margin-top': pspan.p.css('font-size') }));

    // Init Evaluator
    if (this.act.ev)
      this.act.ev.init(this.act.project.settings.locales);

    return $div;
  }

  /**
   * Creates a target DOM element.
   * This method can be overridden in subclasses to create specific types of targets.
   * @param {module:activities/text/TextActivityDocument.TextTarget} target - The target related to the DOM object to be created
   * @param {external:jQuery} $span - An initial DOM object (usually a `span`) that can be used
   * to store the target, or replaced by another type of object.
   * @returns {external:jQuery} - The jQuery DOM element loaded with the target data.
   */
  $createTargetElement(target, $span) {
    $span.text(target.text);
    target.$span = $span;
    return $span;
  }

  /**
   * Creates a 'span' element, used to isolate elements of text not involved in targets.
   * Used only when {@link spanText} is true.
   * @param {external:jQuery} $span - An initial DOM object (usually a `span`) that can be used
   * to store the target, or replaced by another type of object.
   * @returns {external:jQuery} - The jQuery DOM element loaded with the span data.
   */
  $createSpanElement($span) {
    return $span;
  }

  /**
   * Basic initialization procedure, common to all activities.
   * @override
   */
  initActivity() {
    if (this.act.prevScreen)
      this.preInitActivity();
    else
      this.startActivity();
  }

  /**
   * Called when the activity starts playing
   * @override
   */
  startActivity() {
    super.initActivity();
    this.setAndPlayMsg('initial', 'start');
    this.setDocContent(this.$div, this.act.document);
    this.playing = true;
  }

  /**
   * Called when the text activity has a 'previous screen' information to be shown before the
   * activity starts
   */
  preInitActivity() {
    if (!this.act.prevScreen)
      return;

    const prevScreenEnd = () => {
      this.showingPrevScreen = false;
      this.$div.unbind('click');
      if (this.prevScreenTimer) {
        window.clearTimeout(this.prevScreenTimer);
        this.prevScreenTimer = null;
      }
      this.startActivity();
      return true;
    };

    this.showingPrevScreen = true;
    this.$div.empty();

    if (!this.act.prevScreenText) {
      this.setDocContent(this.$div, this.act.document);
    } else {
      if (!this.act.prevScreenStyle)
        this.act.prevScreenStyle = new boxes_BoxBase();
      this.$div.css(this.act.prevScreenStyle.getCSS()).css('overflow', 'auto');
      const $html = external_jquery_default()('<div/>', { class: 'JClicTextDocument' })
        .css({ 'padding': 4 })
        .css(this.act.prevScreenStyle.getCSS())
        .append(this.act.prevScreenText);
      this.$div.append($html);
    }

    this.enableCounters(true, false, false);
    this.ps.setCounterValue('time', 0);

    this.ps.setMsg(this.act.messages['previous']);

    if (this.act.prevScreenMaxTime > 0) {
      this.ps.setCountDown('time', this.act.prevScreenMaxTime);
      this.prevScreenTimer = window.setTimeout(prevScreenEnd, this.act.prevScreenMaxTime * 1000);
    }

    this.$div.on('click', prevScreenEnd);
    this.ps.playMsg();
  }

  /**
   * Called when the user clicks on the check button
   * @returns {boolean} - `true` when the panel is OK, `false` otherwise.
   */
  evaluatePanel() {
    this.finishActivity(true);
    return true;
  }

  /**
   * Ordinary ending of the activity, usually called form `processEvent`
   * @override
   * @param {boolean} result - `true` if the activity was successfully completed, `false` otherwise
   */
  finishActivity(result) {
    if (this.$checkButton)
      this.$checkButton.prop('disabled', true);
    this.targets.forEach(t => {
      if (t.$comboList)
        t.$comboList.attr('disabled', true);
    });
    this.showPopup(null);
    super.finishActivity(result);
  }

  /**
   * Main handler used to process mouse, touch, keyboard and edit events
   * @override
   * @param {external:Event} _event - The HTML event to be processed
   * @returns {boolean} - When this event handler returns `false`, jQuery will stop its
   * propagation through the DOM tree. See: {@link http://api.jquery.com/on}
   */
  processEvent(_event) {
    return this.playing;
  }

  /**
   * @param {external:jQuery} $popup - The popup to display, or _null _ to just hide the current popup
   * @param {number} maxTime - The maximum time to mantain the popup on screen, in seconds
   * @param {number} waitTime - When set, indicates the number of seconds to wait before show the popup
   */
  showPopup($popup, maxTime, waitTime) {
    // Hide current popup
    if (this.$currentPopup) {
      this.$currentPopup.css({ display: 'none' });
      this.$currentPopup = null;
      if (this.currentPopupTimer) {
        window.clearTimeout(this.currentPopupTimer);
        this.currentPopupTimer = 0;
      }
    }

    // Clear popupWaitTimer
    if (this.popupWaitTimer) {
      window.clearTimeout(this.popupWaitTimer);
      this.popupWaitTimer = 0;
    }

    // Prepare popup timer
    if (waitTime) {
      this.popupWaitTimer = window.setTimeout(() => {
        this.showPopup($popup, maxTime);
      }, waitTime * 1000);
      return;
    }

    if ($popup) {
      $popup.css({ display: '' });
      $popup.trigger('click');

      this.$currentPopup = $popup;
      if (maxTime) {
        this.currentPopupTimer = window.setTimeout(() => {
          $popup.css({ display: 'none' });
          if (this.$currentPopup === $popup) {
            this.$currentPopup = null;
            this.currentPopupTimer = 0;
          }
        }, maxTime * 1000);
      }
    }
  }
}

Object.assign(TextActivityBasePanel.prototype, {
  /**
   * Array of jQuery DOM elements (usually of type 'span') containing the targets of this activity
   * @name module:activities/text/TextActivityBase.TextActivityBasePanel#targets
   * @type {external:jQuery[]} */
  targets: null,
  /**
   * Flag indicating if targets must be visually marked at the beginning of the activity.
   * Should be `true` except for {@link module:activities/text/IdentifyText.IdentifyText IdentifyText} activities.
   * @name module:activities/text/TextActivityBase.TextActivityBasePanel#targetsMarked
   * @type {boolean} */
  targetsMarked: true,
  /**
   * The button used to check the activity, only when `Activity.checkButtonText` is not null
   * @name module:activities/text/TextActivityBase.TextActivityBasePanel#$checkButton
   * @type {external:jQuery}*/
  $checkButton: null,
  /**
   * System timer used to close the previous document when act.maxTime is reached.
   * @name module:activities/text/TextActivityBase.TextActivityBasePanel#prevScreenTimer
   * @type {number} */
  prevScreenTimer: null,
  /**
   * The popup currently been displayed
   * @name module:activities/text/TextActivityBase.TextActivityBasePanel#$currentPopup
   * @type {external:jQuery} */
  $currentPopup: null,
  /**
   * A timer controlling the time the current popup will be displayed
   * @name module:activities/text/TextActivityBase.TextActivityBasePanel#currentPopupTimer
   * @type {number} */
  currentPopupTimer: 0,
  /**
   * A timer prepared to display a popup after a while
   * @name module:activities/text/TextActivityBase.TextActivityBasePanel#popupWaitTimer
   * @type {number} */
  popupWaitTimer: 0,
  /**
   * When true, all text outside of targets and cells will be inserted as independent words or letters,
   * using 'span' elements. {@link module:activities/text/TextActivityBase.TextActivityBasePanel#$createSpanElement} can be used
   * to customize these elements.
   * @name module:activities/text/TextActivityBase.TextActivityBasePanel#spanText
   * @type {boolean} */
  spanText: false,
  /**
   * When true, text spanning will be done at char level: each single letter will be a clickacle span.
   * Used only in activities of type "itentify letters"
   * @name module:activities/text/TextActivityBase.TextActivityBasePanel#spanChars
   * @type {boolean} */
  spanChars: false,
});

/**
 * Panel class associated to this type of activity: {@link module:activities/text/TextActivityBase.TextActivityBasePanel TextActivityBasePanel}
 * @type {class} */
TextActivityBase.Panel = TextActivityBasePanel;

/* harmony default export */ const text_TextActivityBase = (TextActivityBase);

;// CONCATENATED MODULE: ./src/activities/text/FillInBlanks.js
/**
 *  File    : activities/text/FillInBlanks.js
 *  Created : 20/06/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Catalan Educational Telematic Network (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */






/**
 * In this type of activity the text document has some blanks that must be filled-in. The blanks
 * can be drop-down boxes or text fields (empty or pre-filled with an initial text). Blanks can
 * also have associated clues, shown as "pop-ups".
 * @extends module:activities/text/TextActivityBase.TextActivityBase
 */
class FillInBlanks extends TextActivityBase {
  /**
   * FillInBlanks constructor
   * @param {module:project/JClicProject.JClicProject} project - The {@link module:project/JClicProject.JClicProject JClicProject} to which this activity belongs
   */
  constructor(project) {
    super(project);
  }

  /**
   * This kind of activity usually makes use of the keyboard
   * @override
   * @returns {boolean}
   */
  needsKeyboard() {
    return true;
  }
}

Object.assign(FillInBlanks.prototype, {
  /**
   * Whether to jump or not to the next target when the current one is solved.
   * @name module:activities/text/FillInBlanks.FillInBlanks#autoJump
   * @type {boolean} */
  autoJump: false,
  /**
   * Whether to block or not the jump to other targets until the current one
   * is resolved.
   * @name module:activities/text/FillInBlanks.FillInBlanks#forceOkToAdvance
   * @type {boolean} */
  forceOkToAdvance: false,
});

/**
 * The {@link module:activities/text/TextActivityBase.TextActivityBasePanel} where {@link module:activities/text/FillInBlanks.FillInBlanks FillInBlanks} activities are played.
 * @extends module:activities/text/TextActivityBase.TextActivityBasePanel
 */
class FillInBlanksPanel extends TextActivityBasePanel {
  /**
   * FillInBlanksPanel constructor
   * @param {module:Activity.Activity} act - The {@link module:Activity.Activity Activity} to which this Panel belongs
   * @param {module:JClicPlayer.JClicPlayer} ps - Any object implementing the methods defined in the
   * [PlayStation](http://projectestac.github.io/jclic/apidoc/edu/xtec/jclic/PlayStation.html) Java interface.
   * @param {external:jQuery} [$div] - The jQuery DOM element where this Panel will deploy
   */
  constructor(act, ps, $div) {
    super(act, ps, $div);
  }

  /**
   * Creates a target DOM element for the provided target. This DOM element can be an editable
   * `span` or a `select` with specific `option` elements (when the target is a drop-down list)
   * @override
   * @param {module:activities/text/TextActivityDocument.TextTarget} target - The target related to the DOM object to be created
   * @param {external:jQuery} $span -  - An initial DOM object (usually a `span`) that can be used
   * to store the target, or replaced by another type of object.
   * @returns {external:jQuery} - The jQuery DOM element loaded with the target data.
   */
  $createTargetElement(target, $span) {

    $span.addClass('JClicTextTarget');

    const idLabel = `target${`000${this.targets.length - 1}`.slice(-3)}`;
    if (target.isList && target.options && target.options.length > 0) {
      // Use a `select` element
      $span = external_jquery_default()('<select/>', { id: idLabel, name: idLabel });
      if (target.options[0].trim() !== '')
        external_jquery_default()('<option selected/>', { value: '', text: '' }).appendTo($span);
      target.options.forEach(op => external_jquery_default()('<option/>', { value: op, text: op }).appendTo($span));
      target.$comboList = $span.bind('focus change', event => {
        event.textTarget = target;
        this.processEvent(event);
      });
    } else {
      // Use a `span` element with the `contentEditable` attribute set `on`
      target.currentText = target.iniText ?
        target.iniText
        : fillString(target.iniChar, target.numIniChars);

      target.$span = $span.text(target.currentText).attr({
        contenteditable: 'true',
        id: idLabel,
        autocomplete: 'off',
        spellcheck: 'false'
      }).bind('focus input blur', event => {
        event.textTarget = target;
        this.processEvent(event);
      }).bind('keydown keyup', event => {
        // Catch `enter` key in Firefox
        if (event.keyCode === 13) {
          event.preventDefault();
          if (event.type === 'keydown') {
            // Simulate a `blur` event
            event.textTarget = target;
            event.type = 'blur';
            this.processEvent(event);
          }
        }
      });
    }
    return $span;
  }

  /**
   * Evaluates all the targets in this panel. This method is usually called from the `Check` button.
   * @override
   * @returns {boolean} - `true` when all targets are OK, `false` otherwise.
   */
  evaluatePanel() {
    let targetsOk = 0;
    const numTargets = this.targets.length;
    this.targets.forEach(target => {
      const
        result = this.act.ev.evalText(target.readCurrentText(), target.answers),
        ok = this.act.ev.isOk(result);
      target.targetStatus = ok ? 'SOLVED' : 'WITH_ERROR';
      if (ok)
        targetsOk++;
      this.markTarget(target, result);
      this.ps.reportNewAction(this.act, 'WRITE', target.currentText, target.getAnswers(), ok, targetsOk);
    });
    if (targetsOk === numTargets) {
      this.finishActivity(true);
      return true;
    } else
      this.playEvent('finishedError');
    return false;
  }

  /**
   * Checks if the specified TextTarget has a valid answer in its `currentText` field
   * @param {module:activities/text/TextActivityDocument.TextTarget} target - The target to check
   * @param {boolean} onlyCheck - When `true`, the cursor will no be re-positioned
   * @param {number} [jumpDirection] - `1` to go forward, `-1` to go back.
   * @returns {boolean} - `true` when the target contains a valid answer
   */
  checkTarget(target, onlyCheck, jumpDirection) {
    const
      result = this.act.ev.evalText(target.currentText, target.answers),
      ok = this.act.ev.isOk(result);

    target.targetStatus = ok ? 'SOLVED' : 'WITH_ERROR';
    if (onlyCheck)
      return ok;

    this.markTarget(target, result);
    const targetsOk = this.countSolvedTargets(false, false);
    if (target.currentText.length > 0)
      this.ps.reportNewAction(this.act, 'WRITE', target.currentText, target.getAnswers(), ok, targetsOk);
    if (ok && targetsOk === this.targets.length) {
      this.finishActivity(true);
      return ok;
    } else if (target.currentText.length > 0)
      this.playEvent(ok ? 'actionOk' : 'actionError');

    if (jumpDirection && jumpDirection !== 0) {
      let p = target.num + jumpDirection;
      if (p >= this.targets.length)
        p = 0;
      else if (p < 0)
        p = this.targets.length - 1;

      const destTarget = this.targets[p];
      if (destTarget.$span) {
        destTarget.$span.focus();
        setSelectionRange(destTarget.$span.get(-1), 0, 0);
      } else if (destTarget.$comboList)
        destTarget.$comboList.focus();
    }
    return ok;
  }

  /**
   * Counts the number of targets with `SOLVED` status
   * @param {boolean} checkNow - When `true`, all targets will be evaluated. Otherwise, only the
   * current value of `targetStatus` will be checked.
   * @param {boolean} [mark] - When `true`, errors in the target answer will be marked.
   * @returns {number} - The number of targets currently solved.
   */
  countSolvedTargets(checkNow, mark) {
    return this.targets.reduce((n, target) => {
      if (checkNow) {
        target.readCurrentText();
        this.checkTarget(target, !mark);
      }
      return target.targetStatus === 'SOLVED' ? ++n : n;
    }, 0);
  }

  /**
   * Visually marks the target as 'solved OK' or 'with errors'.
   * @param {module:activities/text/TextActivityDocument.TextTarget} target - The text target to be marked.
   * @param {number[]} attributes -  - Array of flags indicating the status (OK or error) for each
   * character in `target.currentText`.
   */
  markTarget(target, attributes) {
    if (target.$comboList || this.act.ev.isOk(attributes))
      target.checkColors();
    else if (target.$span) {
      // Identify text fragments
      const
        txt = target.currentText,
        fragments = [];
      let
        currentStatus = -1,
        currentFragment = -1,
        i = 0;
      for (; i < attributes.length && i < txt.length; i++) {
        if (attributes[i] !== currentStatus) {
          fragments[++currentFragment] = '';
          currentStatus = attributes[i];
        }
        fragments[currentFragment] += txt.charAt(i);
      }
      if (i < txt.length)
        fragments[currentFragment] += txt.substr(i);
      // Empty and re-fill $span
      target.$span.empty();
      currentStatus = attributes[0];
      fragments.forEach(fragment => {
        external_jquery_default()('<span/>')
          .text(fragment)
          .css(target.doc.style[currentStatus === 0 ? 'target' : 'targetError'].css)
          .appendTo(target.$span);
        currentStatus ^= 1;
      });
    }
    // Target has been marked, so clear the 'modified' flag
    target.flagModified = false;
  }

  /**
   * Called by {@link module:JClicPlayer.JClicPlayer JClicPlayer} when this activity panel is fully visible, just after the
   * initialization process.
   * @override
   */
  activityReady() {
    super.activityReady();

    // Prevent strange behavior with GoogleChrome when `white-space` CSS attribute is set to
    // `pre-wrap` (needed for tabulated texts)
    external_jquery_default()('.JClicTextTarget').css('white-space', 'normal');
    if (this.targets.length > 0 && this.targets[0].$span)
      this.targets[0].$span.focus();
  }

  /**
   * Ordinary ending of the activity, usually called form `processEvent`
   * @override
   * @param {boolean} result - `true` if the activity was successfully completed, `false` otherwise
   */
  finishActivity(result) {
    this.targets.forEach(target => {
      if (target.$span)
        target.$span.removeAttr('contenteditable').blur();
      else if (target.$comboList)
        target.$comboList.attr('disabled', 'true').blur();
    });
    return super.finishActivity(result);
  }

  /**
   * Main handler used to process mouse, touch, keyboard and edit events.
   * @override
   * @param {external:Event} event - The HTML event to be processed
   * @returns {boolean} - When this event handler returns `false`, jQuery will stop its
   * propagation through the DOM tree. See: {@link http://api.jquery.com/on}
   */
  processEvent(event) {
    if (!super.processEvent(event))
      return false;

    const target = event.textTarget;
    let $span = null, pos = 0;
    switch (event.type) {
      case 'focus':
        if (target) {
          if (target.$span && target.$span.children().length > 0) {
            // Clear inner spans used to mark errors
            $span = target.$span;
            pos = Math.min(
              target.currentText.length,
              getCaretCharacterOffsetWithin($span.get(-1)));
            $span.empty();
            $span.text(target.currentText);
            setSelectionRange($span.get(-1), pos, pos);
            target.flagModified = true;
          } else if (target.$comboList)
            target.$comboList.css(target.doc.style['target'].css);

          if (target.$popup && (target.infoMode === 'always' || target.infoMode === 'onError' && target.targetStatus === 'WITH_ERROR'))
            this.showPopup(target.$popup, target.popupMaxTime, target.popupDelay);
          else
            this.showPopup(null);
        }
        break;

      case 'blur':
        if (target.flagModified && !this.$checkButton)
          this.checkTarget(target, false, 1);
        break;

      case 'input':
        if (target && target.$span) {
          $span = target.$span;
          let txt = $span.html();
          // Check for `enter` key
          if (/(<br>|\n|\r)/.test(txt)) {
            txt = txt.replace(/(<br>|\n|\r)/g, '');
            $span.html(txt);
            target.currentText = $span.text();
            return this.$checkButton ? false : this.checkTarget(target, false, 1);
          }
          // Check if text has changed
          // From here, use 'text' instead of 'html' to avoid HTML entities
          txt = $span.text();
          if (txt !== target.currentText) {
            // Span text has changed!
            target.flagModified = true;
            const added = txt.length - target.currentText.length;
            if (added > 0) {
              if (txt.indexOf(target.iniChar) >= 0) {
                // Remove filling chars
                pos = getCaretCharacterOffsetWithin($span.get(-1));
                for (let i = 0; i < added; i++) {
                  const p = txt.indexOf(target.iniChar);
                  if (p < 0)
                    break;
                  txt = txt.substr(0, p) + txt.substr(p + 1);
                  if (p < pos)
                    pos--;
                }
                $span.text(txt);
                setSelectionRange($span.get(-1), pos, pos);
              }

              // Check if current text exceeds max length
              if (txt.length > target.maxLenResp) {
                pos = getCaretCharacterOffsetWithin($span.get(-1));
                txt = txt.substr(0, target.maxLenResp);
                pos = Math.min(pos, txt.length);
                $span.text(txt);
                setSelectionRange($span.get(-1), pos, pos);
              }
            } else if (txt === '') {
              txt = target.iniChar;
              $span.text(txt);
              setSelectionRange($span.get(-1), 0, 0);
            }
            target.currentText = txt;
          }
        }
        break;

      case 'change':
        if (target && target.$comboList) {
          target.currentText = target.$comboList.val();
          target.flagModified = true;
          return this.$checkButton ? false : this.checkTarget(target, false, 1);
        }
        break;

      default:
        break;
    }
    return true;
  }
}

Object.assign(FillInBlanksPanel.prototype, {
  /**
   * Flag indicating if the activity is open or locked
   * @name module:activities/text/FillInBlanks.FillInBlanksPanel#locked
   * @type {boolean} */
  locked: true,
});

/**
 * Panel class associated to this type of activity: {@link module:activities/text/FillInBlanks.FillInBlanksPanel FillInBlanksPanel}
 * @type {class} */
FillInBlanks.Panel = FillInBlanksPanel;

// Register activity class
/* harmony default export */ const text_FillInBlanks = (src_Activity.registerClass('@text.FillInBlanks', FillInBlanks));

;// CONCATENATED MODULE: ./src/boxes/BoxConnector.js
/**
 *  File    : boxes/BoxConnector.js
 *  Created : 26/05/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Catalan Educational Telematic Network (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */



const DEFAULT_COMPOSITE_OP = 'source-over';

/**
 * BoxConnector allows users to visually connect two {@link module:boxes/ActiveBox.ActiveBox ActiveBox} objects of an
 * {@link module:Activity.ActivityPanel ActivityPanel}. There are two modes of operation:
 *
 * - Drawing a line between an origin point (usually the point where the user clicks on) and a
 * destination point.
 * - Dragging the ActiveBox from one location to another.
 *
 * The connecting lines can have arrowheads at its endings.
 */
class BoxConnector {
  /**
   * BoxConnector constructor
   * @param {module:AWT.Container} parent - The Container to which this BoxConnector belongs
   * @param {external:CanvasRenderingContext2D} ctx - The canvas rendering context where to draw
   */
  constructor(parent, ctx) {
    this.parent = parent;
    this.ctx = ctx;
    this.dim = new Dimension(ctx.canvas.width, ctx.canvas.height);
    this.origin = new Point();
    this.dest = new Point();
    this.relativePos = new Point();
  }

  /**
   * Displaces the ending point of the connector
   * @param {number} dx - Displacement on the X axis
   * @param {number} dy - Displacement on the Y axis
   */
  moveBy(dx, dy) {
    this.moveTo(Point(this.dest.x + dx, this.dest.y + dy));
  }

  /**
   * Moves the ending point of the connector to a new position
   * @param {module:AWT.Point} pt - The new position
   * @param {boolean} forcePaint - When `true`, forces the repaint of all the area also if there is
   * no movement at all.
   */
  moveTo(pt, forcePaint) {
    if (!this.active || !forcePaint && this.dest.equals(pt))
      return;

    // Restore the background
    if (this.bgRect) {
      if (this.bgImg) {
        this.ctx.putImageData(
          this.bgImg,
          0, 0,
          this.bgRect.pos.x, this.bgRect.pos.y,
          this.bgRect.dim.width, this.bgRect.dim.height);
      } else if (this.parent)
        this.parent.updateContent();
    }

    this.dest.moveTo(pt);

    // Calculate the bounds of the invalidated area after the move:
    // Start with the origin point or box area
    const pt1 = new Point(this.origin.x - this.relativePos.x, this.origin.y - this.relativePos.y);
    this.bgRect = new Rectangle(pt1, this.bx ? this.bx.dim : new Dimension());
    //  Add the destination point or box area
    const pt2 = new Point(pt.x - this.relativePos.x, pt.y - this.relativePos.y);
    this.bgRect.add(new Rectangle(pt2, this.bx ? this.bx.dim : new Dimension()));
    // Add a generous border around the area
    this.bgRect.grow(10, 10);

    if (this.bx !== null) {
      // Move the ActiveBox
      this.bx.moveTo(new Point(pt.x - this.relativePos.x, pt.y - this.relativePos.y));
      this.bx.setTemporaryHidden(false);
      this.bx.update(this.ctx, null);
      this.bx.setTemporaryHidden(true);
    } else {
      // Draw the connecting line
      this.drawLine();
      this.linePainted = true;
    }
  }

  /**
   * Starts the box connector operation
   * @param {module:AWT.Point} pt - Starting point
   * @param {module:boxes/ActiveBox.ActiveBox} [box] -  Passed only when the BoxConnector runs in drag&drop mode
   */
  begin(pt, box) {
    if (this.active)
      this.end();
    this.origin.moveTo(pt);
    this.dest.moveTo(pt);
    this.linePainted = false;
    this.active = true;

    if (box) {
      // Remember what box will be moved, hide it from the panel and repaint all
      this.bx = box;
      this.relativePos.moveTo(pt.x - box.pos.x, pt.y - box.pos.y);
      this.bx.setFocused(true);
      this.bx.setTemporaryHidden(true);
      this.linePainted = false;
      this.parent.invalidate().update();
    }

    // Save the full image currently displayed on the panel (with the box hidden)
    try {
      this.bgImg = this.ctx.getImageData(0, 0, this.dim.width, this.dim.height);
    } catch (ex) {
      // Avoid "canvas tainted by cross-origin data" errors
      // Setting bgImg to null is less efficient, but works
      this.bgImg = null;
    }
    this.bgRect = null;

    // Make a first movement to make the box appear
    if (box)
      this.moveTo(pt, true);
  }

  /**
   * Finalizes the operation of this box connector until a new call to `begin`
   */
  end() {
    if (!this.active)
      return;

    this.active = false;
    this.linePainted = false;
    this.bgRect = null;
    this.bgImg = null;

    if (this.bx) {
      // Restore the original position and attributes of the box
      this.bx.setFocused(false);
      this.bx.moveTo(this.origin.x - this.relativePos.x, this.origin.y - this.relativePos.y);
      this.bx.setTemporaryHidden(false);
      this.bx = null;
      this.relativePos.moveTo(0, 0);
    }

    // Repaint all
    this.ctx.clearRect(0, 0, this.dim.width, this.dim.height);
    this.parent.invalidate().update();
  }

  /**
   * Strokes a line between `origin` and `dest`, optionally ended with an arrowhead.
   */
  drawLine() {
    if (this.compositeOp !== DEFAULT_COMPOSITE_OP) {
      this.ctx.strokeStyle = this.xorColor;
      this.ctx.globalCompositeOperation = this.compositeOp;
    } else
      this.ctx.strokeStyle = this.lineColor;

    this.ctx.lineWidth = this.lineWidth;

    this.ctx.beginPath();
    this.ctx.moveTo(this.origin.x, this.origin.y);
    this.ctx.lineTo(this.dest.x, this.dest.y);
    this.ctx.stroke();

    if (this.arrow) {
      // Draws the arrow head
      const
        beta = Math.atan2(this.origin.x - this.dest.x, this.dest.x - this.origin.x),
        arp = new Point(this.dest.x - this.arrowLength * Math.cos(beta + this.arrowAngle),
          this.dest.y + this.arrowLength * Math.sin(beta + this.arrowAngle));
      this.ctx.beginPath();
      this.ctx.moveTo(this.dest.x, this.dest.y);
      this.ctx.lineTo(arp.x, arp.y);
      this.ctx.stroke();

      arp.moveTo(this.dest.x - this.arrowLength * Math.cos(beta - this.arrowAngle),
        this.dest.y + this.arrowLength * Math.sin(beta - this.arrowAngle));
      this.ctx.beginPath();
      this.ctx.moveTo(this.dest.x, this.dest.y);
      this.ctx.lineTo(arp.x, arp.y);
      this.ctx.stroke();
    }
    if (this.compositeOp !== DEFAULT_COMPOSITE_OP) {
      // reset default settings
      this.ctx.globalCompositeOperation = DEFAULT_COMPOSITE_OP;
    }
  }
}

Object.assign(BoxConnector.prototype, {
  /**
   * The background image, saved and redrawn on each movement
   * @name module:boxes/BoxConnector.BoxConnector#bgImg
   * @type {external:HTMLImageElement} */
  bgImg: null,
  /**
   * The rectangle of {@link module:Activity.ActivityPanel ActivityPanel} saved in `bgImg`
   * @name module:boxes/BoxConnector.BoxConnector#bgRect
   * @type {module:AWT.Rectangle} */
  bgRect: null,
  /**
   * Initial position of the connector
   * @name module:boxes/BoxConnector.BoxConnector#origin
   * @type {module:AWT.Point} */
  origin: null,
  /**
   * Current (while moving) and final position of the connector
   * @name module:boxes/BoxConnector.BoxConnector#dest
   * @type {module:AWT.Point} */
  dest: null,
  /**
   * When `true`, the connector must end on arrowhead
   * @name module:boxes/BoxConnector.BoxConnector#arrow
   * @type {boolean} */
  arrow: false,
  /**
   * `true` while the connector is active
   * @name module:boxes/BoxConnector.BoxConnector#active
   * @type {boolean} */
  active: false,
  /**
   * `true` while the line has already been painted (used for XOR expressions)
   * @name module:boxes/BoxConnector.BoxConnector#linePainted
   * @type {boolean} */
  linePainted: false,
  /**
   * The arrowhead length (in pixels)
   * @name module:boxes/BoxConnector.BoxConnector#arrowLength
   * @type {number} */
  arrowLength: 10,
  /**
   * The arrowhead angle
   * @name module:boxes/BoxConnector.BoxConnector#arrowAngle
   * @type {number} */
  arrowAngle: Math.PI / 6,
  /**
   * The main color used in XOR operations
   * @name module:boxes/BoxConnector.BoxConnector#lineColor
   * @type {string} */
  lineColor: 'black',
  /**
   * The complementary color used in XOR operations
   * @name module:boxes/BoxConnector.BoxConnector#xorColor
   * @type {string} */
  xorColor: 'white',
  /**
   * The global composite operator used when drawing in XOR mode. Default is "difference".
   * For a list of possible values see:
   * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation}
   * @name module:boxes/BoxConnector.BoxConnector#compositeOp
   * @type {string} */
  compositeOp: 'difference',
  /**
   * The default {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation composite operator}
   * ("source-over").
   * @name module:boxes/BoxConnector.BoxConnector#DEFAULT_COMPOSITE_OP
   * @static
   * @type {string} */
  DEFAULT_COMPOSITE_OP: DEFAULT_COMPOSITE_OP,
  /**
   * Relative position of point B regarding A
   * @name module:boxes/BoxConnector.BoxConnector#relativePos
   * @type {module:AWT.Point} */
  relativePos: null,
  /**
   * The ActiveBox to connect or move
   * @name module:boxes/BoxConnector.BoxConnector#bx
   * @type {module:boxes/ActiveBox.ActiveBox} */
  bx: null,
  /**
   * The Graphics context where the BoxConnector will paint
   * @name module:boxes/BoxConnector.BoxConnector#ctx
   * @type {external:CanvasRenderingContext2D} */
  ctx: null,
  /**
   * The dimension of the HTML canvas where to draw
   * @name module:boxes/BoxConnector.BoxConnector#dim
   * @type {module:AWT.Dimension} */
  dim: null,
  /**
   * The container to which this connector belongs
   * @name module:boxes/BoxConnector.BoxConnector#parent
   * @type {module:AWT.Container} */
  parent: null,
  /**
   * Width of the connector line
   * @name module:boxes/BoxConnector.BoxConnector#lineWidth
   * @type {number} */
  lineWidth: 1.5,
});

/* harmony default export */ const boxes_BoxConnector = (BoxConnector);

;// CONCATENATED MODULE: ./src/activities/text/OrderText.js
/**
 *  File    : activities/text/OrderText.js
 *  Created : 20/06/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */







/**
 * In this type of text activity users must put in order some words or paragraphs that have been
 * initially shuffled.
 * @extends module:activities/text/TextActivityBase.TextActivityBase
 */
class OrderText extends TextActivityBase {
  /**
   * OrderText constructor
   * @param {module:project/JClicProject.JClicProject} project - The project to which this activity belongs
   */
  constructor(project) {
    super(project);
  }

  /**
   * Whether or not the activity uses random to shuffle internal components
   * @override
   * @returns {boolean}
   */
  hasRandom() {
    return true;
  }

  /**
   * When `true`, the activity must always be shuffled
   * @override
   * @returns {boolean}
   */
  shuffleAlways() {
    return true;
  }

  /**
   * Whether the activity allows the user to request help.
   * @override
   * @returns {boolean}
   */
  helpSolutionAllowed() {
    return true;
  }
}

Object.assign(OrderText.prototype, {
  /**
   * Whether to allow or not to shuffle words among different paragraphs.
   * @name module:activities/text/OrderText.OrderText#amongParagraphs
   * @type {boolean} */
  amongParagraphs: false,
  /**
   * The box connector
   * @name module:activities/text/OrderText.OrderText#bc
   * @type {module:boxes/BoxConnector.BoxConnector} */
  bc: null,
});

/**
 * The {@link module:activities/text/TextActivityBase.TextActivityBasePanel TextActivityBasePanel} where {@link module:activities/text/OrderText.OrderText OrderText} activities are played.
 * @extends module:activities/text/TextActivityBase.TextActivityBasePanel
 */
class OrderTextPanel extends TextActivityBasePanel {
  /**
   * OrderTextPanel constructor
   * @param {module:Activity.Activity} act - The {@link module:Activity.Activity Activity} to which this Panel belongs
   * @param {module:JClicPlayer.JClicPlayer} ps - Any object implementing the methods defined in the
   * [PlayStation](http://projectestac.github.io/jclic/apidoc/edu/xtec/jclic/PlayStation.html) Java interface.
   * @param {external:jQuery} [$div] - The jQuery DOM element where this Panel will deploy
   */
  constructor(act, ps, $div) {
    super(act, ps, $div);
  }

  /**
   * Prepares the text panel
   * @override
   */
  buildVisualComponents() {
    this.act.document.style['target'].css.cursor = 'pointer';
    super.buildVisualComponents();
  }

  /**
   * Sets the size and position of this activity panel
   * @override
   * @param {module:AWT.Rectangle} rect
   */
  setBounds(rect) {
    if (this.$canvas)
      this.$canvas.remove();

    super.setBounds(rect);
    if (!this.act.dragCells) {
      // Create the main canvas
      this.$canvas = external_jquery_default()(`<canvas width="${rect.dim.width}" height="${rect.dim.height}"/>`).css({
        position: 'absolute',
        top: 0,
        left: 0,
        'pointer-events': 'none'
      });
      this.$div.append(this.$canvas);

      // Create a [BoxConnector](BoxConnector.html) and attach it to the canvas context
      this.bc = new boxes_BoxConnector(this, this.$canvas.get(-1).getContext('2d'));
      this.bc.compositeOp = this.bc.DEFAULT_COMPOSITE_OP;

      // Repaint all
      this.invalidate().update();
    }
  }

  /**
   * Creates a target DOM element for the provided target.
   * @override
   * @param {module:activities/text/TextActivityDocument.TextTarget} target - The target related to the DOM object to be created
   * @param {external:jQuery} $span -  - An initial DOM object (usually a `span`) that can be used
   * to store the target, or replaced by another type of object.
   * @returns {external:jQuery} - The jQuery DOM element loaded with the target data.
   */
  $createTargetElement(target, $span) {
    super.$createTargetElement(target, $span);
    const idLabel = `target${`000${this.targets.length - 1}`.slice(-3)}`;
    $span.addClass('JClicTextTarget').bind('click', event => {
      event.textTarget = target;
      event.idLabel = idLabel;
      this.processEvent(event);
    });
    return $span;
  }

  /**
   * Swaps the position of two targets in the document
   * @param {module:activities/text/TextActivityDocument.TextTarget} t1 - One target
   * @param {module:activities/text/TextActivityDocument.TextTarget} t2 - Another target
   */
  swapTargets(t1, t2) {
    const
      $span1 = t1.$span,
      $span2 = t2.$span,
      $marker = external_jquery_default()('<span/>');
    $marker.insertAfter($span2);
    $span2.detach();
    $span2.insertAfter($span1);
    $span1.detach();
    $span1.insertAfter($marker);
    $marker.remove();

    const
      pos = t1.pos,
      $p = t1.$p;
    t1.pos = t2.pos;
    t1.$p = t2.$p;
    t2.pos = pos;
    t2.$p = $p;
  }

  /**
   * Basic initialization procedure
   * @override
   */
  initActivity() {
    super.initActivity();
    if (!this.firstRun)
      this.buildVisualComponents();
    else
      this.firstRun = false;
  }

  /**
   * Called when the activity starts playing
   * @override
   */
  startActivity() {
    super.startActivity();
    if (!this.showingPrevScreen) {
      if (this.act.type === 'orderWords' && !this.act.amongParagraphs) {
        // Group targets by paragraph
        const groups = [];
        let
          lastTarget = null,
          currentGroup = [];
        this.targets.forEach(t => {
          if (lastTarget !== null && lastTarget.$p !== t.$p) {
            groups.push(currentGroup);
            currentGroup = [];
          }
          currentGroup.push(t);
          lastTarget = t;
        });
        if (currentGroup.length > 0)
          groups.push(currentGroup);

        // Scramble group by group
        groups.forEach(group => this.shuffleTargets(group, this.act.shuffles));
      } else
        this.shuffleTargets(this.targets, this.act.shuffles);

      this.playing = true;
    }
    this.setBounds(this);
  }

  /**
   * Randomly shuffles a set of targets
   * @param {module:activities/text/TextActivityDocument.TextTarget[]} targets - The set of targets to shuffle (can be all
   * document targets or just the targets belonging to the same paragraph, depending on the value of
   * `amongParagraphs` in {@link module:Activity.Activity Activity}.
   * @param {number} steps - The number of times to shuffle the elements
   */
  shuffleTargets(targets, steps) {
    const nt = targets.length;
    if (nt > 1) {
      let repeatCount = 100;
      for (let i = 0; i < steps; i++) {
        const
          r1 = Math.floor(Math.random() * nt),
          r2 = Math.floor(Math.random() * nt);
        if (r1 !== r2) {
          this.swapTargets(targets[r1], targets[r2]);
        } else {
          if (--repeatCount)
            i++;
        }
      }
    }
  }

  /**
   * Sets the current target
   * @param {module:activities/text/TextActivityDocument.TextTarget} target - The currently selected target. Can be `null`.
   */
  setCurrentTarget(target) {
    const targetCss = this.act.document.getFullStyle('target').css;
    if (this.currentTarget && this.currentTarget.$span)
      this.currentTarget.$span.css(targetCss);
    if (target && target.$span) {
      target.$span.css({
        color: targetCss['background-color'],
        'background-color': targetCss.color
      });
    }
    this.currentTarget = target;
  }

  /**
   * Counts the number of targets that are at right position
   * @returns {number}
   */
  countSolvedTargets() {
    return this.targets.filter(({ num, pos }) => num === pos).length;
  }

  /**
   * Evaluates all the targets in this panel. This method is usually called from the `Check` button.
   * @override
   * @returns {boolean} - `true` when all targets are OK, `false` otherwise.
   */
  evaluatePanel() {
    if (this.bc && this.bc.active)
      this.bc.end();
    this.setCurrentTarget(null);

    let targetsOk = 0;
    this.targets.forEach(target => {
      const ok = target.num === target.pos;
      target.targetStatus = ok ? 'SOLVED' : 'WITH_ERROR';
      if (ok)
        targetsOk++;
      target.checkColors();
      this.ps.reportNewAction(this.act, 'PLACE', target.text, target.pos, ok, targetsOk);
    });
    if (targetsOk === this.targets.length) {
      this.finishActivity(true);
      return true;
    } else {
      this.playEvent('finishedError');
    }
    return false;
  }

  /**
   * Ordinary ending of the activity, usually called form `processEvent`
   * @override
   * @param {boolean} result - `true` if the activity was successfully completed, `false` otherwise
   */
  finishActivity(result) {
    external_jquery_default()('.JClicTextTarget').css('cursor', 'pointer');
    return super.finishActivity(result);
  }

  /**
   * Main handler used to process mouse, touch, keyboard and edit events.
   * @override
   * @param {external:Event} event - The HTML event to be processed
   * @returns {boolean} - When this event handler returns `false`, jQuery will stop its
   * propagation through the DOM tree. See: {@link http://api.jquery.com/on}
   */
  processEvent(event) {
    if (!super.processEvent(event))
      return false;

    const target = event.textTarget;
    let p = null;
    if (this.bc && this.playing && !this.showingPrevScreen) {
      //
      // _touchend_ event don't provide pageX nor pageY information
      if (event.type === 'touchend')
        p = this.bc.active ? this.bc.dest.clone() : new Point();
      else {
        // Touch events can have more than one touch, so `pageX` must be obtained from `touches[0]`
        const
          x = event.originalEvent.touches ? event.originalEvent.touches[0].pageX : event.pageX,
          y = event.originalEvent.touches ? event.originalEvent.touches[0].pageY : event.pageY;
        p = new Point(x - this.$div.offset().left, y - this.$div.offset().top);
      }

      switch (event.type) {
        case 'click':
          if (target && target !== this.currentTarget) {
            if (this.currentTarget) {
              if (this.bc && this.bc.active)
                this.bc.end();
              this.swapTargets(target, this.currentTarget);
              this.setCurrentTarget(null);

              if (!this.$checkButton) {
                // Check and notify action
                const
                  cellsAtPlace = this.countSolvedTargets(),
                  ok = target.pos === target.num;
                this.ps.reportNewAction(this.act, 'PLACE', target.text, target.pos, ok, cellsAtPlace);

                // End activity or play event sound
                if (ok && cellsAtPlace === this.targets.length)
                  this.finishActivity(true);
                else
                  this.playEvent(ok ? 'actionOk' : 'actionError');
              }
            } else {
              this.setCurrentTarget(target);
              this.bc.begin(p);
              this.playEvent('click');
            }
          }
          break;

        case 'mousemove':
          this.bc.moveTo(p);
          break;

        default:
          break;
      }
      event.preventDefault();
      return true;
    }
  }
}

// Properties and methods specific to OrderTextPanel
Object.assign(OrderTextPanel.prototype, {
  /**
   * Currently selected text target
   * @name module:activities/text/OrderText.OrderTextPanel#currentTarget
   * @type {module:activities/text/TextActivityDocument.TextActivityDocument.TextTarget} */
  currentTarget: null,
  /**
   * The box connector
   * @name module:activities/text/OrderText.OrderTextPanel#bc
   * @type {module:boxes/BoxConnector.BoxConnector} */
  bc: null,
  /**
   * List of mouse, touch and keyboard events intercepted by this panel
   * @override
   * @name module:activities/text/OrderText.OrderTextPanel#events
   * @type {string[]} */
  events: ['click', 'mousemove'],
});

/**
 * Panel class associated to this type of activity: {@link module:activities/text/OrderText.OrderTextPanel OrderTextPanel}
 * @type {class} */
OrderText.Panel = OrderTextPanel;

// Register activity class
/* harmony default export */ const text_OrderText = (src_Activity.registerClass('@text.Order', OrderText));

;// CONCATENATED MODULE: ./src/activities/text/Complete.js
/**
 *  File    : activities/text/Complete.js
 *  Created : 20/06/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */




/**
 * This type of text activity suggests users to complete a given text, without any help on where to
 * write the missing words or phrases.
 * @extends module:activities/text/TextActivityBase.TextActivityBase
 */
class Complete extends TextActivityBase {
  /**
   * Complete constructor
   * @param {module:project/JClicProject.JClicProject} project - The project to which this activity belongs
   */
  constructor(project) {
    super(project);
  }
}

/**
 * The {@link module:activities/text/TextActivityBase.TextActivityBasePanel TextActivityBasePanel} where {@link module:activities/text/Complete.Complete Complete} activities are played.
 * @extends module:activities/text/TextActivityBasePanel.TextActivityBasePanel
 */
class CompletePanel extends TextActivityBasePanel {
  /**
   * CompletePanel constructor
   * @param {module:Activity.Activity} act - The {@link module:Activity.Activity Activity} to which this Panel belongs
   * @param {module:JClicPlayer.JClicPlayer} ps - Any object implementing the methods defined in the
   * [PlayStation](http://projectestac.github.io/jclic/apidoc/edu/xtec/jclic/PlayStation.html) Java interface.
   * @param {external:jQuery} [$div] - The jQuery DOM element where this Panel will deploy
   */
  constructor(act, ps, $div) {
    super(act, ps, $div);
  }

  /**
   * Creates a target DOM element for the provided target.
   * @override
   * @param {module:activities/text/TextActivityDocument.TextTarget} _target - The target related to the DOM object to be created
   * @param {external:jQuery} _$span -  - An initial DOM object (usually a `span`) that can be used
   * to store the target, or replaced by another type of object.
   * @returns {external:jQuery} - The jQuery DOM element loaded with the target data.
   */
  $createTargetElement(_target, _$span) {
    // Targets are always hidden in this type of activities
    return null;
  }

  /**
   * Called when the activity starts playing
   * @override
   */
  startActivity() {
    super.startActivity();
    this.$div.find('.JClicTextDocument').attr('contenteditable', 'true').attr('spellcheck', 'false');
  }

  /**
   * Evaluates all the targets in this panel. This method is usually called from the `Check` button.
   * @override
   * @returns {boolean} - `true` when all targets are OK, `false` otherwise.
   */
  evaluatePanel() {
    // TODO: Mark errors!
    const
      currentText = this.$div.find('.JClicTextDocument').text().trim(),
      originalText = this.act.document.getRawText(),
      ok = this.act.ev.checkText(currentText, originalText);

    this.ps.reportNewAction(this.act, 'WRITE', currentText, originalText, ok, this.targets.length);

    if (ok) {
      this.finishActivity(true);
      return true;
    } else {
      this.playEvent('finishedError');
    }
    return false;
  }

  /**
   * Ordinary ending of the activity, usually called form `processEvent`
   * @param {boolean} result - `true` if the activity was successfully completed, `false` otherwise
   */
  finishActivity(result) {
    this.$div.find('.JClicTextDocument').attr('contenteditable', 'false');
    return super.finishActivity(result);
  }
}

/**
 * Panel class associated to this type of activity: {@link module:activities/text/Complete.CompletePanel CompletePanel}
 * @type {class} */
Complete.Panel = CompletePanel;

// Register activity class
/* harmony default export */ const text_Complete = (src_Activity.registerClass('@text.Complete', Complete));

;// CONCATENATED MODULE: ./src/activities/text/IdentifyText.js
/**
 *  File    : activities/text/Identify.js
 *  Created : 20/06/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */




/**
 * This type of text activity suggests users to click on specific words or single letters of a
 * given text, without any help on where these elements are placed.
 * @extends module:activities/text/TextActivityBase.TextActivityBase
 */
class IdentifyText extends TextActivityBase {
  /**
   * IdentifyText constructor
   * @param {module:project/JClicProject.JClicProject} project - The project to which this activity belongs
   */
  constructor(project) {
    super(project);
  }
}

/**
 * The {@link module:activities/text/TextActivityBase.TextActivityBasePanel TextActivityBasePanel} where {@link module:activities/text/IdentifyText.IdentifyText IdentifyText} activities are played.
 * @extends module:activities/text/TextActivityBase.TextActivityBasePanel
 */
class IdentifyTextPanel extends TextActivityBasePanel {
  /**
   * IdentifyTextPanel constructor
   * @param {module:Activity.Activity} act - The {@link module:Activity.Activity Activity} to which this Panel belongs
   * @param {module:JClicPlayer.JClicPlayer} ps - Any object implementing the methods defined in the
   * [PlayStation](http://projectestac.github.io/jclic/apidoc/edu/xtec/jclic/PlayStation.html) Java interface.
   * @param {external:jQuery} [$div] - The jQuery DOM element where this Panel will deploy
   */
  constructor(act, ps, $div) {
    super(act, ps, $div);
    this.spanText = true;
    this.spanChars = act.type === 'identifyChars';
    this.spansChecked = new Set();
  }

  /**
   * Creates a target DOM element for the provided target.
   * @override
   * @param {module:activities/text/TextActivityDocument.TextTarget} target - The target related to the DOM object to be created
   * @param {external:jQuery} $span -  - An initial DOM object (usually a `span`) that can be used
   * to store the target, or replaced by another type of object.
   * @returns {external:jQuery} - The jQuery DOM element loaded with the target data.
   */
  $createTargetElement(target, $span) {
    super.$createTargetElement(target, $span);
    const idLabel = `target${`000${this.targets.length - 1}`.slice(-3)}`;
    $span.bind('click', event => {
      event.textTarget = target;
      event.idLabel = idLabel;
      this.processEvent(event);
    });
    return $span;
  }

  $createSpanElement($span) {
    $span.bind('click', event => {
      event.$spanElement = $span;
      this.processEvent(event);
    });
    return $span;
  }

  /**
   * Basic initialization procedure
   * @override
   */
  initActivity() {
    super.initActivity(this);
    this.$div.find('.JClicTextDocument > p').css('cursor', 'pointer');
    this.$div.find('.JClicTextDocument > span').css('cursor', 'pointer');
    // Clean possible previous errors
    this.spansChecked.forEach($spanElement => $spanElement.css($spanElement.initialCSS || this.act.document.style['default'].css));
    this.spansChecked.clear();
    this.playing = true;
  }

  /**
   * Counts the number of targets that are solved
   * @returns {number}
   */
  countSolvedTargets() {
    return this.targets.filter(({ targetStatus }) => targetStatus === 'SOLVED').length;
  }

  /**
   * Evaluates all the targets in this panel. This method is usually called from the `Check` button.
   * @override
   * @returns {boolean} - `true` when all targets are OK, `false` otherwise.
   */
  evaluatePanel() {
    let targetsOk = 0;
    this.targets.forEach(target => {
      const ok = target.targetStatus === 'SOLVED';
      if (ok)
        targetsOk++;
      target.checkColors();
      this.ps.reportNewAction(this.act, 'SELECT', target.text, target.pos, ok, targetsOk);
    });


    if (targetsOk === this.targets.length && this.spansChecked.size === 0) {
      this.finishActivity(true);
      return true;
    } else {
      // Mark selected spans as error
      this.spansChecked.forEach($spanElement => $spanElement.css(this.act.document.style['targetError'].css));
      this.playEvent('finishedError');
    }
    return false;
  }

  /**
   * Ordinary ending of the activity, usually called form `processEvent`
   * @override
   * @param {boolean} result - `true` if the activity was successfully completed, `false` otherwise
   */
  finishActivity(result) {
    this.$div.find('.JClicTextDocument > p').css('cursor', 'pointer');
    return super.finishActivity(result);
  }

  /**
   * Main handler used to process mouse, touch, keyboard and edit events.
   * @override
   * @param {external:Event} event - The HTML event to be processed
   * @returns {boolean} - When this event handler returns `false`, jQuery will stop its
   * propagation through the DOM tree. See: {@link http://api.jquery.com/on}
   */
  processEvent(event) {
    if (!super.processEvent(event) ||
      event.timeStamp === this.lastTimeStamp)
      return false;

    if (event.timeStamp)
      this.lastTimeStamp = event.timeStamp;

    const target = event.textTarget;
    const $spanElement = event.$spanElement;

    switch (event.type) {
      case 'click':
        let text, pos, ok = false;
        if (target) {
          if (target.targetStatus === 'SOLVED')
            target.targetStatus = 'HIDDEN';
          else {
            target.targetStatus = 'SOLVED';
            ok = true;
          }
          text = target.text;
          pos = target.pos;
          // TODO: Just on/off target colors, don't mark it as error!
          target.checkColors();
        } else {
          if ($spanElement) {
            $spanElement.checked = !$spanElement.checked;
            if ($spanElement.checked) {
              this.spansChecked.add($spanElement);
              $spanElement.css(this.act.document.style.target.css);
            }
            else {
              this.spansChecked.delete($spanElement);
              $spanElement.css($spanElement.initialCSS || this.act.document.style.default.css);
            }
            text = $spanElement.text();
          }
          else
            text = 'unknown';
          pos = 0;
        }

        if (!this.$checkButton) {
          // Check and notify action
          const cellsAtPlace = this.countSolvedTargets();
          this.ps.reportNewAction(this.act, 'SELECT', text, pos, ok, cellsAtPlace);

          // End activity or play event sound
          if (ok && this.spansChecked.size === 0 && cellsAtPlace === this.targets.length)
            this.finishActivity(true);
          else
            this.playEvent(ok ? 'actionOk' : 'actionError');
        }
        event.preventDefault();
        break;

      default:
        break;
    }
    return true;
  }
}

Object.assign(IdentifyTextPanel.prototype, {
  /**
   * Flag indicating if targets must be visually marked when the activity begins. In this type of
   * activity should be always `false` to avoid revealing the words o letters that must be found.
   * @name module:activities/text/IdentifyText.IdentifyTextPanel#targetsMarked
   * @type {boolean} */
  targetsMarked: false,
  /**
   * Used to avoid duplicate event processing
   * @name module:activities/text/IdentifyText.IdentifyTextPanel#lastTimeStamp
   * @type {number}
   */
  lastTimeStamp: 0,
  /**
   * Set of non-target spans currently selected by the player.
   * This attribute should be empty to solve the activity.
   * @name module:activities/text/IdentifyText.IdentifyTextPanel#spansChecked
   * @type {set} */
  spansChecked: new Set(),
});

/**
 * Panel class associated to this type of activity: {@link module:activities/text/IdentifyText.IdentifyTextPanel IdentifyTextPanel}
 * @type {class} */
IdentifyText.Panel = IdentifyTextPanel;

// Register activity class
/* harmony default export */ const text_IdentifyText = (src_Activity.registerClass('@text.Identify', IdentifyText));

;// CONCATENATED MODULE: ./src/boxes/BoxBag.js
/**
 *  File    : boxes/BoxBag.js
 *  Created : 21/04/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Catalan Educational Telematic Network (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */





/**
 * BoxBag is a class derived from {@link module:boxes/AbstractBox.AbstractBox AbstractBox} that contains a collection of "boxes"
 * (objects also derived from {@link module:boxes/AbstractBox.AbstractBox AbstractBox}). This class implements methods to add, remove
 * and retrieve boxes, and to manage some of its properties like visibility, status, location and size.
 * @extends module:boxes/AbstractBox.AbstractBox
 */
class BoxBag extends boxes_AbstractBox {
  /**
   * BoxBag constructor
   * @param {module:boxes/AbstractBox.AbstractBox} [parent] - The AbstractBox to which this box bag belongs
   * @param {module:AWT.Container} [container] - The container where this box bag is placed.
   * @param {module:boxes/BoxBase.BoxBase} [boxBase] - The object where colors, fonts, border and other graphic properties
   */
  constructor(parent, container, boxBase) {
    // BoxBag extends AbstractBox
    super(parent, container, boxBase);
    this.preferredBounds = new Rectangle();
    this.cells = [];
  }

  /**
   * Static method that sets the position and dimension of a `Resizable` object based on a
   * preferred maximum dimension and a margin.
   * @param {module:AWT.Dimension} preferredMaxSize - The preferred maximum size
   * @param {Resizable} rs - A resizable object implementing the methods described in the
   * {@link http://projectestac.github.io/jclic/apidoc/edu/xtec/jclic/boxes/Resizable.html Resizable}
   * interface of JClic. Currently a {@link module:boxes/BoxBag.BoxBag BoxBag} or {@link module:boxes/TextGrid.TextGrid TextGrid}.
   * @param {number} margin - The margin between the available area and the BoxBag
   * @returns {module:AWT.Dimension} - The resulting size of the container
   */
  static layoutSingle(preferredMaxSize, rs, margin) {

    // Avoid exceptions when rs is null
    if (!rs)
      return preferredMaxSize;

    // optimal, maximal and minimal dimensions
    let
      d = rs.getPreferredSize(),
      minSize = rs.getMinimumSize(),
      maxSize = preferredMaxSize;

    // remove margins
    maxSize.width -= 2 * margin;
    maxSize.height -= 2 * margin;
    // correct maxSize if less than minSize
    if (minSize.width > maxSize.width || minSize.height > maxSize.height) {
      maxSize = minSize;
    }
    // compute scale factor
    let scale = d.width > maxSize.width ? maxSize.width / d.width : 1;
    if (scale * d.height > maxSize.height)
      scale = maxSize.height / d.height;

    // resize the `Resizable` object
    d = rs.getScaledSize(scale);
    rs.setBounds(margin, margin, d.width, d.height);

    // restore margins
    d.width += 2 * margin;
    d.height += 2 * margin;

    return d;
  }

  /**
   * Static method that sets the position and dimension of two `Resizable` objects based on a
   * preferred maximum size, a layout schema and a margin.
   * @param {module:AWT.Dimension} desiredMaxSize - The preferred maximum size
   * @param {Resizable} rsA - First resizable object implementing the methods described in the
   * {@link http://projectestac.github.io/jclic/apidoc/edu/xtec/jclic/boxes/Resizable.html Resizable}
   * interface of JClic. Currently a {@link module:boxes/BoxBag.BoxBag BoxBag} or {@link module:boxes/TextGrid.TextGrid TextGrid}.
   * @param {Resizable} rsB - Second resizable object
   * @param {string} boxGridPos - The layout schema. Possible values are:
   * - "AB" (_A_ at left, _B_ at right)
   * - "BA" (_B_ at left, _A_ at right)
   * - "AUB" (_A_ above _B_)
   * - "BUA" (_A_ below _B_).
   * @param {number} margin - The margin between the available area and the BoxBag
   * @returns {module:AWT.Dimension} - The resulting size of the container
   */
  static layoutDouble(desiredMaxSize, rsA, rsB, boxGridPos, margin) {
    // number of horizontal and vertical grid lines
    let
      isHLayout = false,
      nbh = 1,
      nbv = 1;
    switch (boxGridPos) {
      case 'AB':
      case 'BA':
        nbh = 2;
        nbv = 1;
        isHLayout = true;
        break;
      case 'AUB':
      case 'BUA':
        nbh = 1;
        nbv = 2;
        isHLayout = false;
        break;
    }
    const
      ra = rsA.getBounds(),
      rb = rsB.getBounds();

    // optimal dimensions
    let
      da = rsA.getPreferredSize(),
      db = rsB.getPreferredSize();

    const d = new Dimension(
      isHLayout ? da.width + db.width : Math.max(da.width, db.width),
      isHLayout ? Math.max(da.height, db.height) : da.height + db.height
    );

    // minimal dimensions
    const
      minSizeA = rsA.getMinimumSize(),
      minSizeB = rsB.getMinimumSize(),
      minSize = new Dimension(
        isHLayout ? minSizeA.width + minSizeB.width : Math.max(minSizeA.width, minSizeB.width),
        isHLayout ? Math.max(minSizeA.height, minSizeB.height) : minSizeA.height + minSizeB.height
      ),
      maxSize = desiredMaxSize;

    // remove margins
    maxSize.width -= (1 + nbh) * margin;
    maxSize.height -= (1 + nbv) * margin;

    // correct maxSize if less than minSize
    if (minSize.width > maxSize.width || minSize.height > maxSize.height)
      maxSize.setDimension(minSize);

    // compute scale factor
    let scale = d.width > maxSize.width ? maxSize.width / d.width : 1;
    if (scale * d.height > maxSize.height)
      scale = maxSize.height / d.height;

    //
    // correct possible minimal infractions
    // ...
    // resize
    da = rsA.getScaledSize(scale);
    db = rsB.getScaledSize(scale);

    // set margins to center one box relative to the other
    let
      dah = db.width > da.width ? (db.width - da.width) / 2 : 0,
      dbh = da.width > db.width ? (da.width - db.width) / 2 : 0,
      dav = db.height > da.height ? (db.height - da.height) / 2 : 0,
      dbv = da.height > db.height ? (da.height - db.height) / 2 : 0;

    switch (boxGridPos) {
      case 'AB':
        rsA.setBounds(margin, margin + dav, da.width, da.height);
        rsB.setBounds(2 * margin + da.width, margin + dbv, db.width, db.height);
        break;
      case 'BA':
        rsB.setBounds(margin, margin + dbv, db.width, db.height);
        rsA.setBounds(2 * margin + db.width, margin + dav, da.width, da.height);
        break;
      case 'AUB':
        rsA.setBounds(margin + dah, margin, da.width, da.height);
        rsB.setBounds(margin + dbh, 2 * margin + da.height, db.width, db.height);
        break;
      case 'BUA':
        rsB.setBounds(margin + dbh, margin, db.width, db.height);
        rsA.setBounds(margin + dah, 2 * margin + db.height, da.width, da.height);
        break;
      default:
        rsA.setBounds(
          Math.round(margin + scale * ra.pos.x),
          Math.round(margin + scale * ra.pos.y),
          da.width, da.height);
        rsB.setBounds(
          Math.round(margin + scale * rb.pos.x),
          Math.round(margin + scale * rb.pos.y),
          da.width, da.height);
        break;
    }

    // recompute 'd' adding margins
    const r = new Rectangle(rsA.getBounds());
    r.add(rsB.getBounds());
    d.width = r.dim.width + 2 * margin;
    d.height = r.dim.height + 2 * margin;

    return d;
  }

  /**
   * Gets the preferred size of this `BoxBag`
   * @returns {module:AWT.Dimension}
   */
  getPreferredSize() {
    return this.preferredBounds.dim;
  }

  /**
   * Gets the minimum size requested by this `BoxBag`
   * @returns {module:AWT.Dimension}
   */
  getMinimumSize() {
    const d = this.getPreferredSize();
    return new Dimension(
      Math.max(settings.MIN_CELL_SIZE, d.width),
      Math.max(settings.MIN_CELL_SIZE, d.height));
  }

  /**
   * Scales the current size of this box bag, multiplying all values by a specific factor
   * @param {number} scale - The scale factor
   * @returns {module:AWT.Dimension}
   */
  getScaledSize(scale) {
    const d = this.getPreferredSize();
    return new Dimension(Math.round(scale * d.width), Math.round(scale * d.height));
  }

  /**
   * Adds an {@link module:boxes/AbstractBox.AbstractBox AbstractBox} to the collection of cells
   * @param {module:boxes/AbstractBox.AbstractBox} bx - The box to add
   */
  addBox(bx) {
    this.cells.push(bx);
    bx.setParent(this);

    if (this.cells.length === 1)
      Rectangle.prototype.setBounds.call(this, bx);
    else
      this.add(bx);

    this.preferredBounds.setBounds(this.getBounds());
  }

  /**
   * Returns the index of a specific box in the `cells` array
   * @param {module:boxes/AbstractBox.AbstractBox} bx
   * @returns {number}
   */
  boxIndex(bx) {
    return bx === null ? -1 : this.cells.indexOf(bx);
  }

  /**
   * Returns the box at a specific index in the `cells` array
   * @param {number} n - The index
   * @returns {module:boxes/AbstractBox.AbstractBox}
   */
  getBox(n) {
    return n < 0 || n >= this.cells.length ? null : this.cells[n];
  }

  /**
   * Gets the background box
   * @returns {module:boxes/AbstractBox.AbstractBox}
   */
  getBackgroundBox() {
    return this.backgroundBox;
  }

  /**
   * Sets the background box
   * @param {module:boxes/AbstractBox.AbstractBox} bx
   */
  setBackgroundBox(bx) {
    this.backgroundBox = bx;
    if (bx !== null) {
      bx.setParent(this);
      bx.isBackground = true;
    }
    // Add the `backgroundbox` rectangle to the global BoxBag rectangle
    Rectangle.prototype.add.call(this, bx);
    this.preferredBounds.setBounds(this.getBounds());
  }

  /**
   * Recalculates the total size of this BoxBag (useful after direct additions o deletions of
   * elements in the `cells` array).
   * Updates `preferredBounds` and the current position and size of the box bag.
   */
  recalcSize() {
    let r = this.backgroundBox ? new Rectangle(this.backgroundBox.pos, this.backgroundBox.dim) : null;
    this.cells.forEach(cell => {
      if (!r)
        r = new Rectangle(cell.pos, cell.dim);
      else
        r.add(cell);
    });
    if (!r)
      r = new Rectangle(this.pos.x, this.pos.y, 0, 0);
    this.preferredBounds.setRect(r);
    this.x = r.pos.x;
    this.y = r.pos.y;
    this.dim.width = r.dim.width;
    this.dim.height = r.dim.height;
  }

  /**
   * Returns the number of cells stored in this BoxBag
   * @returns {number}
   */
  getNumCells() {
    return this.cells.length;
  }

  /**
   * Sets the specified key - value pair to all cells of this bag.
   * @param {string} key - The key to be established
   * @param {any} value - The value, of any type
   */
  setCellAttr(key, value) {
    this.cells.forEach(bx => bx[key] = value);
    if (this.backgroundBox)
      this.backgroundBox[key] = value;
  }

  /**
   * Overrides {@link module:boxes/AbstractBox.AbstractBox#setBorder} iterating over all the cells stored in this box bag.
   * @override
   * @param {boolean} newVal - Whether to set or unset the border
   */
  setBorder(newVal) {
    this.cells.forEach(bx => bx.setBorder(newVal));
  }

  /**
   * Overrides {@link module:boxes/AbstractBox.AbstractBox#setVisible} iterating over all the cells stored in this box bag.
   * @override
   * @param {boolean} newVal - Whether to set the cells visible or not
   */
  setVisible(newVal) {
    this.cells.forEach(bx => bx.setVisible(newVal));
  }

  /**
   * Overrides {@link module:boxes/AbstractBox.AbstractBox#setAlternative} iterating over all the cells stored in this box bag.
   * @override
   * @param {boolean} newVal - Whether to set or unset the cells in "alternative" mode
   */
  setAlternative(newVal) {
    super.setAlternative(newVal);
    this.cells.forEach(bx => bx.setAlternative(newVal));
  }

  /**
   * Overrides {@link module:boxes/AbstractBox.AbstractBox#setBounds} adjusting the position and size of all cells
   * @override
   * @param {(AWT.Rectangle|number)} rect - An AWT.Rectangle object, or the `x` coordinate of the
   * upper-left corner of a new rectangle.
   * @param {number} [ry] - `y` coordinate of the upper-left corner of the new rectangle.
   * @param {number} [rw] - Width of the new rectangle.
   * @param {number} [rh] - Height of the new rectangle.
   */
  setBounds(rect, ry, rw, rh) {
    if (typeof rect === 'number') {
      // Arguments are co-ordinates and size
      rect = new Rectangle(rect, ry, rw, rh);
    }
    if (rect.getSurface() > 0 && !rect.equals(this)) {
      const
        scaleW = rect.dim.width / this.dim.width,
        scaleH = rect.dim.height / this.dim.height,
        dx = rect.pos.x - this.pos.x,
        dy = rect.pos.y - this.pos.y;
      this.cells.forEach(bx => {
        const p = new Point(bx.pos.x - this.pos.x, bx.pos.y - this.pos.y);
        bx.setBounds(
          dx + this.pos.x + scaleW * p.x,
          dy + this.pos.y + scaleH * p.y,
          scaleW * bx.dim.width,
          scaleH * bx.dim.height);
        // Clear pos0
        bx.pos0 = null;
      });
      if (this.backgroundBox !== null) {
        const
          bx = this.backgroundBox,
          p = new Point(bx.pos.x - this.pos.x, bx.pos.y - this.pos.y);
        bx.setBounds(
          dx + this.pos.x + scaleW * p.x,
          dy + this.pos.y + scaleH * p.y,
          scaleW * bx.dim.width,
          scaleH * bx.dim.height);
      }
    }
    super.setBounds(rect);
  }

  /**
   * Performs graphics operations for each cell.
   * Overrides {@link module:boxes/AbstractBox.AbstractBox#update}
   * @override
   * @param {external:CanvasRenderingContext2D} ctx - The canvas rendering context used to draw the
   * box contents.
   * @param {module:AWT.Rectangle} [dirtyRegion] - The area that must be repainted. `null` refers to the whole box.
   */
  update(ctx, dirtyRegion) {
    if (this.isEmpty() || !this.isVisible() || this.isTemporaryHidden())
      return false;

    if (dirtyRegion && !this.intersects(dirtyRegion))
      return false;

    if (this.backgroundBox !== null)
      this.backgroundBox.update(ctx, dirtyRegion);

    this.cells.forEach(bx => {
      if (!bx.isMarked())
        bx.update(ctx, dirtyRegion);
    });

    // Make a second loop to repaint marked cells
    this.cells.forEach(bx => {
      if (bx.isMarked())
        bx.update(ctx, dirtyRegion);
    });
    return true;
  }

  /**
   * Finds the first visible {@link module:boxes/AbstractBox.AbstractBox AbstractBox} located under the specified point
   * @param {module:AWT.Point} p
   * @returns {module:boxes/AbstractBox.AbstractBox}
   */
  findBox(p) {
    let result = null;
    for (let i = this.cells.length - 1; i >= 0; i--) {
      const bx = this.getBox(i);
      if (bx.isVisible() && bx.contains(p)) {
        result = bx;
        break;
      }
    }
    return result;
  }

  /**
   * Count the number of cells of this BoxBag that are in "inactive" state
   * @returns {number}
   */
  countInactiveCells() {
    return this.cells.reduce((n, bx) => bx.isInactive() ? ++n : n, 0);
  }
}

Object.assign(BoxBag.prototype, {
  /**
   * The array of cells
   * @name module:boxes/BoxBag.BoxBag#cells
   * @type {module:boxes/AbstractBox.AbstractBox[]} */
  cells: [],
  /**
   * Rectangle containing the preferred bounds of the BoxBag
   * @name module:boxes/BoxBag.BoxBag#preferredBounds
   * @type {module:AWT.Rectangle} */
  preferredBounds: new Rectangle(),
  /**
   * An optional box used as a background by this BoxBag
   * @name module:boxes/BoxBag.BoxBag#backgroundBox
   * @type {module:boxes/AbstractBox.AbstractBox} */
  backgroundBox: null,
});

/* harmony default export */ const boxes_BoxBag = (BoxBag);

;// CONCATENATED MODULE: ./src/boxes/ActiveBoxBag.js
/**
 *  File    : boxes/ActiveBoxBag.js
 *  Created : 21/04/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */





/**
 * This class is a special case of {@link module:boxes/BoxBag.BoxBag BoxBag} containing only objects of type {@link module:boxes/ActiveBox.ActiveBox ActiveBox}.
 * In addition to the members and methods of `BoxBag`, it implements specific methods to deal with
 * {@link module:boxes/ActiveBagContent.ActiveBagContent ActiveBagContent} objects and with the other specific members of `ActiveBox` like its "ids"
 * (`idOrder`, `idLoc` and `idAss`).
 * @extends module:boxes/BoxBag.BoxBag
 */
class ActiveBoxBag extends boxes_BoxBag {
  /**
   * ActiveBoxBag constructor
   * @param {module:boxes/AbstractBox.AbstractBox} [parent] - The AbstractBox to which this box bag belongs
   * @param {module:AWT.Container} [container] - The container where this box bag is placed.
   * @param {module:boxes/BoxBase.BoxBase} [boxBase] - The object where colors, fonts, border and other graphic properties
   * of this box bag are defined.
   */
  constructor(parent, container, boxBase) {
    // ActiveBoxBag extends BoxBag
    super(parent, container, boxBase);
  }

  /**
   * Adds an {@link module:boxes/ActiveBox.ActiveBox ActiveBox} to this bag
   * @param {module:boxes/ActiveBox.ActiveBox} bx - The ActiveBox to be added to this bag
   */
  addActiveBox(bx) {
    bx.idLoc = this.cells.length;
    bx.idOrder = bx.idLoc;
    return this.addBox(bx);
  }

  /**
   * Finds an ActiveBox by its relative location (`idLoc` field)
   * @param {number} idLoc
   * @returns {module:boxes/ActiveBox.ActiveBox}
   */
  getActiveBox(idLoc) {
    return this.getBox(idLoc);
  }

  /**
   * Gets the background box
   * @returns {module:boxes/ActiveBox.ActiveBox}
   */
  getBackgroundActiveBox() {
    return this.getBackgroundBox();
  }

  /**
   * Sets the content of members of this ActiveBoxBag, based on one or more {@link module:boxes/ActiveBagContent.ActiveBagContent ActiveBagContent}
   * objects.
   * @param {module:boxes/ActiveBagContent.ActiveBagContent} abc - The main bag of content
   * @param {module:boxes/ActiveBagContent.ActiveBagContent} [altAbc] - The alternative bag of content
   * @param {number} [fromIndex] - Starts taking the cell content located at this position on the bag
   * @param {number} [toCell] - Starts filling the box located at this position on the ActiveBoxBag
   * @param {number} [numCells] - Acts only with a limited number of elements.
   */
  setContent(abc, altAbc, fromIndex, toCell, numCells) {
    if (!fromIndex)
      fromIndex = 0;
    if (!toCell)
      toCell = 0;
    if (!numCells)
      numCells = this.cells.length;

    for (let i = 0; i < numCells; i++) {
      const bx = this.getActiveBox(toCell + i);
      bx.setContent(abc, fromIndex + i);
      bx.setAlternative(false);
      if (altAbc)
        bx.setAltContent(altAbc, fromIndex + i);
    }

    if (abc.backgroundContent !== null && this.getBackgroundActiveBox() !== null) {
      const bx = this.getBackgroundActiveBox();
      bx.setContent(abc.backgroundContent);
      if (abc.style !== bx.boxBase)
        bx.setBoxBase(abc.style);
    }
  }

  /**
   * Finds an ActiveBox by location
   * @param {module:AWT.Point} point - The location to search for
   * @returns {module:boxes/ActiveBox.ActiveBox}
   */
  findActiveBox(point) {
    return this.findBox(point);
  }

  /**
   * Clears the content of all boxes
   */
  clearAllBoxes() {
    this.cells.forEach(bx => bx.clear());
  }

  /**
   * Clears the content of all boxes and background box
   */
  clearAll() {
    this.clearAllBoxes();
    if (this.backgroundBox !== null)
      this.getBackgroundActiveBox().clear();
  }

  /**
   * Count the number of cells that are at its original place
   * @returns {number}
   */
  countCellsAtPlace() {
    return this.cells.reduce((n, bx) => bx.isAtPlace() ? ++n : n, 0);
  }

  /**
   * Finds the {@link module:boxes/ActiveBox.ActiveBox ActiveBox} that has the specified `idLoc` attribute
   * @param {number} idLoc - The idLoc to search for
   * @returns {module:boxes/ActiveBox.ActiveBox}
   */
  getActiveBoxWithIdLoc(idLoc) {
    return this.cells.find(bx => bx.idLoc === idLoc) || null;
  }

  /**
   * Checks if the place occupied by a cell corresponds to a cell with equivalent content.
   * @param {module:boxes/ActiveBox.ActiveBox} bx - The box to check
   * @param {boolean} checkCase - If `true`, check case when comparing texts
   * @returns {boolean}
   */
  cellIsAtEquivalentPlace(bx, checkCase) {
    return bx.isAtPlace() ||
      bx.isEquivalent(this.getActiveBoxWithIdLoc(bx.idOrder), checkCase);
  }

  /**
   * Count the number of cells that are at its original place or equivalent
   * @param {boolean} checkCase -  - If `true`, check case when comparing texts
   * @returns {number}
   */
  countCellsAtEquivalentPlace(checkCase) {
    return this.cells.reduce((n, bx) => this.cellIsAtEquivalentPlace(bx, checkCase) ? ++n : n, 0);
  }

  /**
   * Counts the number of cells that have the provided `idAss` attribute
   * @param {number} idAss - The `idAss` attribute to search
   * @returns {number}
   */
  countCellsWithIdAss(idAss) {
    return this.cells.reduce((n, bx) => bx.idAss === idAss ? ++n : n, 0);
  }

  /**
   * Resets the default `idAss` attribute on all cells
   */
  setDefaultIdAss() {
    this.cells.map(bx => bx.setDefaultIdAss());
  }

  /**
   * Shuffles the cells
   * @param {number} times - Number of times to shuffle
   * @param {boolean} fitInArea - Ensure that all cells are inside the bag rectangle
   */
  shuffleCells(times, fitInArea) {
    let nc = this.cells.length;
    if (nc >= 2) {
      // Array of AWT.Point objects
      const
        pos = [],
        idLoc = [],
        p = new Point();

      for (let i = 0; i < nc; i++) {
        const bx = this.getActiveBox(i);
        pos[i] = new Point(bx.pos);
        idLoc[i] = bx.idLoc;
      }

      for (let i = 0; i < times; i++) {
        const
          r1 = Math.floor(Math.random() * nc),
          r2 = Math.floor(Math.random() * nc);
        if (r1 !== r2) {
          p.moveTo(pos[r1]);
          pos[r1].moveTo(pos[r2]);
          pos[r2].moveTo(p);
          const j = idLoc[r1];
          idLoc[r1] = idLoc[r2];
          idLoc[r2] = j;
        }
      }

      for (let i = 0; i < nc; i++) {
        const
          bx = this.getActiveBox(i),
          px = pos[i].x,
          py = pos[i].y;
        bx.moveTo(new Point(px, py));
        if (fitInArea)
          this.fitCellsInArea([bx]);
        bx.idLoc = idLoc[i];
      }
    }
  }

  /**
   * Fits cells inside the ActiveBoxBag area. Useful when non-rectangular cells exchange its positions.
   * @param {module:boxes/ActiveBox.ActiveBox[]} boxes - The boxes to be checked
   */
  fitCellsInArea(boxes) {
    const
      maxX = this.pos.x + this.dim.width,
      maxY = this.pos.y + this.dim.height;

    boxes.forEach(bx => {
      // Save original position
      if (!bx.pos0)
        bx.pos0 = new Point(bx.pos);

      const
        px = Math.min(Math.max(bx.pos.x, this.pos.x), maxX - bx.dim.width),
        py = Math.min(Math.max(bx.pos.y, this.pos.y), maxY - bx.dim.height);
      if (px !== bx.pos.x || py !== bx.pos.y)
        bx.moveTo(new Point(px, py));
    });
  }

  /**
   * Exchange the positions of two cells inside the ActiveBoxBag area.
   * @param {module:boxes/ActiveBox.ActiveBox} bxa - The first box
   * @param {module:boxes/ActiveBox.ActiveBox} bxb - The second box
   * @param {boolean} fitInArea - Ensure that all cells are inside the bag rectangle
   */
  swapCellPositions(bxa, bxb, fitInArea) {
    // Save backup of bxb significant properties
    const
      posB = new Point(bxb.pos),
      posB0 = bxb.pos0,
      idLocB = bxb.idLoc;

    bxb.moveTo(bxa.pos0 || bxa.pos);
    bxb.pos0 = bxa.pos0;
    bxb.idLoc = bxa.idLoc;

    bxa.moveTo(posB0 || posB);
    bxa.pos0 = posB0;
    bxa.idLoc = idLocB;

    if (fitInArea)
      this.fitCellsInArea([bxa, bxb]);
  }

  /**
   * Resets the IDs of all cells
   */
  resetIds() {
    this.cells.forEach((bx, i) => {
      if (bx) {
        bx.idOrder = i;
        bx.idAss = i;
        bx.idLoc = i;
      }
    });
  }

  /**
   * Gets the index of box located in the `cells` array after the provided index, having the
   * provided `idAssValid` value as `idAss` attribute.
   * When `idAssValid` is `null` or `undefined`, search for the next cell with `idAss>0`
   * @param {number} currentItem - The index after to which start scanning
   * @param {string} [idAssValid] - The `idAss` attribute value to search
   * @returns {number}
   */
  getNextItem(currentItem, idAssValid) {
    const IDASSNOTUSED = -12345;
    if (!idAssValid)
      idAssValid = IDASSNOTUSED;
    let i = currentItem + 1;
    for (; i < this.cells.length; i++) {
      const bx = this.cells[i];
      if (!bx)
        break;
      if (idAssValid !== IDASSNOTUSED) {
        if (idAssValid === bx.idAss)
          break;
      } else if (bx.idAss >= 0)
        break;
    }
    return i;
  }

  /**
   * Builds a group of hidden `buton` elements that will act as a accessible objects associated
   * to the canvas area of this ActiveBoxBag.
   * The buttons will only be created when `CanvasRenderingContext2D` has a method named `addHitRegion`.
   * See https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Hit_regions_and_accessibility
   * for more information and supported browsers.
   * @param {external:jQuery} $canvas - The `canvas` where this `ActiveBoxBag` will deploy, wrapped up in a jQuery object
   * @param {external:jQuery} $clickReceiver - The DOM element that will be notified  when a button is clicked.
   * @param {string} [eventType] - Type of event sent to $clickReceiver. Default is `click`.
   * @returns {external:jQuery} - The $accessibleDiv member, containing the accessible elements associated to this ActiveBoxBag.
   */
  buildAccessibleElements($canvas, $clickReceiver, eventType) {
    this.$accessibleDiv = this.accessibleText !== '' ? external_jquery_default()('<div/>', { 'aria-label': this.accessibleText, tabindex: 0 }) : null;
    $canvas.append(this.$accessibleDiv);
    this.cells
      .map(a => a)
      .sort((a, b) => a.idLoc > b.idLoc ? 1 : -1)
      .forEach(bx => bx.buildAccessibleElement($canvas, $clickReceiver, this.$accessibleDiv, eventType));
    return this.$accessibleDiv;
  }
}

Object.assign(ActiveBoxBag.prototype, {
  /**
   * `div` containing the accessible elements associated to this ActiveBoxBag
   * @name module:boxes/ActiveBoxBag.ActiveBoxBag#$accessibleDiv
   * @type {external:jQuery} */
  $accessibleDiv: null,
});

/* harmony default export */ const boxes_ActiveBoxBag = (ActiveBoxBag);

;// CONCATENATED MODULE: ./src/boxes/ActiveBoxGrid.js
/**
 *  File    : boxes/ActiveBoxGrid.js
 *  Created : 19/05/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Catalan Educational Telematic Network (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */






/**
 * This class extends {@link module:boxes/ActiveBoxbag.ActiveBoxBag ActiveBoxBag} with constructors that take an argument of type
 * {@link module:shapers/Shaper.Shaper Shaper} used to build all its {@link module:boxes/ActiveBox.ActiveBox ActiveBox}components. It also maintains information
 * about the number of "rows" and "columns", useful to compute valid (integer) values when
 * resizing or moving its components.
 * @extends module:boxes/ActiveBoxBag.ActiveBoxBag
 */
class ActiveBoxGrid extends boxes_ActiveBoxBag {
  /**
   * ActiveBxGrid constructor
   * @param {module:boxes/AbstractBox.AbstractBox} parent - The AbstractBox to which this box grid belongs
   * @param {module:AWT.Container} container - The container where this box grid is placed.
   * @param {module:boxes/BoxBase} boxBase - The object where colors, fonts, border and other graphic properties
   * @param {number} px - `X` coordinate of the upper left corner of this box grid
   * @param {number} py - `Y` coordinate of the upper left corner of this box grid
   * @param {number} setWidth - Total width of the box grid
   * @param {number} setHeight - Total height of the box grid
   * @param {module:shapers/Shaper.Shaper} sh - Shaper used to build the ActiveBox objects
   */
  constructor(parent, container, boxBase, px, py, setWidth, setHeight, sh) {
    // ActiveBoxGrid derives from ActiveBoxBag
    super(parent, container, boxBase);

    this.nCols = sh.nCols;
    this.nRows = sh.nRows;

    // This will be the enclosing rectangle of this ActiveBox bag
    const r = new Rectangle(
      new Point(px, py),
      new Dimension(
        Math.round(setWidth / this.nCols) * this.nCols,
        Math.round(setHeight / this.nRows) * this.nRows));

    // Create all the [ActiveBox](ActiveBox.html) objects based on the
    // shapes provided by the [Shaper](Shaper.html)
    for (let i = 0; i < sh.nCells; i++) {
      const
        tmpSh = sh.getShape(i, r),
        bx = new boxes_ActiveBox(this, container, boxBase, i, tmpSh.getBounds());
      if (!sh.rectangularShapes)
        bx.setShape(tmpSh);
      this.addActiveBox(bx);
    }

    // If the Shaper has `remainder` (extra space), set the background box of this
    // [BoxBag](BoxBag.html)
    if (sh.hasRemainder) {
      const
        tmpSh = sh.getRemainderShape(r),
        bx = new boxes_ActiveBox(this, container, boxBase, 0, tmpSh.getBounds());
      bx.setShape(tmpSh);
      this.setBackgroundBox(bx);
    }
  }

  /**
   * This factory constructor creates a new empty grid with the number of cells indicated by the
   * {@link module:boxes/ActiveBagContent.ActiveBagContent ActiveBagContent} `abc`, not filling the cells with any content.
   * @param {module:boxes/AbstractBox.AbstractBox} parent - The AbstractBox to which this box grid belongs
   * @param {module:AWT.Container} container - The container where this box grid is placed.
   * @param {number} px - `X` coordinate of the upper left corner of this box grid
   * @param {number} py - `Y` coordinate of the upper left corner of this box grid
   * @param {module:boxes/ActiveBagContent.ActiveBagContent} abc - Used only to get the number of cells and the shaper (when `sh` is `null`)
   * @param {module:shapers/Shaper.Shaper} sh - Shaper used to build the ActiveBox objects
   * @param {module:boxes/BoxBase.BoxBase} boxBase - The object where colors, fonts, border and other graphic properties
   * of this box grid are defined.
   * @returns {module:boxes/ActiveBoxGrid.ActiveBoxGrid}
   */
  static createEmptyGrid(parent, container, px, py, abc, sh, boxBase) {
    const result = abc ? new ActiveBoxGrid(parent, container,
      boxBase || abc.style,
      px, py,
      abc.getTotalWidth(), abc.getTotalHeight(),
      sh || abc.getShaper()) : null;

    if (result)
      result.setBorder(abc.border);

    return result;
  }

  /**
   * Gets the minimum size of this grid
   * @returns {module:AWT.Dimension}
   */
  getMinimumSize() {
    return new Dimension(
      settings.MIN_CELL_SIZE * this.nCols,
      settings.MIN_CELL_SIZE * this.nRows);
  }

  /**
   * Gets a scaled size of this grid, rounded to the nearest integer values
   * @param {number} scale - The scale factor
   * @returns {module:AWT.Dimension}
   */
  getScaledSize(scale) {
    return new Dimension(
      roundTo(scale * this.preferredBounds.dim.width, this.nCols),
      roundTo(scale * this.preferredBounds.dim.height, this.nRows));
  }

  /**
   * Returns the logical coordinates of the provided {@link module:boxes/ActiveBox.ActiveBox ActiveBox}.
   * The units of the result are not pixels, but ordinal numbers (relative positions) of columns
   * and rows in the grid.
   * @param {module:boxes/ActiveBox.ActiveBox} bx - The box to process
   * @returns {module:AWT.Point}
   */
  getCoord(bx) {
    return new Point(bx.idLoc % this.nCols, Math.floor(bx.idLoc / this.nCols));
  }

  /**
   * Calculates the logical distance between two {@link module:boxes/ActiveBox.ActiveBox ActiveBox} objects.
   * Resulting units are not pixels, but ordinal numbers (relative positions) of columns and rows
   * in the grid.
   * @param {module:boxes/ActiveBox.ActiveBox} src - First box
   * @param {module:boxes/ActiveBox.ActiveBox} dest - Second box
   * @returns {module:AWT.Point}
   */
  getCoordDist(src, dest) {
    const
      ptSrc = this.getCoord(src),
      ptDest = this.getCoord(dest);
    return new Point(ptDest.x - ptSrc.x, ptDest.y - ptSrc.y);
  }
}

Object.assign(ActiveBoxGrid.prototype, {
  /**
   * Number of columns of this box grid
   * @name module:boxes/ActiveBoxGrid.ActiveBoxGrid#nCols
   * @type {number} */
  nCols: 1,
  /**
   * Number of rows of this box grid
   * @name module:boxes/ActiveBoxGrid.ActiveBoxGrid#nRows
   * @type {number} */
  nRows: 1,
});

/* harmony default export */ const boxes_ActiveBoxGrid = (ActiveBoxGrid);

;// CONCATENATED MODULE: ./src/activities/text/WrittenAnswer.js
/**
 *  File    : activities/text/WrittenAnswer.js
 *  Created : 04/06/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */









/**
 * This class of {@link module:Activity.Activity Activity} shows a panel with {@link module:boxes/ActiveBox.ActiveBox ActiveBox} objects acting as cells
 * with questions. The answers to these questions must be written in a separate text field.
 *
 * The ActiveBox objects are filled with data stored in {@link module:boxes/ActiveBagContent.ActiveBagContent ActiveBagContent} repositories.
 *
 * A second {@link module:boxes/ActiveBagContent.ActiveBagContent ActiveBagContent} can be used as alternative content, revealed as the questions
 * are solved.
 * @extends module:Activity.Activity
 */
class WrittenAnswer extends Activity {
  /**
   * WrittenAnswer constructor
   * @param {module:project/JClicProject.JClicProject} project - The JClic project to which this activity belongs
   */
  constructor(project) {
    super(project);
  }

  /**
   * Loads this object settings from an XML element
   * @override
   * @param {external:jQuery} $xml - The jQuery XML element to parse
   */
  setProperties($xml) {
    super.setProperties($xml);
    this.abc['primary'].avoidAllIdsNull(this.abc['answers'].getNumCells());
  }

  /**
   * Retrieves the minimum number of actions needed to solve this activity
   * @override
   * @returns {number}
   */
  getMinNumActions() {
    return this.invAss ?
      this.abc['answers'].getNumCells() :
      this.abc['primary'].getNumCells() - this.nonAssignedCells;
  }

  /**
   * This activity uses random values to shuffle its internal components
   * @override
   * @returns {boolean}
   */
  hasRandom() {
    return true;
  }

  /**
   * This activity makes use of the keyboard
   * @override
   * @returns {boolean}
   */
  needsKeyboard() {
    return true;
  }

  /**
   * This activity can permit the user to display the solution
   * @override
   * @returns {boolean}
   */
  helpSolutionAllowed() {
    return true;
  }
}

Object.assign(WrittenAnswer.prototype, {
  /**
   * Number of unassigned cells
   * @name module:activities/text/WrittenAnswer.WrittenAnswer#nonAssignedCells
   * @type {number} */
  nonAssignedCells: 0,
  /**
   * Whether to use or not the cell's `idAss` field to check if pairings match
   * @name module:activities/text/WrittenAnswer.WrittenAnswer#useIdAss
   * @type {boolean} */
  useIdAss: true,
});

/**
 * The {@link module:Activity.ActivityPanel ActivityPanel} where {@link module:activities/text/WrittenAnswer.WrittenAnswer WrittenAnswer} activities are played.
 * @extends module:Activity.ActivityPanel
 */
class WrittenAnswerPanel extends ActivityPanel {
  /**
   * WrittenAnswerPanel constructor
   * @param {module:Activity.Activity} act - The {@link module:Activity.Activity Activity} to which this Panel belongs
   * @param {module:JClicPlayer.JClicPlayer} ps - Any object implementing the methods defined in the
   * [PlayStation](http://projectestac.github.io/jclic/apidoc/edu/xtec/jclic/PlayStation.html) Java interface.
   * @param {external:jQuery} [$div] - The jQuery DOM element where this Panel will deploy
   */
  constructor(act, ps, $div) {
    super(act, ps, $div);
  }

  /**
   * Performs miscellaneous cleaning operations
   * @override
   */
  clear() {
    if (this.bgA) {
      this.bgA.end();
      this.bgA = null;
    }
    if (this.bgB) {
      this.bgB.end();
      this.bgB = null;
    }
  }

  /**
   * Prepares the visual components of the activity
   * @override
   */
  buildVisualComponents() {
    if (this.firstRun)
      super.buildVisualComponents();

    this.clear();

    const
      abcA = this.act.abc['primary'],
      abcB = this.act.abc['answers'],
      solved = this.act.abc['solvedPrimary'];

    if (abcA && abcB) {
      if (this.act.invAss)
        this.invAssCheck = Array(abcB.getNumCells()).fill(false);

      if (abcA.image) {
        abcA.setImgContent(this.act.project.mediaBag, null, false);
        if (abcA.animatedGifFile && !abcA.shaper.rectangularShapes && !this.act.shuffleA)
          this.$animatedBg = external_jquery_default()('<span/>').css({
            'background-image': 'url(' + abcA.animatedGifFile + ')',
            'background-position': 'center',
            'background-repeat': 'no-repeat',
            position: 'absolute'
          }).appendTo(this.$div);
      }

      if (solved && solved.image)
        solved.setImgContent(this.act.project.mediaBag, null, false);

      if (this.act.acp !== null) {
        const contentKit = [abcA, abcB];
        if (solved)
          contentKit.push(solved);
        this.act.acp.generateContent(abcA.nch, abcA.ncw, contentKit, false);
      }

      this.bgA = boxes_ActiveBoxGrid.createEmptyGrid(null, this, this.act.margin, this.act.margin, abcA);

      let w = abcB.w;
      if (this.act.boxGridPos === 'AUB' || this.act.boxGridPos === 'BUA')
        w = abcA.getTotalWidth();
      //
      // bgB will be used only as a placeholder for `$textField`
      this.bgB = new boxes_ActiveBoxGrid(null, this, abcB.style, this.act.margin, this.act.margin, w, abcB.h, new shapers_Rectangular(1, 1));
      this.$form = external_jquery_default()('<form/>', { id: 'form1' /*, action: '#' */ });
      // Modified 05/Feb/2020: jQuery not catching submit event when on first activity
      this.$form[0].addEventListener('submit', event => {
        event.preventDefault();
        if (this.playing)
          this.setCurrentCell(this.currentCell);
        return false;
      });

      this.$textField = external_jquery_default()('<input/>', { type: 'text', size: 200 })
        .css(abcB.style.getCSS())
        .css({
          position: 'absolute', top: 0, left: 0,
          border: 0, padding: 0, margin: 0,
          'text-align': 'center'
        })
        .attr({
          autocomplete: 'off',
          autocorrect: 'off',
          autocapitalize: 'off',
          spellcheck: 'false',
        });

      this.$div.append(this.$form.append(this.$textField));
      this.bgA.setContent(abcA, solved || null);
      this.bgA.setDefaultIdAss();
      if (this.$animatedBg)
        this.bgA.setCellAttr('tmpTrans', true);

      this.act.nonAssignedCells = 0;
      for (let i = 0; i < this.bgA.getNumCells(); i++) {
        var bx = this.bgA.getActiveBox(i);
        if (bx.idAss === -1) {
          this.act.nonAssignedCells++;
          bx.switchToAlt(this.ps);
        }
      }
      this.bgA.setVisible(true);
      this.bgB.setVisible(false);
    }
  }

  /**
   * Basic initialization procedure
   * @override
   */
  initActivity() {
    super.initActivity();
    if (!this.firstRun)
      this.buildVisualComponents();
    else
      this.firstRun = false;

    if (this.bgA && this.bgB) {
      // Scramble cells
      if (this.act.shuffleA)
        this.shuffle([this.bgA], true, true);

      if (this.useOrder)
        this.currentItem = this.bgA.getNextItem(-1);

      this.setAndPlayMsg('initial', 'start');
      this.invalidate().update();
      this.playing = true;
    }
  }

  /**
   * Called by [JClicPlayer](JClicPlayer.html) when this activity panel is fully visible, just
   * after the initialization process.
   * @override
   */
  activityReady() {
    super.activityReady();
    this.setCurrentCell(0);
  }

  /**
   * Updates the graphic content of this panel.
   * This method will be called from {@link module:AWT.Container#update} when needed.
   * @override
   * @param {module:AWT.Rectangle} dirtyRegion - Specifies the area to be updated. When `null`,
   * it's the whole panel.
   */
  updateContent(dirtyRegion) {
    super.updateContent(dirtyRegion);
    if (this.bgA && this.$canvas) {
      const
        canvas = this.$canvas.get(-1),
        ctx = canvas.getContext('2d');
      if (!dirtyRegion)
        dirtyRegion = new Rectangle(0, 0, canvas.width, canvas.height);
      ctx.clearRect(dirtyRegion.pos.x, dirtyRegion.pos.y, dirtyRegion.dim.width, dirtyRegion.dim.height);
      this.bgA.update(ctx, dirtyRegion);
    }
    return this;
  }

  /**
   * Sets the real dimension of this panel.
   * @override
   * @param {module:AWT.Dimension} preferredMaxSize - The maximum surface available for the activity panel
   * @returns {module:AWT.Dimension}
   */
  setDimension(preferredMaxSize) {
    return (!this.bgA || !this.bgB || this.getBounds().equals(preferredMaxSize)) ?
      preferredMaxSize :
      boxes_BoxBag.layoutDouble(preferredMaxSize, this.bgA, this.bgB, this.act.boxGridPos, this.act.margin);
  }

  /**
   * Sets the size and position of this activity panel
   * @override
   * @param {module:AWT.Rectangle} rect
   */
  setBounds(rect) {
    if (this.$canvas)
      this.$canvas.remove();

    super.setBounds(rect);
    if (this.bgA || this.bgB) {
      const r = rect.clone();
      if (this.act.boxGridPos === 'AUB')
        r.height -= this.bgB.pos.y + this.act.margin / 2;
      else if (this.act.boxGridPos === 'AB')
        r.width -= this.bgB.pos.x + this.act.margin / 2;

      // Create the main canvas
      this.$canvas = external_jquery_default()('<canvas width="' + r.dim.width + '" height="' + r.dim.height + '"/>').css({
        position: 'absolute',
        top: 0,
        left: 0
      });

      // Resize animated gif background
      if (this.bgA && this.$animatedBg) {
        var bgRect = this.bgA.getBounds();
        this.$animatedBg.css({
          left: bgRect.pos.x,
          top: bgRect.pos.y,
          width: bgRect.dim.width + 'px',
          height: bgRect.dim.height + 'px',
          'background-size': bgRect.dim.width + 'px ' + bgRect.dim.height + 'px'
        });
        this.$canvas.insertAfter(this.$animatedBg);
      } else
        this.$div.prepend(this.$canvas);

      if (this.$textField) {
        this.$textField.css({
          top: this.bgB.pos.y,
          left: this.bgB.pos.x,
          width: this.bgB.dim.width,
          height: this.bgB.dim.height,
          zIndex: 9
        });
      }
      // Repaint all
      this.invalidate().update();
    }
  }

  /**
   * Builds the accessible components needed for this ActivityPanel
   * This method is called when all main elements are placed and visible, when the activity is ready
   * to start or when resized.
   * @override
   */
  buildAccessibleComponents() {
    if (this.$canvas && this.accessibleCanvas) {
      super.buildAccessibleComponents();
      if (this.bgA)
        this.bgA.buildAccessibleElements(this.$canvas, this.$div, 'click');
      // bgB has a regular input element, so it's already accessible
    }
  }

  /**
   * Checks if all inverse associations are done
   * @returns {boolean}
   */
  checkInvAss() {
    return this.act.invAss && this.invAssCheck && this.invAssCheck.every(chk => chk);
  }

  /**
   * Updates the currently selected cell, evaluating the answer written by the user on the text field.
   * @param {number} i - Index into the {@link module:boxes/ActiveBoxbag.ActiveBoxBag ActiveBoxBag} of the cell to make active
   * @param {function[]} delayedActions - If set, store the the action in this array for future execution
   */
  setCurrentCell(i, delayedActions = null) {
    if (!this.playing)
      return;

    let
      bx = null,
      m = false;

    if (this.currentCell !== -1) {
      let ok = false;
      bx = this.bgA ? this.bgA.getActiveBoxWithIdLoc(this.currentCell) : null;
      if (bx) {
        bx.setMarked(false);
        const
          src = bx.getDescription(),
          id = bx.idAss,
          txCheck = id >= 0 ? this.act.abc['answers'].getActiveBoxContent(id).text : '',
          txAnswer = this.$textField.val().trim();
        if (compareMultipleOptions(txAnswer, txCheck, false, this.act.numericContent)) {
          ok = true;
          bx.idAss = -1;
          // When in multiple-answer, fill-in textField with the first valid option:
          const p = txCheck.indexOf('|');
          if (p >= 0)
            this.$textField.val(txCheck.substring(0, p));

          if (this.act.abc['solvedPrimary']) {
            bx.switchToAlt(this.ps);
            m = bx.playMedia(this.ps, delayedActions);
          } else
            bx.clear();
          if (this.act.invAss && id >= 0 && id < this.invAssCheck.length) {
            this.invAssCheck[id] = true;
          }
          if (this.act.useOrder)
            this.currentItem = this.bgA.getNextItem(this.currentItem);
        }

        const cellsPlaced = this.bgA.countCellsWithIdAss(-1);
        if (txAnswer.length > 0) {
          this.ps.reportNewAction(this.act, 'WRITE', src, txAnswer, ok, cellsPlaced);
        }
        if (ok && (this.checkInvAss() || cellsPlaced === this.bgA.getNumCells())) {
          this.finishActivity(true);
          this.$textField.prop('disabled', true);
          this.invalidate().update();
          return;
        } else if (!m && txAnswer.length > 0)
          this.playEvent(ok ? 'actionOk' : 'actionError');
      }
    }

    bx = this.bgA ?
      this.act.useOrder ?
        this.bgA.getBox(this.currentItem) :
        this.bgA.getActiveBoxWithIdLoc(i) :
      null;

    if (this.bgA && (!bx || bx.idAss === -1)) {
      for (var j = 0; j < this.bgA.getNumCells(); j++) {
        bx = this.bgA.getActiveBoxWithIdLoc(j);
        if (bx.idAss !== -1)
          break;
      }
      if (bx && bx.idAss === -1) {
        this.finishActivity(false);
        this.$textField.prop('disabled', true);
        this.invalidate().update();
        return;
      }
    }
    // Draw border only if it has more than one cell
    if (bx && this.bgA && this.bgA.getNumCells() > 1)
      bx.setMarked(true);
    if (bx)
      this.currentCell = bx.idLoc;
    this.$textField.val('');
    this.$textField.focus();
    this.invalidate().update();
    if (bx)
      bx.playMedia(this.ps, delayedActions);
  }

  /**
   * Main handler used to process mouse, touch, keyboard and edit events
   * @override
   * @param {external:Event} event - The HTML event to be processed
   * @returns {boolean} - When this event handler returns `false`, jQuery will stop its
   * propagation through the DOM tree. See: {@link http://api.jquery.com/on}
   */
  processEvent(event) {
    if (this.playing) {
      // Array to be filled with actions to be executed at the end of event processing
      const delayedActions = [];
      switch (event.type) {
        case 'click':
          event.preventDefault();
          this.ps.stopMedia(1);
          const p = new Point(
            event.pageX - this.$div.offset().left,
            event.pageY - this.$div.offset().top);

          // Avoid clicks on the text field
          if (this.bgB.contains(p)) {
            this.$textField.focus();
            break;
          }

          const bx = this.bgA ? this.bgA.findActiveBox(p) : null;
          if (bx && !bx.isInactive()) {
            if (bx.getContent() && bx.getContent().mediaContent === null)
              this.playEvent('CLICK');
            this.setCurrentCell(bx.idLoc, delayedActions);
          }
          break;

        case 'change':
          event.preventDefault();
          this.setCurrentCell(this.currentCell, delayedActions);
          break;
      }
      delayedActions.forEach(action => action());
      return false;
    }
  }
}

Object.assign(WrittenAnswerPanel.prototype, {
  /**
   * The input text field where users write the answers
   * @name module:activities/text/WrittenAnswer.WrittenAnswerPanel#$textField
   * @type {external:jQuery} */
  $textField: null,
  /**
   * Array for storing checked associations
   * @name module:activities/text/WrittenAnswer.WrittenAnswerPanel#invAssCheck
   * @type {boolean[]} */
  invAssCheck: null,
  /**
   * The {@link module:boxes/ActiveBoxbag.ActiveBoxBag ActiveBoxBag} object containing the questions
   * @name module:activities/text/WrittenAnswer.WrittenAnswerPanel#bgA
   * @type {module:boxes/ActiveBoxBag.ActiveBoxBag} */
  bgA: null,
  /**
   * An optional {@link module:boxes/ActiveBoxbag.ActiveBoxBag ActiveBoxBag} with content displayed as cells are solved.
   * @name module:activities/text/WrittenAnswer.WrittenAnswerPanel#bgB
   * @type {module:boxes/ActiveBoxBag.ActiveBoxBag} */
  bgB: null,
  /**
   * The currently selected cell
   * @name module:activities/text/WrittenAnswer.WrittenAnswerPanel#currentCell
   * @type {number} */
  currentCell: -1,
  /**
   * Mouse events intercepted by this panel
   * @override
   * @name module:activities/text/WrittenAnswer.WrittenAnswerPanel#events
   * @type {string[]} */
  events: ['click', 'change'],
});

/**
 * Panel class associated to this type of activity: {@link module:activities/text/WrittenAnswer.WrittenAnswerPanel WrittenAnswerPanel}
 * @type {class} */
WrittenAnswer.Panel = WrittenAnswerPanel;

// Register activity class
/* harmony default export */ const text_WrittenAnswer = (Activity.registerClass('@text.WrittenAnswer', WrittenAnswer));

;// CONCATENATED MODULE: ./src/activities/panels/InformationScreen.js
/**
 *  File    : activities/panels/InformationScreen.js
 *  Created : 19/05/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */

/* global window */







/**
 * This class of {@link module:Activity.Activity Activity} just shows a panel with {@link module:boxes/ActiveBox.ActiveBox ActiveBox} objects.
 * Because active boxes can act as a links to specific points in the project's sequence of
 * activities, this kind of activity is often used as a menu where users can choose from different
 * options.
 * @extends module:Activity.Activity
 */
class InformationScreen extends Activity {
  /**
   * InformationScreen constructor
   * @param {module:project/JClicProject.JClicProject} project - The {@link module:project/JClicProject.JClicProject JClicProject} to which this activity belongs
   */
  constructor(project) {
    super(project);
    // This kind of activities are not reported
    this.includeInReports = false;
    this.reportActions = false;
  }
}

/**
 * The {@link module:Activity.ActivityPanel ActivityPanel} where {@link module:activities/panels/InformationScreen.InformationScreen InformationScreen} activities should display its content
 * @extends module:Activity.ActivityPanel
 */
class InformationScreenPanel extends ActivityPanel {
  /**
   * InformationScreenPanel constructor
   * @param {module:Activity.Activity} act - The {@link module:Activity.Activity Activity} to which this Panel belongs
   * @param {module:JClicPlayer.JClicPlayer} ps - Any object implementing the methods defined in the
   * [PlayStation](http://projectestac.github.io/jclic/apidoc/edu/xtec/jclic/PlayStation.html) Java interface.
   * @param {external:jQuery} [$div] - The jQuery DOM element where this Panel will deploy
   */
  constructor(act, ps, $div) {
    super(act, ps, $div);
  }

  /**
   * Miscellaneous cleaning operations
   * @override
   */
  clear() {
    if (this.bg) {
      this.bg.end();
      this.bg = null;
    }
  }

  /**
   * Prepares the visual components of the activity
   * @override
   */
  buildVisualComponents() {
    if (this.firstRun)
      super.buildVisualComponents();
    this.clear();
    const abc = this.act.abc['primary'];
    if (abc) {
      if (abc.image) {
        abc.setImgContent(this.act.project.mediaBag, null, false);
        if (abc.animatedGifFile && !abc.shaper.rectangularShapes)
          this.$animatedBg = external_jquery_default()('<span/>').css({
            'background-image': `url(${abc.animatedGifFile})`,
            'background-position': 'center',
            'background-repeat': 'no-repeat',
            position: 'absolute'
          }).appendTo(this.$div);
      }

      if (this.act.acp !== null)
        this.act.acp.generateContent(abc.nch, abc.ncw, [abc], false);

      this.bg = boxes_ActiveBoxGrid.createEmptyGrid(null, this,
        this.act.margin, this.act.margin,
        abc);
      this.bg.setContent(abc);
      if (this.$animatedBg)
        this.bg.setCellAttr('tmpTrans', true);
      this.bg.setVisible(true);
    }
  }

  /**
   * Basic initialization procedure
   * @override
   */
  initActivity() {
    super.initActivity();
    if (!this.firstRun)
      this.buildVisualComponents();
    else
      this.firstRun = false;

    this.invalidate().update();
    this.setAndPlayMsg('initial', 'start');
    this.playing = true;
  }

  /**
   * Updates the graphic content of this panel.
   * This method will be called from {@link module:AWT.Container#update} when needed.
   * @override
   * @param {module:AWT.Rectangle} dirtyRegion - Specifies the area to be updated. When `null`,
   * it's the whole panel.
   */
  updateContent(dirtyRegion) {
    super.updateContent(dirtyRegion);
    if (this.bg && this.$canvas) {
      const
        canvas = this.$canvas.get(-1),
        ctx = canvas.getContext('2d');
      if (!dirtyRegion)
        dirtyRegion = new Rectangle(0, 0, canvas.width, canvas.height);
      ctx.clearRect(dirtyRegion.pos.x, dirtyRegion.pos.y, dirtyRegion.dim.width, dirtyRegion.dim.height);
      this.bg.update(ctx, dirtyRegion);
    }
    return this;
  }

  /**
   * Sets the real dimension of this panel.
   * @override
   * @param {module:AWT.Dimension} preferredMaxSize - The maximum surface available for the activity panel
   * @returns {module:AWT.Dimension}
   */
  setDimension(preferredMaxSize) {
    return this.getBounds().equals(preferredMaxSize) ?
      preferredMaxSize :
      boxes_BoxBag.layoutSingle(preferredMaxSize, this.bg, this.act.margin);
  }

  /**
   * Sets the size and position of this activity panel
   * @override
   * @param {module:AWT.Rectangle} rect
   */
  setBounds(rect) {
    if (this.$canvas)
      this.$canvas.remove();

    super.setBounds(rect);
    if (this.bg) {
      this.$canvas = external_jquery_default()('<canvas width="' + rect.dim.width + '" height="' + rect.dim.height + '"/>').css({
        position: 'absolute',
        top: 0,
        left: 0
      });
      // Resize animated gif background
      if (this.$animatedBg) {
        const bgRect = this.bg.getBounds();
        this.$animatedBg.css({
          left: bgRect.pos.x,
          top: bgRect.pos.y,
          width: `${bgRect.dim.width}px`,
          height: `${bgRect.dim.height}px`,
          'background-size': `${bgRect.dim.width}px ${bgRect.dim.height}px`
        });
      }
      this.$div.append(this.$canvas);
      this.invalidate().update();
      window.setTimeout(() => this.bg ? this.bg.buildAccessibleElements(this.$canvas, this.$div) : null, 0);
    }
  }

  /**
   * Builds the accessible components needed for this ActivityPanel
   * This method is called when all main elements are placed and visible, when the activity is ready
   * to start or when resized.
   * @override
   */
  buildAccessibleComponents() {
    if (this.$canvas && this.accessibleCanvas && this.bg) {
      super.buildAccessibleComponents();
      this.bg.buildAccessibleElements(this.$canvas, this.$div);
    }
  }

  /**
   * Main handler used to process mouse, touch, keyboard and edit events
   * @override
   * @param {external:Event} event - The HTML event to be processed
   * @returns {boolean} - When this event handler returns `false`, jQuery will stop its
   * propagation through the DOM tree. See: {@link http://api.jquery.com/on}
   */
  processEvent(event) {
    if (this.playing) {
      const p = new Point(
        event.pageX - this.$div.offset().left,
        event.pageY - this.$div.offset().top);
      // Array to be filled with actions to be executed at the end of event processing
      const delayedActions = [];
      this.ps.stopMedia(1);
      const bx = this.bg.findActiveBox(p);
      if (bx) {
        if (!bx.playMedia(this.ps, delayedActions))
          this.playEvent('click');
      }
      delayedActions.forEach(action => action());
      event.preventDefault();
    }
  }
}

Object.assign(InformationScreenPanel.prototype, {
  /**
   * The {@link module:boxes/ActiveBoxbag.ActiveBoxBag ActiveBoxBag} containing the information to be displayed.
   * @name module:activities/panels/InformationScreen.InformationScreenPanel#bg
   * @type {module:boxes/ActiveBoxBag.ActiveBoxBag} */
  bg: null,
  /**
   * List of mouse, touch and keyboard events intercepted by this panel
   * @override
   * @name module:activities/panels/InformationScreen.InformationScreenPanel#events
   * @type {string[]} */
  events: ['click'],
});

/**
 * Panel class associated to this type of activity: {@link module:activities/panels/InformationScreen.InformationScreenPanel InformationScreenPanel}
 * @type {class} */
InformationScreen.Panel = InformationScreenPanel;

// Register activity class
/* harmony default export */ const panels_InformationScreen = (Activity.registerClass('@panels.InformationScreen', InformationScreen));

;// CONCATENATED MODULE: ./src/activities/panels/Identify.js
/**
 *  File    : activities/panels/Identify.js
 *  Created : 03/06/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */

/* global window */







/**
 * The aim of this type of {@link module:Activity.Activity Activity} is to identify {@link module:boxes/ActiveBox.ActiveBox ActiveBox} elements in a panel
 * that satisfy a specific condition, usually exposed in the main message.
 * @extends module:Activity.Activity
 */
class Identify extends Activity {
  /**
   * Identify constructor
   * @param {module:project/JClicProject.JClicProject} project - The {@link module:project/JClicProject.JClicProject JClicProject} to which this activity belongs
   */
  constructor(project) {
    super(project);
  }

  /**
   * Retrieves the minimum number of actions needed to solve this activity
   * @override
   * @returns {number}
   */
  getMinNumActions() {
    return this.cellsToMatch;
  }

  /**
   * Whether or not the activity uses random to shuffle internal components
   * @override
   * @returns {boolean}
   */
  hasRandom() {
    return true;
  }
}

Object.assign(Identify.prototype, {
  /**
   * Number of not assigned cells (calculated in {@link module:activities/panels/Identify.IdentifyPanel#buildVisualComponents buildVisualComponents})
   * @name module:activities/panels/Identify.Identify#nonAssignedCells
   * @type {number} */
  nonAssignedCells: 0,
  /**
   * Number of cells the user must identify to complete the activity (calculated in
   * {@link module:activities/panels/Identify.IdentifyPanel#buildVisualComponents buildVisualComponents})
   * @name module:activities/panels/Identify.Identify#cellsToMatch
   * @type {number} */
  cellsToMatch: 1,
});

/**
 * The {@link module:Activity.ActivityPanel ActivityPanel} where {@link module:activities/panels/Identify.Identify Identify} activities are played.
 * @extends module:Activity.ActivityPanel
 */
class IdentifyPanel extends ActivityPanel {
  /**
   * IdentifyPanel constructor
   * @param {module:Activity.Activity} act - The {@link module:Activity.Activity Activity} to which this Panel belongs
   * @param {module:JClicPlayer.JClicPlayer} ps - Any object implementing the methods defined in the
   * [PlayStation](http://projectestac.github.io/jclic/apidoc/edu/xtec/jclic/PlayStation.html) Java interface.
   * @param {external:jQuery} [$div] - The jQuery DOM element where this Panel will deploy
   */
  constructor(act, ps, $div) {
    super(act, ps, $div);
  }

  /**
   * Miscellaneous cleaning operations
   * @override
   */
  clear() {
    if (this.bg) {
      this.bg.end();
      this.bg = null;
    }
  }

  /**
   * Prepares the visual components of the activity
   * @override
   */
  buildVisualComponents() {
    if (this.firstRun)
      super.buildVisualComponents();
    this.clear();
    const
      abc = this.act.abc['primary'],
      solved = this.act.abc['solvedPrimary'];
    if (abc) {
      if (abc.image) {
        abc.setImgContent(this.act.project.mediaBag, null, false);
        if (abc.animatedGifFile && !abc.shaper.rectangularShapes && !this.act.shuffleA)
          this.$animatedBg = external_jquery_default()('<span/>').css({
            'background-image': `url(${abc.animatedGifFile})`,
            'background-position': 'center',
            'background-repeat': 'no-repeat',
            position: 'absolute'
          }).appendTo(this.$div);
      }

      if (solved && solved.image)
        solved.setImgContent(this.act.project.mediaBag, null, false);

      if (this.act.acp !== null) {
        const contentKit = [abc];
        if (solved) {
          contentKit.push(null);
          contentKit.push(solved);
        }
        this.act.acp.generateContent(abc.nch, abc.ncw, contentKit, false);
      }
      this.bg = boxes_ActiveBoxGrid.createEmptyGrid(null, this,
        this.act.margin, this.act.margin,
        abc);
      this.bg.setContent(abc, solved || null);
      this.bg.setAlternative(false);
      if (this.$animatedBg)
        this.bg.setCellAttr('tmpTrans', true);
      this.bg.setDefaultIdAss();
      this.act.nonAssignedCells = 0;
      this.act.cellsToMatch = 0;
      const n = this.bg.getNumCells();
      for (let i = 0; i < n; i++) {
        const
          bx = this.bg.getActiveBox(i),
          id = bx.idAss;
        if (id === 1)
          this.act.cellsToMatch++;
        else if (id === -1) {
          this.act.nonAssignedCells++;
          bx.switchToAlt(this.ps);
        }
      }
      this.bg.setVisible(true);
    }
  }

  /**
   * Basic initialization procedure
   * @override
   */
  initActivity() {
    super.initActivity();
    if (!this.firstRun)
      this.buildVisualComponents();
    else
      this.firstRun = false;

    if (this.bg) {
      if (this.act.shuffleA)
        this.shuffle([this.bg], true, true);

      if (this.useOrder)
        this.currentItem = this.bg.getNextItem(-1);

      this.setAndPlayMsg('initial', 'start');
      this.invalidate().update();
      this.playing = true;
    }
  }

  /**
   * Updates the graphic content of this panel.
   * This method will be called from {@link module:AWT.Container#update} when needed.
   * @override
   * @param {module:AWT.Rectangle} dirtyRegion - Specifies the area to be updated. When `null`,
   * it's the whole panel.
   */
  updateContent(dirtyRegion) {
    super.updateContent(dirtyRegion);

    if (this.bg && this.$canvas) {
      const
        canvas = this.$canvas.get(-1),
        ctx = canvas.getContext('2d');
      if (!dirtyRegion)
        dirtyRegion = new Rectangle(0, 0, canvas.width, canvas.height);
      ctx.clearRect(dirtyRegion.pos.x, dirtyRegion.pos.y, dirtyRegion.dim.width, dirtyRegion.dim.height);
      this.bg.update(ctx, dirtyRegion);
    }
    return super.updateContent(dirtyRegion);
  }

  /**
   * Sets the real dimension of this panel.
   * @override
   * @param {module:AWT.Dimension} preferredMaxSize - The maximum surface available for the activity panel
   * @returns {module:AWT.Dimension}
   */
  setDimension(preferredMaxSize) {
    return this.getBounds().equals(preferredMaxSize) ?
      preferredMaxSize :
      boxes_BoxBag.layoutSingle(preferredMaxSize, this.bg, this.act.margin);
  }

  /**
   * Sets the size and position of this activity panel
   * @override
   * @param {module:AWT.Rectangle} rect
   */
  setBounds(rect) {
    if (this.$canvas)
      this.$canvas.remove();

    super.setBounds(rect);
    if (this.bg) {
      this.$canvas = external_jquery_default()(`<canvas width="${rect.dim.width}" height="${rect.dim.height}"/>`).css({
        position: 'absolute',
        top: 0,
        left: 0
      });
      // Resize animated gif background
      if (this.$animatedBg) {
        const bgRect = this.bg.getBounds();
        this.$animatedBg.css({
          left: bgRect.pos.x,
          top: bgRect.pos.y,
          width: `${bgRect.dim.width}px`,
          height: `${bgRect.dim.height}px`,
          'background-size': `${bgRect.dim.width}px ${bgRect.dim.height}px`
        });
      }
      this.$div.append(this.$canvas);
      this.invalidate().update();
      window.setTimeout(() => this.bg ? this.bg.buildAccessibleElements(this.$canvas, this.$div) : null, 0);
    }
  }

  /**
   * Builds the accessible components needed for this ActivityPanel
   * This method is called when all main elements are placed and visible, when the activity is ready
   * to start or when resized.
   * @override
   */
  buildAccessibleComponents() {
    if (this.bg && this.$canvas && this.accessibleCanvas) {
      super.buildAccessibleComponents();
      this.bg.buildAccessibleElements(this.$canvas, this.$div);
    }
  }

  /**
   * Main handler used to process mouse, touch, keyboard and edit events
   * @override
   * @param {external:Event} event - The HTML event to be processed
   * @returns {boolean} - When this event handler returns `false`, jQuery will stop its
   * propagation through the DOM tree. See: {@link http://api.jquery.com/on}
   */
  processEvent(event) {
    if (this.playing) {
      const p = new Point(
        event.pageX - this.$div.offset().left,
        event.pageY - this.$div.offset().top);
      // Flag for assuring that only one media plays per event (avoid event sounds overlapping
      // cell's media sounds)
      let m = false;
      // Array to be filled with actions to be executed at the end of event processing
      const delayedActions = [];

      switch (event.type) {
        case 'click':
          this.ps.stopMedia(1);
          // Find the box behind the clicked point
          const bx = this.bg ? this.bg.findActiveBox(p) : null;
          if (bx) {
            if (bx.idAss !== -1) {
              // Check if it's a valid move
              let ok = false;
              const src = bx.getDescription();
              m = m || bx.playMedia(this.ps, delayedActions);
              if (bx.idAss === 1 && (!this.act.useOrder || bx.idOrder === this.currentItem)) {
                ok = true;
                bx.idAss = -1;
                if (bx.switchToAlt(this.ps))
                  m = m || bx.playMedia(this.ps, delayedActions);
                else
                  bx.clear();
                if (this.act.useOrder)
                  this.currentItem = this.bg.getNextItem(this.currentItem, 1);
              }
              const cellsOk = this.bg.countCellsWithIdAss(-1);
              this.ps.reportNewAction(this.act, 'SELECT', src, null, ok, cellsOk - this.act.nonAssignedCells);
              if (ok && cellsOk === this.act.cellsToMatch + this.act.nonAssignedCells)
                this.finishActivity(true);
              else if (!m)
                this.playEvent(ok ? 'actionOk' : 'actionError');
              this.update();
            } else {
              this.playEvent('actionError');
            }
          }
          break;
      }
      delayedActions.forEach(action => action());
      event.preventDefault();
    }
  }
}

Object.assign(IdentifyPanel.prototype, {
  /**
   * The {@link module:boxes/ActiveBoxbag.ActiveBoxBag ActiveBoxBag} containing the information to be displayed on the panel.
   * @name module:activities/panels/Identify.IdentifyPanel#bg
   * @type {module:boxes/ActiveBoxBag.ActiveBoxBag} */
  bg: null,
  /**
   * List of mouse, touch and keyboard events intercepted by this panel
   * @override
   * @name module:activities/panels/Identify.IdentifyPanel#events
   * @type {string[]} */
  events: ['click'],
});

/**
 * Panel class associated to this type of activity: {@link module:activities/panels/Identify.IdentifyPanel IdentifyPanel}
 * @type {class} */
Identify.Panel = IdentifyPanel;

// Register activity class
/* harmony default export */ const panels_Identify = (Activity.registerClass('@panels.Identify', Identify));

;// CONCATENATED MODULE: ./src/activities/panels/Explore.js
/**
 *  File    : activities/panels/Explore.js
 *  Created : 04/06/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */








/**
 * This class of {@link module:Activity.Activity Activity} shows a panel with {@link module:boxes/ActiveBox.ActiveBox ActiveBox} objects. Users can click
 * on this objects to obtain associated information. This associated information, displayed in
 * a second panel, can be text graphics, sound, video... or a combination of them.
 * @extends module:Activity.Activity
 */
class Explore extends Activity {
  /**
   * Explore constructor
   * @param {module:project/JClicProject.JClicProject} project - The {@link module:project/JClicProject.JClicProject JClicProject} to which this activity belongs
   */
  constructor(project) {
    super(project);
  }

  /**
   * Activities of this type never end, so automatic sequences must pause here
   * @override
   * @returns {boolean}
   */
  mustPauseSequence() {
    return true;
  }

  /**
   * Retrieves the minimum number of actions needed to solve this activity
   * @override
   * @returns {number}
   */
  getMinNumActions() {
    return 0;
  }

  /**
   * Usually this activity don't use random to shuffle internal components, but in some cases
   * can make use of it.
   * @override
   * @returns {boolean}
   */
  hasRandom() {
    return true;
  }
}

/**
 * The {@link module:Activity.ActivityPanel ActivityPanel} where {@link module:activities/panels/Explore.Explore Explore} activities are played.
 * @extends module:Activity.ActivityPanel
 */
class ExplorePanel extends ActivityPanel {
  /**
   * ExplorePanel constructor
   * @param {module:Activity.Activity} act - The {@link module:Activity.Activity Activity} to which this Panel belongs
   * @param {module:JClicPlayer.JClicPlayer} ps - Any object implementing the methods defined in the
   * [PlayStation](http://projectestac.github.io/jclic/apidoc/edu/xtec/jclic/PlayStation.html) Java interface.
   * @param {external:jQuery} [$div] - The jQuery DOM element where this Panel will deploy
   */
  constructor(act, ps, $div) {
    super(act, ps, $div);
  }

  /**
   * Miscellaneous cleaning operations
   * @override
   */
  clear() {
    if (this.bgA) {
      this.bgA.end();
      this.bgA = null;
    }
    if (this.bgB) {
      this.bgB.end();
      this.bgB = null;
    }
  }

  /**
   * Prepares the visual components of the activity
   * @override
   */
  buildVisualComponents() {
    if (this.firstRun)
      super.buildVisualComponents();
    this.clear();
    const
      abcA = this.act.abc['primary'],
      abcB = this.act.abc['secondary'];

    if (abcA && abcB) {
      if (abcA.image) {
        abcA.setImgContent(this.act.project.mediaBag, null, false);
        if (abcA.animatedGifFile && !abcA.shaper.rectangularShapes && !this.act.shuffleA)
          this.$animatedBg = external_jquery_default()('<span/>').css({
            'background-image': `url(${abcA.animatedGifFile})`,
            'background-position': 'center',
            'background-repeat': 'no-repeat',
            position: 'absolute'
          }).appendTo(this.$div);
      }

      if (abcB.image)
        abcB.setImgContent(this.act.project.mediaBag, null, false);

      if (this.act.acp !== null)
        this.act.acp.generateContent(abcA.nch, abcA.ncw, [abcA, abcB], false);

      this.bgA = boxes_ActiveBoxGrid.createEmptyGrid(null, this, this.act.margin, this.act.margin, abcA);
      const w = (this.act.boxGridPos === 'AUB' || this.act.boxGridPos === 'BUA') ? abcA.getTotalWidth() : abcB.w;
      this.bgB = new boxes_ActiveBoxGrid(null, this, abcB.style, this.act.margin, this.act.margin, w, abcB.h, new shapers_Rectangular(1, 1));

      this.bgA.setContent(abcA);
      this.bgA.setDefaultIdAss();
      if (this.$animatedBg)
        this.bgA.setCellAttr('tmpTrans', true);
      this.bgB.getActiveBox(0).setInactive(false);
      this.bgA.setVisible(true);
      this.bgB.setVisible(true);
    }
  }

  /**
   * Basic initialization procedure
   * @override
   */
  initActivity() {
    super.initActivity();
    if (!this.firstRun)
      this.buildVisualComponents();
    else
      this.firstRun = false;

    if (this.bgA && this.bgB) {
      // Scramble cells
      if (this.act.shuffleA)
        this.shuffle([this.bgA], true, true);

      if (this.useOrder)
        this.currentItem = this.bgA.getNextItem(-1);

      this.setAndPlayMsg('initial', 'start');
      this.invalidate().update();
      this.playing = true;
    }
  }

  /**
   * Updates the graphic content of this panel.
   * This method will be called from {@link module:AWT.Container#update} when needed.
   * @override
   * @param {module:AWT.Rectangle} dirtyRegion - Specifies the area to be updated. When `null`,
   * it's the whole panel.
   */
  updateContent(dirtyRegion) {
    super.updateContent(dirtyRegion);
    if (this.bgA && this.bgB && this.$canvas) {
      const
        canvas = this.$canvas.get(-1),
        ctx = canvas.getContext('2d');
      if (!dirtyRegion)
        dirtyRegion = new Rectangle(0, 0, canvas.width, canvas.height);
      ctx.clearRect(dirtyRegion.pos.x, dirtyRegion.pos.y, dirtyRegion.dim.width, dirtyRegion.dim.height);
      this.bgA.update(ctx, dirtyRegion);
      this.bgB.update(ctx, dirtyRegion);
    }
    return this;
  }

  /**
   * Sets the real dimension of this panel.
   * @override
   * @param {module:AWT.Dimension} preferredMaxSize - The maximum surface available for the activity panel
   * @returns {module:AWT.Dimension}
   */
  setDimension(preferredMaxSize) {
    return !this.bgA || !this.bgB || this.getBounds().equals(preferredMaxSize) ?
      preferredMaxSize :
      boxes_BoxBag.layoutDouble(preferredMaxSize, this.bgA, this.bgB, this.act.boxGridPos, this.act.margin);
  }

  /**
   * Sets the size and position of this activity panel
   * @override
   * @param {module:AWT.Rectangle} rect
   */
  setBounds(rect) {
    if (this.$canvas)
      this.$canvas.remove();
    super.setBounds(rect);

    if (this.bgA || this.bgB) {
      // Create the main canvas
      this.$canvas = external_jquery_default()(`<canvas width="${rect.dim.width}" height="${rect.dim.height}"/>`).css({
        position: 'absolute',
        top: 0,
        left: 0
      });
      // Resize animated gif background
      if (this.$animatedBg) {
        const bgRect = this.bgA.getBounds();
        this.$animatedBg.css({
          left: bgRect.pos.x,
          top: bgRect.pos.y,
          width: `${bgRect.dim.width}px`,
          height: `${bgRect.dim.height}px`,
          'background-size': `${bgRect.dim.width}px ${bgRect.dim.height}px`
        });
      }
      this.$div.append(this.$canvas);
      // Repaint all
      this.invalidate().update();
    }
  }

  /**
   * Builds the accessible components needed for this ActivityPanel
   * This method is called when all main elements are placed and visible, when the activity is ready
   * to start or when resized.
   * @override
   */
  buildAccessibleComponents() {
    if (this.$canvas && this.accessibleCanvas) {
      super.buildAccessibleComponents();
      if (this.bgA)
        this.bgA.buildAccessibleElements(this.$canvas, this.$div);
      if (this.bgB)
        this.bgB.buildAccessibleElements(this.$canvas, this.$div);
    }
  }

  /**
   * Main handler used to process mouse, touch, keyboard and edit events
   * @override
   * @param {external:Event} event - The HTML event to be processed
   * @returns {boolean} - When this event handler returns `false`, jQuery will stop its
   * propagation through the DOM tree. See: {@link http://api.jquery.com/on}
   */
  processEvent(event) {
    if (this.playing) {
      const p = new Point(
        event.pageX - this.$div.offset().left,
        event.pageY - this.$div.offset().top),
        // Array to be filled with actions to be executed at the end of event processing
        delayedActions = [];

      switch (event.type) {
        case 'click':
          this.ps.stopMedia(1);
          const bx1 = this.bgA.findActiveBox(p);
          if (bx1) {
            const bx2 = this.bgB.getActiveBox(0);
            if (bx1.idAss !== -1 && (!this.act.useOrder || bx1.idOrder === this.currentItem)) {
              bx2.setContent(this.act.abc['secondary'], bx1.idAss);
              if (!bx2.playMedia(this.ps, delayedActions) && !bx1.playMedia(this.ps, delayedActions))
                this.playEvent('CLICK');
              if (this.act.useOrder)
                this.currentItem = this.bgA.getNextItem(this.currentItem);
              this.ps.reportNewAction(this.act, 'SELECT', bx1.getDescription(), bx2.getDescription(), true, 0);
              // Modified May 2020: Focusing `accessibleElement` will always draw a border on bx2
              // if (bx2.$accessibleElement)
              //   bx2.$accessibleElement.focus();

              // Clic 3.0 behavior, applied only to one-cell activities:
              if (bx1.idAss === 0 && this.bgA.getNumCells() === 1) {
                const seq = this.act.project.activitySequence;
                const ase = seq.getCurrentAct();
                if (ase && seq.hasNextAct(true) && ase.delay > 0
                  && (seq.getNavButtonsFlag() !== 'both' && seq.getNavButtonsFlag() !== 'fwd')) {
                  this.finishActivity(true);
                }
              }

            } else {
              bx2.clear();
              bx2.setInactive(false);
            }
            this.update();
          }
          break;
      }
      delayedActions.forEach(action => action());
      event.preventDefault();
    }
  }
}

Object.assign(ExplorePanel.prototype, {
  /**
   * The {@link module:boxes/ActiveBoxbag.ActiveBoxBag ActiveBoxBag} object containing the information to be displayed in the `primary` panel
   * @name module:activities/panels/Explore.ExplorePanel#bgA
   * @type {module:boxes/ActiveBoxBag.ActiveBoxBag} */
  bgA: null,
  /**
   * The {@link module:boxes/ActiveBoxbag.ActiveBoxBag ActiveBoxBag} object containing the information associated to `primary` elements.
   * Only one of this elements will be showed for each click done in the `primary` panel.
   * @name module:activities/panels/Explore.ExplorePanel#bgB
   * @type {module:boxes/ActiveBoxBag.ActiveBoxBag} */
  bgB: null,
  /**
   * List of mouse, touch and keyboard events intercepted by this panel
   * @override
   * @name module:activities/panels/Explore.ExplorePanel#events
   * @type {string[]} */
  events: ['click'],
});

/**
 * Panel class associated to this type of activity: {@link module:activities/panels/Explore.ExplorePanel ExplorePanel}
 * @type {class} */
Explore.Panel = ExplorePanel;

// Register activity class
/* harmony default export */ const panels_Explore = (Activity.registerClass('@panels.Explore', Explore));

;// CONCATENATED MODULE: ./src/activities/panels/icons/ico00.png
const ico00_namespaceObject = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAB1UExURUxpcZVZAGyAAGyAAJVZAJVZAJVZAIhmAJVZAJVZAJVZAIhmAGyAAGyAAGyAAGyAAGyAAJVZAJVZAGyAAJVZANj+AP+ZAMFzAPWSALVsANyEAM57AJ66AOiLALXVAM3xAK1nAI6oAIabAJWwAMTnAKFgAGyAAIlz9xYAAAAVdFJOUwB9oCIiZpkRRKq7M4BVu9VmVd1EzJvdA7gAAAE0SURBVDjLjZPZkoMgEEVFFsHdZBQR3M38/ycOKQ1gJKnpV051nwtNEPyrsjBNom9AqNSapxn8CBRjXY+DmjXkbQSXeq9tWJe7ByhVberXqzCY8yGM6GVK9FQ4SpVUxAwnJ+A+2wkLBLLppYgJRgZIrcJYBKxvdLUdFzE4mHBzFNDUvKoVdFfI7YQ1q7gD7LowXNRwaM4R6AzQEXNRWZrPT2jLA9YaQOIXQHV0WIbFvKZImPNGmLCMCwY0lJQQS6vAzEXFjY7Of5iORXwKySHe8+kWWwVeGQUnmW3QTMgDONUbhQ+ABAZwozkTqH1Ox8za3Jz3drLZDMABquuM9nFaKXZpwfFpp+j0ZiHJ21pifiIkQ++Lix+9nc+Z5/tQwrt2fxEBvN8vooQJLgTDX74xSi6z/wAoQC7hWsslMgAAAABJRU5ErkJggg==";
;// CONCATENATED MODULE: ./src/activities/panels/icons/ico01.png
const ico01_namespaceObject = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAByUExURUxpcfzZt/rfw/pycvrcv/3UrJqf/QAAAP/hxPvOov9sbPqFhYmN/f7nz3V4+/3ky/+AgPrIl11g/P/Klf+Kiv9XV//q1vtHR/rCim1w//pcXISI//tfX5WY/VNT///Dh/86OvwhISUl/js7+klM+vq6e8H/VfEAAAABdFJOUwBA5thmAAABGElEQVQ4y62T23aCMBBFiU48iQlELoJW7b3//4udBIi0MqsvDU+w95yEGSiK/15YrlVhd1+C8Nk05+ribzcvCJlXklBV3u/8pToLAnMk3kiCh0Hkz4LA/NSC+YcgANTWYP4OqVGmtmAuC2St2Mn4EMbq9TaPvABpDborD+OB0QqG8hbo3HTNAikFCtEZBTcMx+t+ewC2U4IyMAFUTgVd5nukHYlrqYcxSBlw15k/gTlXx/ySPT5NLOkyP7IQq0PoOd/wSZLgmLtD5AMLsS70ZbnZEL+LTQmZv6aEQIkrpTUlwWX+FhNCyNzaOiVkHgXODyHzFr87ye/3g+NxGrTgJ6zNa8nXJ04zf4Ew88ylr8KM/At//sB88w0/sBcK3bRRzgAAAABJRU5ErkJggg==";
;// CONCATENATED MODULE: ./src/activities/panels/icons/ico02.png
const ico02_namespaceObject = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAtUExURUxpcQAAAP///8zMzJmZmfrdwP/hxPvOov3UrP3JlvzZt/zlzf/p0/zBh/rDjUN28cYAAAABdFJOUwBA5thmAAAAyklEQVQ4y6WT6w6DIAxG/YS2XHTv/7grLshF0C1r+KE5n6fFpMvybQHt6bldbXfQcazNsTD4MdCV+S+AQcBUBYa5M4BfHrcB8oNA08HLg0EeAiwOuGtBzoE0Mje4AO4S7QwhgDhlZrcISiNoqxzFoGbSb5Uyozhs4ckdD4M+OfQtUmeKcUsGnaQEyoSp/6YJIr2LXAPqp4OH4BzJtUXyZy7iBwbl8eSDALUc/Z/Sv1DxHfVm5ao5hjtIme+YbOnJMdlj/vCJoB5HX97wIgms7CtjdwAAAABJRU5ErkJggg==";
;// CONCATENATED MODULE: ./src/activities/panels/icons/ico03.png
const ico03_namespaceObject = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAwUExURUxpcQAAAPrdwP/hxP7mz/8AAAAAmfvOov3UrAAA//3JlvzZtwCZAP8A//zCifq6e7UN6GsAAAABdFJOUwBA5thmAAABA0lEQVQ4y5WS2RbDIAhEHdyTJv3/vy2osVj1oR6zeYcBDcb8NV6v9fp1NV7mgq8cMs/cDWYHhrmomsM1pcj9pgS7FL3IZ6AI8nazsCiCnPOG3wf0QpArfDnoGATC6mwc9oi/AtMFgAFFLQhDCuZcQ0yAMghB+cuNUgJpSVM1zg7phGUFpv3VFdB5gqxolpwdTqYO5EaPJ57PgWOZWgvt0bl4u+LAbwmzv0Q7JxquJM2FSpwTBRHvRU7Mey/E16f4FwfeSkpUBD26CIQ+PMajODTmaw0Dr7/V1zRVQCNvAvNw6QbFb5iWwvRaWKE4Vh3H/6LxG+ueROfYdXXlb+zavg/++ADYLwfSmmk9oQAAAABJRU5ErkJggg==";
;// CONCATENATED MODULE: ./src/activities/panels/icons/icofolder.png
const icofolder_namespaceObject = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAnUExURUxpcffvhP///2VlZczMZv//zPf39+/nc8zMzDMzmZmZZrW1tbWttcl3sA0AAAABdFJOUwBA5thmAAAAgklEQVQ4y9WSQQ6AIAwEsVtFwf+/14JGbcHeTHSuO9kFQggfBE8BFwLR+mBwFGYSZvh53zjzZTdkLTXCkS/ViDHBCLe8Gla48qpkGEHl+8pdYJo0yOouPA2GhLLiCCyC28DIcAXZ0IfsVKS3BTGUMDas0E9NfkO/ovmQBv2v0BJ+xAaYuQX2hCJNtwAAAABJRU5ErkJggg==";
;// CONCATENATED MODULE: ./src/activities/panels/Menu.js
/**
 *  File    : activities/panels/Menu.js
 *  Created : 20/07/2017
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */






// Use Webpack to import PNG files






/**
 * This class of {@link module:Activity.Activity Activity} is only used in legacy JClic project libraries. It contains
 * one or more buttons pointing to specific JClic projects or to other `Menu` activity panels.
 * @extends module:Activity.Activity
 */
class Menu extends Activity {
  /**
   * Menu constructor
   * @param {module:project/JClicProject.JClicProject} project - The {@link module:project/JClicProject.JClicProject JClicProject} to which this activity belongs
   */
  constructor(project) {
    super(project);
    this.menuElements = [];
    // This kind of activities are not reported
    this.includeInReports = false;
    this.reportActions = false;
  }
}

/**
 * The {@link module:Activity.ActivityPanel ActivityPanel} where Menu will show its content.
 * @extends module:Activity.ActivityPanel
 */
class MenuPanel extends ActivityPanel {
  /**
   * MenuPanel constructor
   * @param {module:Activity.Activity} act - The {@link module:Activity.Activity Activity} to which this Panel belongs
   * @param {module:JClicPlayer.JClicPlayer} ps - Any object implementing the methods defined in the
   * [PlayStation](http://projectestac.github.io/jclic/apidoc/edu/xtec/jclic/PlayStation.html) Java interface.
   * @param {external:jQuery} [$div] - The jQuery DOM element where this Panel will deploy
   */
  constructor(act, ps, $div) {
    super(act, ps, $div);
    // This kind of activity will always clean the "last project skin" setting
    ps.lastProjectSkin = null;
  }

  /**
   * Prepares the visual components of the activity
   * @override
   */
  buildVisualComponents() {
    if (this.firstRun)
      super.buildVisualComponents();
    // This `div` will contain the action buttons
    const $btnDiv = external_jquery_default()('<div/>').css({
      'width': '100%',
      'max-height': '100%',
      'position': 'absolute',
      'top': '50%',
      'transform': 'translateY(-50%)',
      'display': 'flex',
      'flex-wrap': 'wrap',
      'overflow-y': 'auto',
      'place-content': 'center',
      'overflow-y': 'auto'
    });
    this.act.menuElements.forEach((me) => {
      // Create a button for each menu element
      const caption = me.description || me.caption || 'JClic';
      const $btn = external_jquery_default()('<button/>', {
        class: 'StockBtn',
        title: caption,
        'aria-label': caption
      }).css({
        'min-width': '80px',
        'max-width': '200px',
        'min-height': '80px',
        'margin': '4px',
        'padding': '4px',
        'display': 'flex',
        'flex-direction': 'column',
        'justify-content': 'center',
        'align-items': 'center'
      });

      // Set the button icon
      const
        iconSrc = MenuPanel.icons[me.icon || '@ico00.png'],
        $img = external_jquery_default()('<img/>', { src: iconSrc || '' }).css({
          'max-width': '180px',
          'max-height': '100px',
          'margin': '4px'
        });
      if (!iconSrc) {
        // It's not a stock image, so load `src` when available
        const mbe = this.act.project.mediaBag.getElement(me.icon, true);
        mbe.getFullPathPromise().then(imgFullPath => $img.attr('src', imgFullPath));
      }
      $btn.append($img);

      // Set the button text
      $btn.append(external_jquery_default()('<span/>').css({
        'max-width': '180px',
        'overflow': 'hidden',
        'white-space': 'nowrap',
        'text-overflow': 'ellipsis'
      }).html(me.caption));

      // Set a click listener method
      // $btn.on('click', function...) does not work!
      $btn[0].addEventListener('click', (ev) => {
        const mc = new media_MediaContent(me.projectPath ? 'RUN_CLIC_PACKAGE' : 'RUN_CLIC_ACTIVITY', me.sequence);
        if (me.projectPath)
          mc.externalParam = me.projectPath;
        log('info', `Launching ${me.projectPath || ''} ${me.sequence || ''}`);
        this.ps.playMedia(mc);
        ev.preventDefault();
      });

      // Place the created button on the container
      $btnDiv.append($btn);
    });

    // Add the buttons container on the main panel `div`
    this.$div.empty().append($btnDiv);
  }

  /**
   * Sets the real dimension of this panel.
   * @override
   * @param {module:AWT.Dimension} preferredMaxSize - The maximum surface available for the activity panel
   * @returns {module:AWT.Dimension}
   */
  setDimension(preferredMaxSize) {
    return preferredMaxSize;
  }

  /**
   * Basic initialization procedure
   * @override
   */
  initActivity() {
    super.initActivity();

    if (!this.firstRun)
      this.buildVisualComponents();
    else
      this.firstRun = false;

    this.setAndPlayMsg('initial', 'start');
    this.playing = true;
  }
}

/**
 * Default icons used in buttons, inherited from JClic
 * @type {object}
 */
MenuPanel.icons = {
  '@ico00.png': ico00_namespaceObject,
  '@ico01.png': ico01_namespaceObject,
  '@ico02.png': ico02_namespaceObject,
  '@ico03.png': ico03_namespaceObject,
  '@icofolder.png': icofolder_namespaceObject,
};

/**
 * Panel class associated to this type of activity: {@link module:activities/panels/Menu.MenuPanel MenuPanel}
 * @type {class} */
Menu.Panel = MenuPanel;

// Register activity class
/* harmony default export */ const panels_Menu = (Activity.registerClass('@panels.Menu', Menu));



;// CONCATENATED MODULE: ./src/activities/puzzles/DoublePuzzle.js
/**
 *  File    : activities/puzzles/DoublePuzzle.js
 *  Created : 22/05/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */









/**
 * The aim of this class of {@link module:Activity.Activity Activity} is to put in order the shuffled elements of an
 * {@link module:boxes/ActiveBagContent.ActiveBagContent ActiveBagContent} that contains an image, sounds, text... or any other media content.
 *
 * The activity uses two panels: one with the shuffled cells, and other initially empty where
 * this cells must be placed in order.
 * @extends module:Activity.Activity
 */
class DoublePuzzle extends Activity {
  /**
   * DoublePuzzle constructor
   * @param {module:project/JClicProject.JClicProject} project - The {@link module:project/JClicProject.JClicProject JClicProject} to which this activity belongs
   */
  constructor(project) {
    super(project);
  }

  /**
   * Retrieves the minimum number of actions needed to solve this activity.
   * @override
   * @returns {number}
   */
  getMinNumActions() {
    return this.abc.primary.getNumCells();
  }

  /**
   * Whether or not the activity uses random to shuffle internal components
   * @override
   * @returns {boolean}
   */
  hasRandom() {
    return true;
  }

  /**
   * When `true`, the activity must always be shuffled
   * @override
   * @returns {boolean}
   */
  shuffleAlways() {
    return true;
  }

  /**
   * Whether the activity allows the user to request help.
   * @override
   * @returns {boolean}
   */
  helpSolutionAllowed() {
    return true;
  }
}

/**
 * The {@link module:Activity.ActivityPanel ActivityPanel} where {@link module:activities/puzzles/DoublePuzzle.DoublePuzzle DoublePuzzle} activities are played.
 * @extends module:Activity.ActivityPanel
 */
class DoublePuzzlePanel extends ActivityPanel {
  /**
   * DoublePuzzlePanel constructor
   * @param {module:Activity.Activity} act - The {@link module:Activity.Activity Activity} to which this Panel belongs
   * @param {module:JClicPlayer.JClicPlayer} ps - Any object implementing the methods defined in the
   * [PlayStation](http://projectestac.github.io/jclic/apidoc/edu/xtec/jclic/PlayStation.html)
   * Java interface.
   * @param {external:jQuery} [$div] - The jQuery DOM element where this Panel will deploy
   */
  constructor(act, ps, $div) {
    super(act, ps, $div);
  }

  /**
   * Miscellaneous cleaning operations
   * @override
   */
  clear() {
    if (this.bgA) {
      this.bgA.end();
      this.bgA = null;
    }
    if (this.bgB) {
      this.bgB.end();
      this.bgB = null;
    }
  }

  /**
   * Prepares the visual components of the activity
   * @override
   */
  buildVisualComponents() {
    if (this.firstRun)
      super.buildVisualComponents();
    this.clear();

    const abc = this.act.abc['primary'];
    if (abc) {
      if (abc.image)
        abc.setImgContent(this.act.project.mediaBag, null, false);

      if (this.act.acp !== null)
        this.act.acp.generateContent(abc.nch, abc.ncw, [abc], false);

      this.bgA = boxes_ActiveBoxGrid.createEmptyGrid(null, this, this.act.margin, this.act.margin, abc);
      this.bgB = boxes_ActiveBoxGrid.createEmptyGrid(null, this, this.act.margin, this.act.margin, abc);

      this.bgA.setContent(abc);

      this.bgA.accessibleText = getMsg('source');
      this.bgB.accessibleText = getMsg('target');

      this.bgA.setVisible(true);
      this.bgB.setVisible(true);

      const bgbA = this.bgA.getBackgroundActiveBox();
      const bgbB = this.bgB.getBackgroundActiveBox();
      if (bgbA && bgbB)
        bgbB.exchangeContent(bgbA);
    }
  }

  /**
   * Basic initialization procedure
   * @override
   */
  initActivity() {
    super.initActivity();
    if (!this.firstRun)
      this.buildVisualComponents();
    else
      this.firstRun = false;

    if (this.bgA && this.bgB) {
      this.shuffle([this.bgA], true, true);
      if (this.useOrder)
        this.currentItem = this.bgA.getNextItem(-1);
      this.setAndPlayMsg('initial', 'start');
      this.invalidate().update();
      this.playing = true;
    }
  }

  /**
   * Updates the graphic content of this panel.
   * This method will be called from {@link module:AWT.Container#update} when needed.
   * @override
   * @param {module:AWT.Rectangle} dirtyRegion - Specifies the area to be updated. When `null`,
   * it's the whole panel.
   */
  updateContent(dirtyRegion) {
    super.updateContent();
    if (this.bgA && this.bgB && this.$canvas) {
      const
        canvas = this.$canvas.get(-1),
        ctx = canvas.getContext('2d');
      if (!dirtyRegion)
        dirtyRegion = new Rectangle(0, 0, canvas.width, canvas.height);
      ctx.clearRect(dirtyRegion.pos.x, dirtyRegion.pos.y, dirtyRegion.dim.width, dirtyRegion.dim.height);
      this.bgA.update(ctx, dirtyRegion);
      this.bgB.update(ctx, dirtyRegion);
    }
    return this;
  }

  /**
   * Sets the real dimension of this panel.
   * @override
   * @param {module:AWT.Dimension} preferredMaxSize - The maximum surface available for the activity panel
   * @returns {module:AWT.Dimension}
   */
  setDimension(preferredMaxSize) {
    return !this.bgA || !this.bgB || this.getBounds().equals(preferredMaxSize) ?
      preferredMaxSize :
      boxes_BoxBag.layoutDouble(preferredMaxSize, this.bgA, this.bgB, this.act.boxGridPos, this.act.margin);
  }

  /**
   * Sets the size and position of this activity panel
   * @override
   * @param {module:AWT.Rectangle} rect
   */
  setBounds(rect) {
    if (this.$canvas)
      this.$canvas.remove();

    super.setBounds(rect);
    if (this.bgA || this.bgB) {
      // Create the main canvas
      this.$canvas = external_jquery_default()(`<canvas width="${rect.dim.width}" height="${rect.dim.height}"/>`).css({
        position: 'absolute',
        top: 0,
        left: 0
      });
      this.$div.append(this.$canvas);

      // Create a [BoxConnector](BoxConnector.html) and attach it to the canvas context
      this.bc = new boxes_BoxConnector(this, this.$canvas.get(-1).getContext('2d'));

      // Repaint all
      this.invalidate().update();
    }
  }

  /**
   * Builds the accessible components needed for this ActivityPanel
   * This method is called when all main elements are placed and visible, when the activity is ready
   * to start or when resized.
   * @override
   */
  buildAccessibleComponents() {
    if (this.$canvas && this.accessibleCanvas) {
      super.buildAccessibleComponents();
      if (this.bgA)
        this.bgA.buildAccessibleElements(this.$canvas, this.$div, 'mousedown');
      if (this.bgB) {
        this.bgB.setCellAttr('accessibleAlwaysActive', true);
        this.bgB.buildAccessibleElements(this.$canvas, this.$div, 'mousedown');
      }
    }
  }

  /**
   * Main handler used to process mouse, touch, keyboard and edit events
   * @override
   * @param {external:Event} event - The HTML event to be processed
   * @returns {boolean} - When this event handler returns `false`, jQuery will stop its
   * propagation through the DOM tree. See: {@link http://api.jquery.com/on}
   */
  processEvent(event) {
    if (this.bc && this.playing) {
      //
      // The [AWT.Point](AWT.html#Point) where the mouse or touch event has been originated
      let p = null;
      //
      // Two [ActiveBox](ActiveBox.html) pointers used for the [BoxConnector](BoxConnector.html)
      // `origin` and `dest` points.
      let bx1, bx2;
      // Array to be filled with actions to be executed at the end of event processing
      const delayedActions = [];
      //
      // _touchend_ event don't provide pageX nor pageY information
      if (event.type === 'touchend')
        p = this.bc.active ? this.bc.dest.clone() : new Point();
      else {
        // Touch events can have more than one touch, so `pageX` must be obtained from `touches[0]`
        const
          x = event.originalEvent && event.originalEvent.touches ? event.originalEvent.touches[0].pageX : event.pageX,
          y = event.originalEvent && event.originalEvent.touches ? event.originalEvent.touches[0].pageY : event.pageY;
        p = new Point(x - this.$div.offset().left, y - this.$div.offset().top);
      }

      // Flag for tracking `mouseup` events
      let up = false;
      switch (event.type) {
        case 'touchcancel':
          // Canvel movement
          if (this.bc.active)
            this.bc.end();
          break;

        case 'mouseup':
          // Don't consider drag moves below 3 pixels. Can be a "trembling click"
          if (this.bc.active && p.distanceTo(this.bc.origin) <= 3)
            break;

          up = true;
        /* falls through */
        case 'touchend':
        case 'touchstart':
        case 'mousedown':
          if (!this.bc.active) {
            //
            // A new pairing starts
            //
            // Pairings can never start with a `mouseup` event
            if (up)
              break;

            this.ps.stopMedia(1);
            //
            // Find the ActiveBox behind the clicked point
            bx1 = this.bgA.findActiveBox(p);
            if (bx1 && !bx1.isInactive() && (!this.act.useOrder || bx1.idOrder === this.currentItem)) {
              // Start the [BoxConnector](BoxConnector.html)
              if (this.act.dragCells)
                this.bc.begin(p, bx1);
              else
                this.bc.begin(p);
              // Play cell media or event sound
              if (!bx1.playMedia(this.ps, delayedActions))
                this.playEvent('click');

              // Move the focus to the opposite accessible group
              if (this.bgB.$accessibleDiv)
                this.bgB.$accessibleDiv.focus();
            }
          } else {
            this.ps.stopMedia(1);
            // Pairing completed
            //
            // Find the active boxes behind `bc.origin` and `p`
            if (this.act.dragCells)
              bx1 = this.bc.bx;
            else
              bx1 = this.bgA.findActiveBox(this.bc.origin);
            bx2 = this.bgB.findActiveBox(p);

            // BoxConnector ends here
            this.bc.end();

            // Check if the pairing was OK
            if (bx1 && bx2 && bx2.isInactive()) {
              let ok = false;
              const
                src = `${bx1.getDescription()} (${bx1.idOrder})`,
                dest = `(${bx2.idOrder})`,
                target = this.act.abc['primary'].getActiveBoxContent(bx2.idOrder);
              if (bx1.getContent().isEquivalent(target, true)) {
                // Pairing OK
                ok = true;
                bx1.exchangeContent(bx2);
                bx1.setVisible(false);
                if (this.act.useOrder)
                  this.currentItem = this.bgA.getNextItem(this.currentItem);
              }
              // Check results and notify action
              const cellsAtPlace = this.bgA.countInactiveCells();
              this.ps.reportNewAction(this.act, 'PLACE', src, dest, ok, cellsAtPlace);
              // Finish activity or play event sound
              if (ok && cellsAtPlace === this.bgA.getNumCells())
                this.finishActivity(true);
              else
                this.playEvent(ok ? 'actionOk' : 'actionError');
            }
            this.update();

            // Move the focus to the `source` accessible group
            if (this.bgA.$accessibleDiv)
              this.bgA.$accessibleDiv.focus();
          }
          break;

        case 'mousemove':
        case 'touchmove':
          this.bc.moveTo(p);
          break;
      }
      delayedActions.forEach(action => action());
      event.preventDefault();
    }
  }
}

Object.assign(DoublePuzzlePanel.prototype, {
  /**
   * The {@link module:boxes/ActiveBoxbag.ActiveBoxBag ActiveBoxBag} object containing the information to be displayed in the `primary` panel
   * @name module:activities/puzzles/DoublePuzzle.DoublePuzzlePanel#bgA
   * @type {module:boxes/ActiveBoxBag.ActiveBoxBag} */
  bgA: null,
  /**
   * The secondary {@link module:boxes/ActiveBoxbag.ActiveBoxBag ActiveBoxBag}, initially empty.
   * @name module:activities/puzzles/DoublePuzzle.DoublePuzzlePanel#bgB
   * @type {module:boxes/ActiveBoxBag.ActiveBoxBag} */
  bgB: null,
  /**
   * The box connector
   * @name module:activities/puzzles/DoublePuzzle.DoublePuzzlePanel#bc
   * @type {module:boxes/BoxConnector.BoxConnector} */
  bc: null,
  /**
   * List of mouse, touch and keyboard events intercepted by this panel
   * @override
   * @name module:activities/puzzles/DoublePuzzle.DoublePuzzlePanel#events
   * @type {string[]} */
  events: ['mousedown', 'mouseup', 'mousemove', 'touchstart', 'touchend', 'touchmove', 'touchcancel'],
});

/**
 * Panel class associated to this type of activity: {@link module:activities/puzzles/DoublePuzzle.DoublePuzzlePanel DoublePuzzlePanel}
 * @type {class} */
DoublePuzzle.Panel = DoublePuzzlePanel;

// Register activity class
/* harmony default export */ const puzzles_DoublePuzzle = (Activity.registerClass('@puzzles.DoublePuzzle', DoublePuzzle));


;// CONCATENATED MODULE: ./src/activities/puzzles/ExchangePuzzle.js
/**
 *  File    : activities/puzzles/ExchangePuzzle.js
 *  Created : 30/05/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */








/**
 * This class of {@link module:Activity.Activity Activity} shows only one panel with shuffled {@link module:boxes/ActiveBox.ActiveBox ActiveBox} objects.
 * To solve the activity, each cell must exchange its location with another one. When all cells are
 * on place, the activity is done.
 * @extends module:Activity.Activity
 */
class ExchangePuzzle extends Activity {
  /**
   * ExchangePuzzle constructor
   * @param {module:project/JClicProject.JClicProject} project - The {@link module:project/JClicProject.JClicProject JClicProject} to which this activity belongs
   */
  constructor(project) {
    super(project);
  }

  /**
   * Retrieves the minimum number of actions needed to solve this activity.
   * @override
   * @returns {number}
   */
  getMinNumActions() {
    return this.abc.primary.getNumCells();
  }

  /**
   * Whether or not the activity uses random to shuffle internal components
   * @override
   * @returns {boolean}
   */
  hasRandom() {
    return true;
  }

  /**
   * When `true`, the activity must always be shuffled
   * @override
   * @returns {boolean}
   */
  shuffleAlways() {
    return true;
  }

  /**
   * Whether the activity allows the user to request help.
   * @override
   * @returns {boolean}
   */
  helpSolutionAllowed() {
    return true;
  }
}

/**
 * The {@link module:Activity.ActivityPanel ActivityPanel} where activities of type {@link module:activities/puzzles/ExchangePuzzle.ExchangePuzzle ExchangePuzzle} are played.
 * @extends module:Activity.ActivityPanel
 */
class ExchangePuzzlePanel extends ActivityPanel {
  /**
   * ExchangePuzzlePanel constructor
   * @param {module:Activity.Activity} act - The {@link module:Activity.Activity Activity} to which this Panel belongs
   * @param {module:JClicPlayer.JClicPlayer} ps - Any object implementing the methods defined in the
   * [PlayStation](http://projectestac.github.io/jclic/apidoc/edu/xtec/jclic/PlayStation.html) Java interface.
   * @param {external:jQuery} [$div] - The jQuery DOM element where this Panel will deploy
   */
  constructor(act, ps, $div) {
    super(act, ps, $div);
  }

  /**
   * Miscellaneous cleaning operations
   * @override
   */
  clear() {
    if (this.bg) {
      this.bg.end();
      this.bg = null;
    }
  }

  /**
   * Prepares the visual components of the activity
   * @override
   */
  buildVisualComponents() {
    if (this.firstRun)
      super.buildVisualComponents();
    this.clear();

    const abc = this.act.abc['primary'];
    if (abc) {
      if (abc.image)
        abc.setImgContent(this.act.project.mediaBag, null, false);

      if (this.act.acp !== null)
        this.act.acp.generateContent(abc.nch, abc.ncw, [abc], false);

      this.bg = boxes_ActiveBoxGrid.createEmptyGrid(null, this, this.act.margin, this.act.margin, abc);
      this.bg.setContent(abc);
      this.bg.setVisible(true);
    }
  }

  /**
   * Basic initialization procedure
   * @override
   */
  initActivity() {
    super.initActivity();
    if (!this.firstRun)
      this.buildVisualComponents();
    else
      this.firstRun = false;

    if (this.bg) {
      this.shuffle([this.bg], true, true);
      if (this.useOrder)
        this.currentItem = this.bg.getNextItem(-1);
      this.setAndPlayMsg('initial', 'start');
      this.invalidate().update();
      this.playing = true;
    }
  }

  /**
   * Updates the graphic content of this panel.
   * This method will be called from {@link module:AWT.Container#update} when needed.
   * @override
   * @param {module:AWT.Rectangle} dirtyRegion - Specifies the area to be updated. When `null`,
   * it's the whole panel.
   */
  updateContent(dirtyRegion) {
    super.updateContent(dirtyRegion);
    if (this.bg && this.$canvas) {
      const
        canvas = this.$canvas.get(-1),
        ctx = canvas.getContext('2d');
      if (!dirtyRegion)
        dirtyRegion = new Rectangle(0, 0, canvas.width, canvas.height);
      ctx.clearRect(dirtyRegion.pos.x, dirtyRegion.pos.y, dirtyRegion.dim.width, dirtyRegion.dim.height);
      this.bg.update(ctx, dirtyRegion);
    }
    return this;
  }

  /**
   * Sets the real dimension of this panel.
   * @override
   * @param {module:AWT.Dimension} preferredMaxSize - The maximum surface available for the activity panel
   * @returns {module:AWT.Dimension}
   */
  setDimension(preferredMaxSize) {
    return !this.bg || this.getBounds().equals(preferredMaxSize) ?
      preferredMaxSize :
      boxes_BoxBag.layoutSingle(preferredMaxSize, this.bg, this.act.margin);
  }

  /**
   * Sets the size and position of this activity panel
   * @override
   * @param {module:AWT.Rectangle} rect
   */
  setBounds(rect) {
    if (this.$canvas)
      this.$canvas.remove();

    super.setBounds(rect);
    if (this.bg) {
      // Create the main canvas
      this.$canvas = external_jquery_default()(`<canvas width="${rect.dim.width}" height="${rect.dim.height}"/>`).css({
        position: 'absolute',
        top: 0,
        left: 0
      });
      this.$div.append(this.$canvas);

      // Create a [BoxConnector](BoxConnector.html) and attach it to the canvas context
      this.bc = new boxes_BoxConnector(this, this.$canvas.get(-1).getContext('2d'));

      // Repaint all
      this.invalidate().update();
    }
  }

  /**
   * Builds the accessible components needed for this ActivityPanel
   * This method is called when all main elements are placed and visible, when the activity is ready
   * to start or when resized.
   * @override
   */
  buildAccessibleComponents() {
    if (this.$canvas && this.accessibleCanvas && this.bg) {
      super.buildAccessibleComponents();
      this.bg.buildAccessibleElements(this.$canvas, this.$div, 'mousedown');
    }
  }

  /**
   * Main handler used to process mouse, touch, keyboard and edit events
   * @override
   * @param {external:Event} event - The HTML event to be processed
   * @returns {boolean} - When this event handler returns `false`, jQuery will stop its
   * propagation through the DOM tree. See: {@link http://api.jquery.com/on}
   */
  processEvent(event) {
    if (this.bc && this.playing) {

      //
      // The [AWT.Point](AWT.html#Point) where the mouse or touch event has been originated
      let p = null;
      //
      // Two [ActiveBox](ActiveBox.html) pointers used for the [BoxConnector](BoxConnector.html)
      // `origin` and `dest` points.
      let bx1, bx2;
      // Array to be filled with actions to be executed at the end of event processing
      const delayedActions = [];
      //
      // _touchend_ event don't provide pageX nor pageY information
      if (event.type === 'touchend')
        p = this.bc.active ? this.bc.dest.clone() : new Point();
      else {
        // Touch events can have more than one touch, so `pageX` must be obtained from `touches[0]`
        const
          x = event.originalEvent && event.originalEvent.touches ? event.originalEvent.touches[0].pageX : event.pageX,
          y = event.originalEvent && event.originalEvent.touches ? event.originalEvent.touches[0].pageY : event.pageY;
        p = new Point(x - this.$div.offset().left, y - this.$div.offset().top);
      }

      // Flag for tracking `mouseup` events
      let up = false;

      switch (event.type) {
        case 'touchcancel':
          // Canvel movement
          if (this.bc.active)
            this.bc.end();
          break;

        case 'mouseup':
          // Don't consider drag moves below 3 pixels. Can be a "trembling click"
          if (this.bc.active && p.distanceTo(this.bc.origin) <= 3)
            break;

          up = true;
        /* falls through */
        case 'touchend':
        case 'touchstart':
        case 'mousedown':
          if (!this.bc.active) {
            // New pairing starts
            //
            // Pairings never can start with a `mouseup` event
            if (up)
              break;

            this.ps.stopMedia(1);
            // Find the ActiveBox behind the clicked point
            bx1 = this.bg.findActiveBox(p);
            if (bx1) {
              // Start the [BoxConnector](BoxConnector.html)
              if (this.act.dragCells)
                this.bc.begin(p, bx1);
              else
                this.bc.begin(p);
              // Play cell media or event sound
              if (!bx1.playMedia(this.ps, delayedActions))
                this.playEvent('click');
            }
          } else {
            this.ps.stopMedia(1);
            // Pairing completed
            //
            // Find the active boxes behind `bc.origin` and `p`
            if (this.act.dragCells)
              bx1 = this.bc.bx;
            else
              bx1 = this.bg.findActiveBox(this.bc.origin);
            this.bc.end();
            bx2 = this.bg.findActiveBox(p);
            //
            // Check if the pairing was OK
            if (bx1 && bx2) {
              const
                src = `${bx1.getDescription()} (${bx1.idOrder})`,
                dest = `(${bx2.idLoc})`;
              let ok = (bx1.idOrder === bx2.idLoc);
              this.bg.swapCellPositions(bx1, bx2, true);
              // Check results and notify action
              const cellsAtPlace = this.bg.countCellsAtEquivalentPlace(true);
              this.ps.reportNewAction(this.act, 'PLACE', src, dest, ok, cellsAtPlace);
              // End activity or play event sound
              if (ok && cellsAtPlace === this.bg.getNumCells())
                this.finishActivity(true);
              else
                this.playEvent(ok ? 'actionOk' : 'actionError');
            }
            this.update();
          }
          break;

        case 'mousemove':
        case 'touchmove':
          this.bc.moveTo(p);
          break;
      }
      delayedActions.forEach(action => action());
      event.preventDefault();
    }
  }
}

Object.assign(ExchangePuzzlePanel.prototype, {
  /**
   * The {@link module:boxes/ActiveBoxbag.ActiveBoxBag ActiveBoxBag} object containing the information to be displayed in the panel.
   * @name module:activities/puzzles/ExchangePuzzle.ExchangePuzzlePanel#bg
   * @type {module:boxes/ActiveBoxBag.ActiveBoxBag} */
  bg: null,
  /**
   * The box connector
   * @name module:activities/puzzles/ExchangePuzzle.ExchangePuzzlePanel#bc
   * @type {module:boxes/BoxConnector.BoxConnector} */
  bc: null,
  /**
   * List of mouse, touch and keyboard events intercepted by this panel
   * @override
   * @name module:activities/puzzles/ExchangePuzzle.ExchangePuzzlePanel#events
   * @type {string[]} */
  events: ['mousedown', 'mouseup', 'mousemove', 'touchstart', 'touchend', 'touchmove', 'touchcancel'],
});

/**
 * Panel class associated to this type of activity: {@link module:activities/puzzles/ExchangePuzzle.ExchangePuzzlePanel ExchangePuzzlePanel}
 * @type {class} */
ExchangePuzzle.Panel = ExchangePuzzlePanel;

// Register activity class
/* harmony default export */ const puzzles_ExchangePuzzle = (Activity.registerClass('@puzzles.ExchangePuzzle', ExchangePuzzle));

;// CONCATENATED MODULE: ./src/activities/puzzles/HolePuzzle.js
/**
 *  File    : activities/puzzles/HolePuzzle.js
 *  Created : 01/06/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */








/**
 * This class of {@link module:Activity.Activity Activity} shows only one panel with shuffled {@link module:boxes/ActiveBox.ActiveBox ActiveBox} cells.
 *
 * One of the cells is out of the main panel, thus allowing its neighbors occupy their space.
 * Only immediate neighbors of the "hole" can move into it.
 *
 * When all cells are on place, the initially "expulsed" cell comes back home and the activity is done.
 * @extends module:Activity.Activity
 */
class HolePuzzle extends Activity {
  /**
   * HolePuzzle constructor
   * @param {module:project/JClicProject.JClicProject} project - The {@link module:project/JClicProject.JClicProject JClicProject} to which this activity belongs
   */
  constructor(project) {
    super(project);
  }

  /**
   * Retrieves the minimum number of actions needed to solve this activity.
   * @override
   * @returns {number}
   */
  getMinNumActions() {
    return this.abc.primary.getNumCells();
  }

  /**
   * Whether or not the activity uses random to shuffle internal components
   * @override
   * @returns {boolean}
   */
  hasRandom() {
    return true;
  }

  /**
   * When `true`, the activity must always be shuffled
   * @override
   * @returns {boolean}
   */
  shuffleAlways() {
    return true;
  }

  /**
   * Whether the activity allows the user to request help
   * @override
   * @returns {boolean}
   */
  helpSolutionAllowed() {
    return true;
  }
}

/**
 * The {@link module:Activity.ActivityPanel ActivityPanel} where {@link module:activities/puzzles/HolePuzzle.HolePuzzle HolePuzzle} activities are played
 * @extends module:Activity.ActivityPanel
 */
class HolePuzzlePanel extends ActivityPanel {
  /**
   * HolePuzzlePanel constructor
   * @param {module:Activity.Activity} act - The {@link module:Activity.Activity Activity} to which this Panel belongs
   * @param {module:JClicPlayer.JClicPlayer} ps - Any object implementing the methods defined in the
   * [PlayStation](http://projectestac.github.io/jclic/apidoc/edu/xtec/jclic/PlayStation.html) Java interface.
   * @param {external:jQuery} [$div] - The jQuery DOM element where this Panel will deploy
   */
  constructor(act, ps, $div) {
    super(act, ps, $div);
  }

  /**
   * Miscellaneous cleaning operations
   * @override
   */
  clear() {
    if (this.bg) {
      this.bg.end();
      this.bg = null;
    }
    if (this.parkBg) {
      this.parkBg.end();
      this.parkBg = null;
    }
  }

  /**
   * Prepares the visual components of the activity
   * @override
   */
  buildVisualComponents() {
    if (this.firstRun)
      super.buildVisualComponents();
    this.clear();

    const abc = this.act.abc['primary'];
    if (abc) {
      if (abc.image)
        abc.setImgContent(this.act.project.mediaBag, null, false);

      if (this.act.acp !== null)
        this.act.acp.generateContent(abc.nch, abc.ncw, [abc], false);

      this.bg = boxes_ActiveBoxGrid.createEmptyGrid(null, this, this.act.margin, this.act.margin, abc);
      this.bg.setContent(abc);
      this.bg.setVisible(true);

      this.hiddenBoxIndex = Math.floor(Math.random() * this.bg.getNumCells());
      this.hiddenBox = this.bg.getActiveBox(this.hiddenBoxIndex);
      this.hiddenBox.setVisible(false);
      this.parkBg = new boxes_ActiveBoxGrid(null, this, abc.style, this.act.margin, this.act.margin,
        this.hiddenBox.dim.width, this.hiddenBox.dim.height, new shapers_Rectangular(1, 1));
      this.parkBg.setContent(abc, null, this.hiddenBoxIndex, 0, 1);
      this.parkBg.setBorder(this.bg.hasBorder());
      this.parkBg.setVisible(true);
    }
  }

  /**
   * Basic initialization procedure
   * @override
   */
  initActivity() {
    super.initActivity();
    if (!this.firstRun)
      this.buildVisualComponents();
    else
      this.firstRun = false;

    if (this.bg) {
      //
      // This activity has an special shuffle method. Cells can move only to places near the 'hole'
      if (this.act.shuffles % 2 !== 1)
        this.act.shuffles++;
      for (var i = 0; i < this.act.shuffles; i++) {
        const pth = this.bg.getCoord(this.hiddenBox);
        const v = Math.floor(Math.random() * 2) === 0 ? 1 : -1;

        if (Math.floor(Math.random() * 2) === 0) {
          pth.x += v;
          if (pth.x < 0 || pth.x >= this.bg.nCols)
            pth.x -= 2 * v;
        } else {
          pth.y += v;
          if (pth.y < 0 || pth.y >= this.bg.nRows)
            pth.y -= 2 * v;
        }
        var dstBx = this.bg.getActiveBoxWithIdLoc(pth.y * this.bg.nCols + pth.x);
        if (dstBx !== null)
          this.hiddenBox.exchangeLocation(dstBx);
      }
      this.setAndPlayMsg('initial', 'start');
      this.invalidate().update();
      this.playing = true;
    }
  }

  /**
   * Updates the graphic content of this panel.
   * This method will be called from {@link module:AWT.Container#update} when needed.
   * @override
   * @param {module:AWT.Rectangle} dirtyRegion - Specifies the area to be updated. When `null`,
   * it's the whole panel.
   */
  updateContent(dirtyRegion) {
    super.updateContent(dirtyRegion);
    if (this.bg && this.parkBg && this.$canvas) {
      const
        canvas = this.$canvas.get(-1),
        ctx = canvas.getContext('2d');
      if (!dirtyRegion)
        dirtyRegion = new Rectangle(0, 0, canvas.width, canvas.height);
      ctx.clearRect(dirtyRegion.pos.x, dirtyRegion.pos.y, dirtyRegion.dim.width, dirtyRegion.dim.height);
      this.bg.update(ctx, dirtyRegion);
      this.parkBg.update(ctx, dirtyRegion);
    }
    return this;
  }

  /**
   * Sets the real dimension of this panel.
   * @override
   * @param {module:AWT.Dimension} preferredMaxSize - The maximum surface available for the activity panel
   * @returns {module:AWT.Dimension}
   */
  setDimension(preferredMaxSize) {
    return !this.bg || !this.parkBg || this.getBounds().equals(preferredMaxSize) ?
      preferredMaxSize :
      boxes_BoxBag.layoutDouble(preferredMaxSize, this.bg, this.parkBg, this.act.boxGridPos, this.act.margin);
  }

  /**
   * Sets the size and position of this activity panel
   * @override
   * @param {module:AWT.Rectangle} rect
   */
  setBounds(rect) {
    if (this.$canvas)
      this.$canvas.remove();

    super.setBounds(rect);
    if (this.bg && this.parkBg) {
      // Create the main canvas
      this.$canvas = external_jquery_default()(`<canvas width="${rect.dim.width}" height="${rect.dim.height}"/>`).css({
        position: 'absolute',
        top: 0,
        left: 0
      });
      this.$div.append(this.$canvas);

      // Repaint all
      this.invalidate().update();
    }
  }

  /**
   * Builds the accessible components needed for this ActivityPanel
   * This method is called when all main elements are placed and visible, when the activity is ready
   * to start or when resized.
   * @override
   */
  buildAccessibleComponents() {
    if (this.$canvas && this.accessibleCanvas && this.bg) {
      super.buildAccessibleComponents();
      this.bg.buildAccessibleElements(this.$canvas, this.$div);
    }
  }

  /**
   * Main handler used to process mouse, touch, keyboard and edit events
   * @override
   * @param {external:Event} event - The HTML event to be processed
   * @returns {boolean} - When this event handler returns `false`, jQuery will stop its
   * propagation through the DOM tree. See: {@link http://api.jquery.com/on}
   */
  processEvent(event) {
    if (this.playing) {
      const p = new Point(
        event.pageX - this.$div.offset().left,
        event.pageY - this.$div.offset().top);
      // Array to be filled with actions to be executed at the end of event processing
      const delayedActions = [];

      switch (event.type) {
        case 'click':
          this.ps.stopMedia(1);
          // Find the box behind the clicked point
          const bx = this.bg.findActiveBox(p);
          if (bx) {
            if (bx.isVisible()) {
              // Check if it's a valid move
              const pt = this.bg.getCoordDist(bx, this.hiddenBox);
              if (Math.abs(pt.x) + Math.abs(pt.y) === 1) {
                // Ok, the cell is adjacent to the hole. Complete the move.
                let m = bx.playMedia(this.ps, delayedActions);
                const
                  src = `${bx.getDescription()} (${bx.idOrder})`,
                  dest = `(${this.hiddenBox.idLoc})`;
                bx.exchangeLocation(this.hiddenBox);
                const ok = bx.idOrder === bx.idLoc;
                // Check results and notify action
                const cellsAtPlace = this.bg.countCellsAtEquivalentPlace(true);
                this.ps.reportNewAction(this.act, 'SELECT', src, dest, ok, cellsAtPlace);
                if (ok && cellsAtPlace === this.bg.getNumCells()) {
                  // Activity completed!
                  this.hiddenBox.setVisible(true);
                  this.parkBg.setVisible(false);
                  this.finishActivity(true);
                } else
                  if (!m)
                    this.playEvent('click');
              }
              this.update();
            } else {
              this.playEvent('actionError');
            }
          }
          break;
      }
      delayedActions.forEach(action => action());
      event.preventDefault();
    }
  }
}

Object.assign(HolePuzzlePanel.prototype, {
  /**
   * The {@link module:boxes/ActiveBoxbag.ActiveBoxBag ActiveBoxBag} object containing the information to be displayed in the panel.
   * @name module:activities/puzzles/HolePuzzle.HolePuzzlePanel#bg
   * @type {module:boxes/ActiveBoxBag.ActiveBoxBag} */
  bg: null,
  /**
   * An auxiliary box bag with only one box, used to store the "missing piece" of
   * the puzzle.
   * @name module:activities/puzzles/HolePuzzle.HolePuzzlePanel#parkBg
   * @type {module:boxes/ActiveBoxGrid.ActiveBoxGrid} */
  parkBg: null,
  /**
   * The hidden cell
   * @name module:activities/puzzles/HolePuzzle.HolePuzzlePanel#hiddenBox
   * @type {module:boxes/ActiveBox.ActiveBox} */
  hiddenBox: null,
  /**
   * Index of the hidden cell on the ActiveBagContent
   * @name module:activities/puzzles/HolePuzzle.HolePuzzlePanel#hiddenBoxIndex
   * @type {number} */
  hiddenBoxIndex: -1,
  /**
   * List of mouse, touch and keyboard events intercepted by this panel
   * @override
   * @name module:activities/puzzles/HolePuzzle.HolePuzzlePanel#events
   * @type {string[]} */
  events: ['click'],
});

/**
 * Panel class associated to this type of activity: {@link module:activities/puzzles/HolePuzzle.HolePuzzlePanel HolePuzzlePanel}
 * @type {class} */
HolePuzzle.Panel = HolePuzzlePanel;

// Register activity class
/* harmony default export */ const puzzles_HolePuzzle = (Activity.registerClass('@puzzles.HolePuzzle', HolePuzzle));

;// CONCATENATED MODULE: ./src/activities/memory/MemoryGame.js
/**
 *  File    : activities/memory/MemoryGame.js
 *  Created : 04/06/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */









/**
 * This class of {@link module:Activity.Activity Activity} shows a panel with duplicate {@link module:boxes/ActiveBox.ActiveBox ActiveBox} objects initially
 * hidden and shuffled. To complete the activity, all object pairs must be found. Only two objects
 * are revealed in every move, so the user must remember the content of each cell.
 *
 * The cell pairs can have identical content, defined in the `primary` {@link module:boxes/ActiveBagContent.ActiveBagContent ActiveBagContent} of
 * the activity, or two different contents. In this case, the `secondary` bag elements will have
 * content related to each `primary` element.
 * @extends module:Activity.Activity
 */
class MemoryGame extends Activity {
  /**
   * MemoryGame constructor
   * @param {module:project/JClicProject.JClicProject} project - The {@link module:project/JClicProject.JClicProject JClicProject} to which this activity belongs
   */
  constructor(project) {
    super(project);
  }

  /**
   * Retrieves the minimum number of actions needed to solve this activity.
   * @override
   * @returns {number}
   */
  getMinNumActions() {
    return this.abc.primary.getNumCells();
  }

  /**
   * Whether or not the activity uses random to shuffle internal components
   * @override
   * @returns {boolean}
   */
  hasRandom() {
    return true;
  }

  /**
   * When `true`, the activity must always be shuffled
   * @override
   * @returns {boolean}
   */
  shuffleAlways() {
    return true;
  }
}

/**
 * The {@link module:Activity.ActivityPanel ActivityPanel} where {@link module:activities/memory/MemoryGame.MemoryGame MemoryGame} activities are played.
 * @extends module:Activity.ActivityPanel
 */
class MemoryGamePanel extends ActivityPanel {
  /**
   * MemoryGamePanel constructor
   * @param {module:Activity.Activity} act - The {@link module:Activity.Activity Activity} to which this Panel belongs
   * @param {module:JClicPlayer.JClicPlayer} ps - Any object implementing the methods defined in the
   * [PlayStation](http://projectestac.github.io/jclic/apidoc/edu/xtec/jclic/PlayStation.html) Java interface.
   * @param {external:jQuery} [$div] - The jQuery DOM element where this Panel will deploy
   */
  constructor(act, ps, $div) {
    super(act, ps, $div);
  }

  /**
   * Miscellaneous cleaning operations
   * @override
   */
  clear() {
    if (this.bg) {
      this.bg.end();
      this.bg = null;
    }
  }

  /**
   * Prepares the visual components of the activity
   * @override
   */
  buildVisualComponents() {
    if (this.firstRun)
      super.buildVisualComponents();
    this.clear();

    const
      abcA = this.act.abc['primary'],
      abcB = this.act.abc['secondary'];

    if (abcA) {
      if (abcA.image)
        abcA.setImgContent(this.act.project.mediaBag, null, false);
      if (abcB && abcB.image)
        abcB.setImgContent(this.act.project.mediaBag, null, false);
      if (this.act.acp !== null) {
        const contentKit = [abcA];
        if (abcB)
          contentKit.push(abcB);
        this.act.acp.generateContent(abcA.nch, abcA.ncw, contentKit, false);
      }

      let ncw = abcA.ncw, nch = abcA.nch;
      if (this.act.boxGridPos === 'AB' || this.act.boxGridPos === 'BA')
        ncw *= 2;
      else
        nch *= 2;

      this.bg = new boxes_ActiveBoxGrid(null, this, abcA.style,
        this.act.margin, this.act.margin,
        abcA.w * ncw, abcA.h * nch, new shapers_Rectangular(ncw, nch));

      const nc = abcA.getNumCells();
      this.bg.setBorder(abcA.border);
      this.bg.setContent(abcA, null, 0, 0, nc);
      this.bg.setContent(abcB ? abcB : abcA, null, 0, nc, nc);
      for (let i = 0; i < 2; i++) {
        for (let j = 0; j < nc; j++) {
          const bx = this.bg.getActiveBox(i * nc + j);
          bx.idAss = j;
          bx.setInactive(true);
        }
      }
      this.bg.setVisible(true);
    }
  }

  /**
   * Basic initialization procedure
   * @override
   */
  initActivity() {
    super.initActivity();

    if (!this.firstRun)
      this.buildVisualComponents();
    else
      this.firstRun = false;

    if (this.bg) {
      this.shuffle([this.bg], true, true);
      this.invalidate().update();
      this.setAndPlayMsg('initial', 'start');
      this.playing = true;
    }
  }

  /**
   * Updates the graphic content of this panel.
   * This method will be called from {@link module:AWT.Container#update} when needed.
   * @override
   * @param {module:AWT.Rectangle} dirtyRegion - Specifies the area to be updated. When `null`,
   * it's the whole panel.
   */
  updateContent(dirtyRegion) {
    super.updateContent(dirtyRegion);
    if (this.bg && this.$canvas) {
      const
        canvas = this.$canvas.get(-1),
        ctx = canvas.getContext('2d');
      if (!dirtyRegion)
        dirtyRegion = new Rectangle(0, 0, canvas.width, canvas.height);
      ctx.clearRect(dirtyRegion.pos.x, dirtyRegion.pos.y, dirtyRegion.dim.width, dirtyRegion.dim.height);
      this.bg.update(ctx, dirtyRegion);
    }
    return this;
  }

  /**
   * Sets the real dimension of this panel.
   * @override
   * @param {module:AWT.Dimension} preferredMaxSize - The maximum surface available for the activity panel
   * @returns {module:AWT.Dimension}
   */
  setDimension(preferredMaxSize) {
    if (!this.bg || this.getBounds().equals(preferredMaxSize))
      return preferredMaxSize;
    return boxes_BoxBag.layoutSingle(preferredMaxSize, this.bg, this.act.margin);
  }

  /**
   * Sets the size and position of this activity panel
   * @override
   * @param {module:AWT.Rectangle} rect
   */
  setBounds(rect) {
    if (this.$canvas)
      this.$canvas.remove();

    super.setBounds(rect);
    if (this.bg) {
      // Create the main canvas
      this.$canvas = external_jquery_default()(`<canvas width="${rect.dim.width}" height="${rect.dim.height}"/>`).css({
        position: 'absolute',
        top: 0,
        left: 0
      });
      this.$div.append(this.$canvas);

      // Create a [BoxConnector](BoxConnector.html) and attach it to the canvas context
      this.bc = new boxes_BoxConnector(this, this.$canvas.get(-1).getContext('2d'));

      // Repaint all
      this.invalidate().update();
    }
  }

  /**
   * Builds the accessible components needed for this ActivityPanel
   * This method is called when all main elements are placed and visible, when the activity is ready
   * to start or when resized.
   * @override
   */
  buildAccessibleComponents() {
    if (this.$canvas && this.accessibleCanvas && this.bg) {
      super.buildAccessibleComponents();
      this.bg.setCellAttr('accessibleAlwaysActive', true);
      this.bg.buildAccessibleElements(this.$canvas, this.$div, 'mousedown');
    }
  }

  /**
   * Main handler used to process mouse, touch, keyboard and edit events
   * @override
   * @param {external:Event} event - The HTML event to be processed
   * @returns {boolean} - When this event handler returns `false`, jQuery will stop its
   * propagation through the DOM tree. See: {@link http://api.jquery.com/on}
   */
  processEvent(event) {
    if (this.bc && this.playing) {
      //
      // The [AWT.Point](AWT.html#Point) where the mouse or touch event has been originated
      let p = null;
      //
      // Two [ActiveBox](ActiveBox.html) pointers used for the [BoxConnector](BoxConnector.html)
      // `origin` and `dest` points.
      let bx1, bx2,
        // Array to be filled with actions to be executed at the end of event processing
        delayedActions = [];
      //
      // _touchend_ event don't provide pageX nor pageY information
      if (event.type === 'touchend')
        p = this.bc.active ? this.bc.dest.clone() : new Point();
      else {
        // Touch events can have more than one touch, so `pageX` must be obtained from `touches[0]`
        const
          x = event.originalEvent && event.originalEvent.touches ? event.originalEvent.touches[0].pageX : event.pageX,
          y = event.originalEvent && event.originalEvent.touches ? event.originalEvent.touches[0].pageY : event.pageY;
        p = new Point(x - this.$div.offset().left, y - this.$div.offset().top);
      }

      // Flag for tracking `mouseup` events
      let up = false;
      switch (event.type) {
        case 'touchcancel':
          // Canvel movement
          if (this.bc.active)
            this.bc.end();
          break;

        case 'mouseup':
        case 'touchend':
          // Don't consider drag moves below 3 pixels. Can be a "trembling click"
          if (this.bc.active && p.distanceTo(this.bc.origin) <= 3)
            break;

          up = true;
        /* falls through */
        case 'touchstart':
        case 'mousedown':
          if (!this.bc.active) {
            // New pairing starts
            //
            // Pairings can never start with a `mouseup` event
            if (up)
              break;

            this.ps.stopMedia(1);
            //
            // Find the ActiveBox behind the clicked point
            bx1 = this.bg ? this.bg.findActiveBox(p) : null;
            if (bx1 && bx1.idAss !== -1) {
              // Play cell media or event sound
              if (!bx1.playMedia(this.ps, delayedActions))
                this.playEvent('click');
              bx1.setInactive(false);
              // Start the [BoxConnector](BoxConnector.html)
              this.update();
              if (this.act.dragCells)
                this.bc.begin(p, bx1);
              else
                this.bc.begin(p);
            }
          } else {
            this.ps.stopMedia(1);
            // Pairing completed
            //
            // Find the active boxes behind `bc.origin` and `p`
            if (this.act.dragCells)
              bx1 = this.bc.bx;
            else
              bx1 = this.bg ? this.bg.findActiveBox(this.bc.origin) : null;
            this.bc.end();
            bx2 = this.bg ? this.bg.findActiveBox(p) : null;
            //
            // Check if the pairing was OK
            if (bx1 && bx1.idAss !== -1 && bx2 && bx2.idAss !== -1) {
              if (bx1 !== bx2) {
                let ok = false;
                if (bx1.idAss === bx2.idAss ||
                  bx1.getContent().isEquivalent(bx2.getContent(), true)) {
                  ok = true;
                  bx1.idAss = -1;
                  bx1.setInactive(false);
                  bx2.idAss = -1;
                  bx2.setInactive(false);
                } else {
                  bx1.setInactive(true);
                  if (this.act.dragCells)
                    bx2.setInactive(true);
                  else {
                    bx2.setInactive(false);
                    // Start the [BoxConnector](BoxConnector.html)
                    this.update();
                    if (this.act.dragCells)
                      this.bc.begin(p, bx1);
                    else
                      this.bc.begin(p);
                  }
                }
                let m = bx2.playMedia(this.ps, delayedActions);
                if (this.bg) {
                  const cellsAtPlace = this.bg.countCellsWithIdAss(-1);
                  this.ps.reportNewAction(this.act, 'MATCH', bx1.getDescription(), bx2.getDescription(), ok, cellsAtPlace / 2);
                  if (ok && cellsAtPlace === this.bg.getNumCells())
                    this.finishActivity(true);
                  else if (!m)
                    this.playEvent(ok ? 'actionOk' : 'actionError');
                }
              } else {
                this.playEvent('CLICK');
                bx1.setInactive(true);
              }
            } else if (bx1 !== null)
              bx1.setInactive(true);

            this.invalidate().update();
          }
          break;

        case 'mousemove':
        case 'touchmove':
          this.bc.moveTo(p);
          break;
      }
      delayedActions.forEach(action => action());
      event.preventDefault();
    }
  }
}

Object.assign(MemoryGamePanel.prototype, {
  /**
   * The {@link module:boxes/ActiveBoxbag.ActiveBoxBag ActiveBoxBag} containing the information to be displayed.
   * @name module:activities/memory/MemoryGame.MemoryGamePanel#bg
   * @type {module:boxes/ActiveBoxBag.ActiveBoxBag} */
  bg: null,
  /**
   * The {@link module:boxes/BoxConnector.BoxConnector BoxConnector} used to reveal pairs of cells
   * @name module:activities/memory/MemoryGame.MemoryGamePanel#bc
   * @type {module:boxes/BoxConnector.BoxConnector} */
  bc: null,
  /**
   * List of mouse, touch and keyboard events intercepted by this panel
   * @override
   * @name module:activities/memory/MemoryGame.MemoryGamePanel#events
   * @type {string[]} */
  events: ['mousedown', 'mouseup', 'mousemove', 'touchstart', 'touchend', 'touchmove', 'touchcancel'],
});

/**
 * Panel class associated to this type of activity: {@link module:activities/memory/MemoryGame.MemoryGamePanel MemoryGamePanel}
 * @type {class} */
MemoryGame.Panel = MemoryGamePanel;

// Register activity class
/* harmony default export */ const memory_MemoryGame = (Activity.registerClass('@memory.MemoryGame', MemoryGame));

;// CONCATENATED MODULE: ./src/activities/associations/SimpleAssociation.js
/**
 *  File    : activities/associations/SimpleAssociation.js
 *  Created : 02/06/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Catalan Educational Telematic Network (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */









/**
 * This class of {@link module:Activity.Activity Activity} uses two panels (`primary` and `secondary`) formed by
 * {@link module:boxes/ActiveBox.ActiveBox ActiveBox} objects filled with data stored in {@link module:boxes/ActiveBagContent.ActiveBagContent ActiveBagContent} repositories.
 *
 * Both panels have the same number of elements, associated one-to-one. A third {@link module:boxes/ActiveBagContent.ActiveBagContent ActiveBagContent}
 * can be used as alternative content, that will be revealed in the `primary` panel as the pairings
 * of its cells are solved.
 * @extends module:Activity.Activity
 */
class SimpleAssociation extends Activity {
  /**
   * SimpleAssociation constructor
   * @param {module:project/JClicProject.JClicProject} project - The JClic project to which this activity belongs
   */
  constructor(project) {
    super(project);
  }

  /**
   * Retrieves the minimum number of actions needed to solve this activity.
   * @override
   * @returns {number}
   */
  getMinNumActions() {
    return this.abc.primary.getNumCells();
  }

  /**
   * Whether or not the activity uses random to shuffle internal components
   * @override
   * @returns {boolean}
   */
  hasRandom() {
    return true;
  }

  /**
   * When `true`, the activity must always be shuffled
   * @override
   * @returns {boolean}
   */
  shuffleAlways() {
    return true;
  }

  /**
   * Whether the activity allows the user to request help.
   * @override
   * @returns {boolean}
   */
  helpSolutionAllowed() {
    return true;
  }
}

Object.assign(SimpleAssociation.prototype, {
  /**
   * When `true`, the cell's `idAss` field will be used to check pairing matches.
   * @name module:activities/associations/SimpleAssociation.SimpleAssociation#useIdAss
   * @type {boolean} */
  useIdAss: false,
});

/**
 * The {@link module:Activity.ActivityPanel ActivityPanel} where {@link module:activities/associations/SimpleAssociation.SimpleAssociation SimpleAssociation} activities are played.
 * @extends module:Activity.ActivityPanel ActivityPanel
 */
class SimpleAssociationPanel extends ActivityPanel {
  /**
   * SimpleAssociationPanel constructor
   * @param {module:Activity.Activity} act - The {@link module:Activity.Activity Activity} to which this Panel belongs
   * @param {module:JClicPlayer.JClicPlayer} ps - Any object implementing the methods defined in the
   * [PlayStation](http://projectestac.github.io/jclic/apidoc/edu/xtec/jclic/PlayStation.html) Java interface.
   * @param {external:jQuery} [$div] - The jQuery DOM element where this Panel will deploy
   */
  constructor(act, ps, $div) {
    super(act, ps, $div);
  }

  /**
   * Performs miscellaneous cleaning operations
   * @override
   */
  clear() {
    if (this.bgA) {
      this.bgA.end();
      this.bgA = null;
    }
    if (this.bgB) {
      this.bgB.end();
      this.bgB = null;
    }
  }

  /**
   * Prepares the visual components of the activity
   * @override
   */
  buildVisualComponents() {
    if (this.firstRun)
      super.buildVisualComponents();

    this.clear();

    const
      abcA = this.act.abc['primary'],
      abcB = this.act.abc['secondary'],
      solved = this.act.abc['solvedPrimary'];

    if (abcA && abcB) {
      if (abcA.image) {
        abcA.setImgContent(this.act.project.mediaBag, null, false);
        if (abcA.animatedGifFile && !abcA.shaper.rectangularShapes && !this.act.shuffleA)
          this.$animatedBg = external_jquery_default()('<span/>').css({
            'background-image': `url(${abcA.animatedGifFile})`,
            'background-position': 'center',
            'background-repeat': 'no-repeat',
            position: 'absolute'
          }).appendTo(this.$div);
      }

      if (abcB.image) {
        abcB.setImgContent(this.act.project.mediaBag, null, false);
        if (abcB.animatedGifFile && !abcB.shaper.rectangularShapes && !this.act.shuffleB)
          this.$animatedBgB = external_jquery_default()('<span/>').css({
            'background-image': `url(${abcB.animatedGifFile})`,
            'background-position': 'center',
            'background-repeat': 'no-repeat',
            position: 'absolute'
          }).appendTo(this.$div);
      }

      if (solved && solved.image)
        solved.setImgContent(this.act.project.mediaBag, null, false);

      if (this.act.acp !== null) {
        const contentKit = [abcA, abcB];
        if (solved)
          contentKit.push(solved);
        this.act.acp.generateContent(abcA.nch, abcA.ncw, contentKit, false);
      }

      this.bgA = boxes_ActiveBoxGrid.createEmptyGrid(null, this, this.act.margin, this.act.margin, abcA);
      this.bgB = boxes_ActiveBoxGrid.createEmptyGrid(null, this, this.act.margin, this.act.margin, abcB);

      this.bgA.setContent(abcA, solved ? solved : null);
      if (this.$animatedBg)
        this.bgA.setCellAttr('tmpTrans', true);

      this.bgB.setContent(abcB);
      if (this.$animatedBgB)
        this.bgB.setCellAttr('tmpTrans', true);

      this.bgA.accessibleText = getMsg('source');
      this.bgB.accessibleText = getMsg('target');

      this.bgA.setVisible(true);
      this.bgB.setVisible(true);
    }
  }

  /**
   * Basic initialization procedure
   * @override
   */
  initActivity() {
    super.initActivity();
    if (!this.firstRun)
      this.buildVisualComponents();
    else
      this.firstRun = false;

    if (this.bgA && this.bgB) {
      // Scramble cells
      const shuffleArray = [];
      if (this.act.shuffleA)
        shuffleArray.push(this.bgA);
      if (this.act.shuffleB)
        shuffleArray.push(this.bgB);
      if (shuffleArray.length > 0) {
        this.shuffle(shuffleArray, true, true);
      }

      if (this.useOrder)
        this.currentItem = this.bgA.getNextItem(-1);

      this.invalidate().update();
      this.setAndPlayMsg('initial', 'start');
      this.playing = true;
    }
  }

  /**
   * Updates the graphic content of this panel.
   * This method will be called from {@link module:AWT.Container#update} when needed.
   * @override
   * @param {module:AWT.Rectangle} dirtyRegion - Specifies the area to be updated. When `null`,
   * it's the whole panel.
   */
  updateContent(dirtyRegion) {
    super.updateContent(dirtyRegion);
    if (this.bgA && this.bgB && this.$canvas) {
      const
        canvas = this.$canvas.get(-1),
        ctx = canvas.getContext('2d');
      if (!dirtyRegion)
        dirtyRegion = new Rectangle(0, 0, canvas.width, canvas.height);
      ctx.clearRect(dirtyRegion.pos.x, dirtyRegion.pos.y, dirtyRegion.dim.width, dirtyRegion.dim.height);
      this.bgA.update(ctx, dirtyRegion);
      this.bgB.update(ctx, dirtyRegion);
    }
    return this;
  }

  /**
   * Sets the real dimension of this panel.
   * @override
   * @param {module:AWT.Dimension} preferredMaxSize - The maximum surface available for the activity panel
   * @returns {module:AWT.Dimension}
   */
  setDimension(preferredMaxSize) {
    return !this.bgA || !this.bgB || this.getBounds().equals(preferredMaxSize) ?
      preferredMaxSize :
      boxes_BoxBag.layoutDouble(preferredMaxSize, this.bgA, this.bgB, this.act.boxGridPos, this.act.margin);
  }

  /**
   * Sets the size and position of this activity panel
   * @override
   * @param {module:AWT.Rectangle} rect
   */
  setBounds(rect) {
    if (this.$canvas)
      this.$canvas.remove();

    super.setBounds(rect);
    if (this.bgA || this.bgB) {
      // Create the main canvas
      this.$canvas = external_jquery_default()(`<canvas width="${rect.dim.width}" height="${rect.dim.height}"/>`).css({
        position: 'absolute',
        top: 0,
        left: 0
      });
      // Resize animated gif background A
      if (this.$animatedBg && this.bgA) {
        const bgRect = this.bgA.getBounds();
        this.$animatedBg.css({
          left: bgRect.pos.x,
          top: bgRect.pos.y,
          width: bgRect.dim.width + 'px',
          height: bgRect.dim.height + 'px',
          'background-size': `${bgRect.dim.width}px ${bgRect.dim.height}px`
        });
      }
      // Resize animated gif background B
      if (this.$animatedBgB && this.bgB) {
        const bgRectB = this.bgB.getBounds();
        this.$animatedBgB.css({
          left: bgRectB.pos.x,
          top: bgRectB.pos.y,
          width: bgRectB.dim.width + 'px',
          height: bgRectB.dim.height + 'px',
          'background-size': `${bgRectB.dim.width}px ${bgRectB.dim.height}px`
        });
      }
      this.$div.append(this.$canvas);

      // Create a [BoxConnector](BoxConnector.html) and attach it to the canvas context
      this.bc = new boxes_BoxConnector(this, this.$canvas.get(-1).getContext('2d'));

      // Repaint all
      this.invalidate().update();
    }
  }

  /**
   * Builds the accessible components needed for this ActivityPanel
   * This method is called when all main elements are placed and visible, when the activity is ready
   * to start or when resized.
   * @override
   */
  buildAccessibleComponents() {
    if (this.$canvas && this.accessibleCanvas) {
      super.buildAccessibleComponents();
      if (this.bgA)
        this.bgA.buildAccessibleElements(this.$canvas, this.$div, 'mousedown');
      if (this.bgB)
        this.bgB.buildAccessibleElements(this.$canvas, this.$div, 'mousedown');
    }
  }

  /**
   * Main handler used to process mouse, touch, keyboard and edit events
   * @override
   * @param {external:Event} event - The HTML event to be processed
   * @returns {boolean} - When this event handler returns `false`, jQuery will stop its
   * propagation through the DOM tree. See: {@link http://api.jquery.com/on}
   */
  processEvent(event) {
    if (this.bc && this.playing) {
      //
      // The [AWT.Point](AWT.html#Point) where the mouse or touch event has been originated
      // and two [ActiveBox](ActiveBox.html) pointers used for the [BoxConnector](BoxConnector.html)
      // `origin` and `dest` points.
      let p = null, bx1, bx2;
      //
      // _touchend_ event don't provide pageX nor pageY information
      if (event.type === 'touchend')
        p = this.bc.active ? this.bc.dest.clone() : new Point();
      else {
        // Touch events can have more than one touch, so `pageX` must be obtained from `touches[0]`
        const
          x = event.originalEvent && event.originalEvent.touches ? event.originalEvent.touches[0].pageX : event.pageX,
          y = event.originalEvent && event.originalEvent.touches ? event.originalEvent.touches[0].pageY : event.pageY;
        p = new Point(x - this.$div.offset().left, y - this.$div.offset().top);
      }

      // Flag for tracking `mouseup` events
      let up = false,
        // Flag for assuring that only one media plays per event (avoid event sounds overlapping
        // cell's media sounds)
        m = false,
        // Flag for tracking clicks on the background of grid A
        clickOnBg0 = false,
        // Array to be filled with actions to be executed at the end of event processing
        delayedActions = [];

      switch (event.type) {
        case 'touchcancel':
          // Canvel movement
          if (this.bc.active)
            this.bc.end();
          break;

        case 'mouseup':
          // Don't consider drag moves below 3 pixels. Can be a "trembling click"
          if (this.bc.active && p.distanceTo(this.bc.origin) <= 3) {
            break;
          }
          up = true;
        /* falls through */
        case 'touchend':
        case 'touchstart':
        case 'mousedown':
          if (!this.bc.active) {
            // A new pairing starts
            //
            // Pairings can never start with a `mouseup` event
            if (up)
              break;

            this.ps.stopMedia(1);
            //
            // Determine if click was done on panel A or panel B
            bx1 = this.bgA ? this.bgA.findActiveBox(p) : null;
            bx2 = this.bgB ? this.bgB.findActiveBox(p) : null;
            if (bx1 && (!this.act.useOrder || bx1.idOrder === this.currentItem) ||
              !this.act.useOrder && bx2 && bx2.idAss !== -1) {
              // Start the [BoxConnector](BoxConnector.html)
              if (this.act.dragCells)
                this.bc.begin(p, bx1 || bx2);
              else
                this.bc.begin(p);
              // Play cell media or event sound
              m = m || (bx1 || bx2).playMedia(this.ps, delayedActions);
              if (!m)
                this.playEvent('click');

              // Move the focus to the opposite accessible group
              let bg = bx1 ? this.bgA : this.bgB;
              if (bg && bg.$accessibleDiv) {
                bg = bx1 ? this.bgB : this.bgA;
                if (bg && bg.$accessibleDiv)
                  bg.$accessibleDiv.focus();
              }
            }
          } else {
            this.ps.stopMedia(1);
            // Pairing completed
            //
            // Find the active boxes behind `bc.origin` and `p`
            const origin = this.bc.origin;
            this.bc.end();
            bx1 = this.bgA ? this.bgA.findActiveBox(origin) : null;
            if (bx1) {
              bx2 = this.bgB ? this.bgB.findActiveBox(p) : null;
            } else {
              bx2 = this.bgB ? this.bgB.findActiveBox(origin) : null;
              if (bx2) {
                bx1 = this.bgA ? this.bgA.findActiveBox(p) : null;
                clickOnBg0 = true;
              }
            }
            // Check if the pairing was correct
            if (bx1 && bx2 && bx1.idAss !== -1 && bx2.idAss !== -1 && this.act.abc['secondary']) {
              let ok = false;
              const
                src = bx1.getDescription(),
                dest = bx2.getDescription(),
                matchingDest = this.act.abc['secondary'].getActiveBoxContent(bx1.idOrder);
              if (bx1.idOrder === bx2.idOrder || bx2.getContent().isEquivalent(matchingDest, true)) {
                // Pairing is OK. Play media and disable involved cells
                ok = true;
                bx1.idAss = -1;
                bx2.idAss = -1;
                if (this.act.abc['solvedPrimary']) {
                  bx1.switchToAlt(this.ps);
                  m = m || bx1.playMedia(this.ps, delayedActions);
                } else {
                  if (clickOnBg0)
                    m = m || bx1.playMedia(this.ps, delayedActions);
                  else
                    m = m || bx2.playMedia(this.ps, delayedActions);
                  bx1.clear();
                }
                bx2.clear();

                if (this.act.useOrder && this.bgA)
                  // Load next item
                  this.currentItem = this.bgA.getNextItem(this.currentItem);
              }
              // Check results and notify action
              const cellsPlaced = this.bgB ? this.bgB.countCellsWithIdAss(-1) : 0;
              this.ps.reportNewAction(this.act, 'MATCH', src, dest, ok, cellsPlaced);
              // End activity or play event sound
              if (ok && cellsPlaced === this.bgB.getNumCells())
                this.finishActivity(true);
              else if (!m)
                this.playEvent(ok ? 'actionOk' : 'actionError');
            }
            this.update();

            // Move the focus to the `source` accessible group
            if (this.bgA && this.bgA.$accessibleDiv)
              this.bgA.$accessibleDiv.focus();
          }
          break;

        case 'mousemove':
        case 'touchmove':
          this.bc.moveTo(p);
          break;
      }
      delayedActions.forEach(action => action());
      event.preventDefault();
    }
  }
}

Object.assign(SimpleAssociationPanel.prototype, {
  /**
   * The {@link module:boxes/ActiveBoxbag.ActiveBoxBag ActiveBoxBag} object containing the information to be displayed in the `primary` panel
   * @name module:activities/associations/SimpleAssociation.SimpleAssociationPanel#bgA
   * @type {module:boxes/ActiveBoxBag.ActiveBoxBag} */
  bgA: null,
  /**
   * The {@link module:boxes/ActiveBoxbag.ActiveBoxBag ActiveBoxBag} object containing the information to be displayed in the `secondary` panel
   * @name module:activities/associations/SimpleAssociation.SimpleAssociationPanel#bgB
   * @type {module:boxes/ActiveBoxBag.ActiveBoxBag} */
  bgB: null,
  /**
   * The box connector
   * @name module:activities/associations/SimpleAssociation.SimpleAssociationPanel#bc
   * @type {module:boxes/BoxConnector.BoxConnector} */
  bc: null,
  /**
   * List of mouse, touch and keyboard events intercepted by this panel
   * @override
   * @name module:activities/associations/SimpleAssociation.SimpleAssociationPanel#events
   * @type {string[]} */
  events: ['mousedown', 'mouseup', 'mousemove', 'touchstart', 'touchend', 'touchmove', 'touchcancel'],
});

/**
 * Panel class associated to this type of activity: {@link module:activities/associations/SimpleAssociation.SimpleAssociationPanel SimpleAssociationPanel}
 * @type {class} */
SimpleAssociation.Panel = SimpleAssociationPanel;

// Register activity class
/* harmony default export */ const associations_SimpleAssociation = (Activity.registerClass('@associations.SimpleAssociation', SimpleAssociation));

;// CONCATENATED MODULE: ./src/activities/associations/ComplexAssociation.js
/**
 *  File    : activities/associations/ComplexAssociation.js
 *  Created : 03/06/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */






/**
 * This is a special case of {@link module:activities/associations/SimpleAssociation.SimpleAssociation SimpleAssociation} where the elements of the 'secondary' panel
 * can have zero, one or more associated elements in the 'primary' panel.
 * @extends module:activities/associations/SimpleAssociation.SimpleAssociation
 */
class ComplexAssociation extends SimpleAssociation {
  /**
   * ComplexAssociation constructor
   * @param {module:project/JClicProject.JClicProject} project - The JClic project to which this activity belongs
   */
  constructor(project) {
    super(project);
    this.useIdAss = true;
  }

  /**
   * Loads this object settings from an XML element
   * @override
   * @param {external:jQuery} $xml - The jQuery XML element to parse
   */
  setProperties($xml) {
    super.setProperties($xml);
    this.abc['primary'].avoidAllIdsNull(this.abc['secondary'].getNumCells());
  }

  /**
   * Retrieves the minimum number of actions needed to solve this activity.
   * @override
   * @returns {number}
   */
  getMinNumActions() {
    if (this.invAss)
      return this.abc['secondary'].getNumCells();
    else
      return this.abc['primary'].getNumCells() - this.nonAssignedCells;
  }
}

Object.assign(ComplexAssociation.prototype, {
  /**
   * Number of unassigned cells
   * @name module:activities/associations/ComplexAssociation.ComplexAssociation#nonAssignedCells
   * @type {number} */
  nonAssignedCells: 0,
  /**
   * Uses cell's `idAss` field to check if pairings match
   * @name module:activities/associations/ComplexAssociation.ComplexAssociation#useIdAss
   * @type {boolean} */
  useIdAss: false,
});

/**
 * The {@link module:Activity.ActivityPanel ActivityPanel} where {@link module:activities/associations/ComplexAssociation.ComplexAssociation ComplexAssociation} activities are played.
 * @extends module:activities/associations/SimpleAssociation.SimpleAssociationPanel
 */
class ComplexAssociationPanel extends SimpleAssociationPanel {
  /**
   * ComplexAssociationPanel prototype
   * @param {module:Activity.Activity} act - The {@link module:Activity.Activity Activity} to which this Panel belongs
   * @param {module:JClicPlayer.JClicPlayer} ps - Any object implementing the methods defined in the
   * [PlayStation](http://projectestac.github.io/jclic/apidoc/edu/xtec/jclic/PlayStation.html) Java interface.
   * @param {external:jQuery} [$div] - The jQuery DOM element where this Panel will deploy
   */
  constructor(act, ps, $div) {
    super(act, ps, $div);
  }

  /**
   * Prepares the visual components of the activity
   * @override
   */
  buildVisualComponents() {
    super.buildVisualComponents();

    const
      abcA = this.act.abc['primary'],
      abcB = this.act.abc['secondary'];

    if (abcA && abcB) {
      if (this.act.invAss)
        this.invAssCheck = Array(abcB.getNumCells()).fill(false);
      this.bgA.setDefaultIdAss();
      this.act.nonAssignedCells = 0;
      this.bgA.cells.forEach(bx => {
        if (bx.idAss === -1) {
          this.act.nonAssignedCells++;
          bx.switchToAlt(this.ps);
        }
      });
    }
  }

  /**
   * Checks if all inverse associations are done
   * @returns {boolean}
   */
  checkInvAss() {
    if (!this.act.invAss || !this.invAssCheck)
      return false;
    return this.invAssCheck.every(chk => chk);
  }

  /**
   * Main handler used to process mouse, touch, keyboard and edit events
   * @override
   * @param {external:Event} event - The HTML event to be processed
   * @returns {boolean} - When this event handler returns `false`, jQuery will stop its
   * propagation through the DOM tree. See: {@link http://api.jquery.com/on}
   */
  processEvent(event) {
    if (this.bc && this.playing) {
      //
      // The [AWT.Point](AWT.html#Point) where the mouse or touch event has been originated
      // and two [ActiveBox](ActiveBox.html) pointers used for the [BoxConnector](BoxConnector.html)
      // `origin` and `dest` points.
      let p = null, bx1, bx2;

      //
      // _touchend_ event don't provide pageX nor pageY information
      if (event.type === 'touchend') {
        p = this.bc.active ? this.bc.dest.clone() : new Point();
      } else {
        // Touch events can have more than one touch, so `pageX` must be obtained from `touches[0]`
        let
          x = event.originalEvent && event.originalEvent.touches ? event.originalEvent.touches[0].pageX : event.pageX,
          y = event.originalEvent && event.originalEvent.touches ? event.originalEvent.touches[0].pageY : event.pageY;
        p = new Point(x - this.$div.offset().left, y - this.$div.offset().top);
      }

      let
        // Flag for tracking `mouseup` events
        up = false,
        // Flag for assuring that only one media plays per event (avoid event sounds overlapping
        // cell's media sounds)
        m = false,
        // Flag for tracking clicks on the background of grid A
        clickOnBg0 = false,
        // Array to be filled with actions to be executed at the end of event processing
        delayedActions = [];

      switch (event.type) {
        case 'touchcancel':
          // Canvel movement
          if (this.bc.active)
            this.bc.end();
          break;

        case 'mouseup':
          // Don't consider drag moves below 3 pixels. Can be a "trembling click"
          if (this.bc.active && p.distanceTo(this.bc.origin) <= 3) {
            break;
          }
          up = true;
        /* falls through */
        case 'touchend':
        case 'touchstart':
        case 'mousedown':
          if (!this.bc.active) {
            // New pairing starts
            //
            // Pairings can never start with a `mouseup` event
            if (up)
              break;

            this.ps.stopMedia(1);
            // Determine if click was done on panel A or panel B
            bx1 = this.bgA ? this.bgA.findActiveBox(p) : null;
            bx2 = this.bgB ? this.bgB.findActiveBox(p) : null;
            if (bx1 && bx1.idAss !== -1 && (!this.act.useOrder || bx1.idOrder === this.currentItem) ||
              !this.act.useOrder && bx2) {
              // Start the [BoxConnector](BoxConnector.html)
              if (this.act.dragCells)
                this.bc.begin(p, bx1 || bx2);
              else
                this.bc.begin(p);
              // Play cell media or event sound
              m = m || (bx1 || bx2).playMedia(this.ps, delayedActions);
              if (!m)
                this.playEvent('click');
            }

            // Move the focus to the opposite accessible group
            let bg = bx1 ? this.bgA : this.bgB;
            if (bg && bg.$accessibleDiv) {
              bg = bx1 ? this.bgB : this.bgA;
              if (bg && bg.$accessibleDiv)
                bg.$accessibleDiv.focus();
            }
          } else {
            this.ps.stopMedia(1);
            // Pairing completed
            //
            // Find the active boxes behind `bc.origin` and `p`
            const origin = this.bc.origin;
            this.bc.end();
            bx1 = this.bgA ? this.bgA.findActiveBox(origin) : null;
            if (bx1) {
              bx2 = this.bgB ? this.bgB.findActiveBox(p) : null;
            } else {
              bx2 = this.bgB ? this.bgB.findActiveBox(origin) : null;
              if (bx2) {
                bx1 = this.bgA ? this.bgA.findActiveBox(p) : null;
                clickOnBg0 = true;
              }
            }
            // Check if the pairing was correct
            if (bx1 && bx2 && bx1.idAss !== -1 && !bx2.isInactive() && this.act.abc['secondary']) {
              const
                src = bx1.getDescription(),
                dest = bx2.getDescription(),
                matchingDest = this.act.abc['secondary'].getActiveBoxContent(bx1.idAss);
              let ok = false;

              if (bx1.idAss === bx2.idOrder || bx2.getContent().isEquivalent(matchingDest, true)) {
                // Pairing was OK. Play media and disable involved cells
                ok = true;
                bx1.idAss = -1;
                if (this.act.abc['solvedPrimary']) {
                  bx1.switchToAlt(this.ps);
                  m = m || bx1.playMedia(this.ps, delayedActions);
                } else {
                  if (clickOnBg0)
                    m = m || bx1.playMedia(this.ps, delayedActions);
                  else
                    m = m || bx2.playMedia(this.ps, delayedActions);
                  bx1.clear();
                }
                if (this.act.invAss) {
                  this.invAssCheck[bx2.idOrder] = true;
                  bx2.clear();
                }
                if (this.act.useOrder && this.bgA)
                  // Load next item
                  this.currentItem = this.bgA.getNextItem(this.currentItem);
              }
              // Check results and notify action
              if (this.bgA) {
                const cellsPlaced = this.bgA.countCellsWithIdAss(-1);
                this.ps.reportNewAction(this.act, 'MATCH', src, dest, ok, cellsPlaced - this.act.nonAssignedCells);
                // End activity or play event sound
                if (ok && (this.checkInvAss() || cellsPlaced === this.bgA.getNumCells()))
                  this.finishActivity(true);
                else if (!m)
                  this.playEvent(ok ? 'actionOk' : 'actionError');
              }
            } else if (this.bgB && (clickOnBg0 && this.bgA && this.bgA.contains(p) || !clickOnBg0 && this.bgB.contains(p))) {
              // click on grid, out of cell
              const srcOut = bx1 ? bx1.getDescription() : bx2 ? bx2.getDescription() : 'null';
              this.ps.reportNewAction(this.act, 'MATCH', srcOut, 'null', false, this.bgB.countCellsWithIdAss(-1));
              this.playEvent('actionError');
            }
            this.update();

            // Move the focus to the `source` accessible group
            if (this.bgA && this.bgA.$accessibleDiv)
              this.bgA.$accessibleDiv.focus();
          }
          break;

        case 'mousemove':
        case 'touchmove':
          this.bc.moveTo(p);
          break;
      }
      delayedActions.forEach(action => action());
      event.preventDefault();
    }
  }
}

Object.assign(ComplexAssociationPanel.prototype, {
  /**
   * Array for storing checked associations
   * @name module:activities/associations/ComplexAssociation.ComplexAssociationPanel#invAssCheck
   * @type {boolean[]} */
  invAssCheck: null,
});

/**
 * Panel class associated to this type of activity: {@link module:activities/associations/ComplexAssociation.ComplexAssociationPanel ComplexAssociationPanel}
 * @type {class} */
ComplexAssociation.Panel = ComplexAssociationPanel;

// Register activity class
/* harmony default export */ const associations_ComplexAssociation = (src_Activity.registerClass('@associations.ComplexAssociation', ComplexAssociation));

;// CONCATENATED MODULE: ./src/boxes/TextGrid.js
/**
 *  File    : boxes/TextGrid.js
 *  Created : 12/06/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */






/**
 * Default values
 * @type {object}
 */
const defaults = {
  MIN_CELL_SIZE: 12,
  DEFAULT_CELL_SIZE: 20,
  MIN_INTERNAL_MARGIN: 2
};

/**
 * Binary flags used to mark status
 * @type {object}
 */
const flags = {
  NORMAL: 0,
  INVERTED: 1,
  HIDDEN: 2,
  LOCKED: 4,
  MARKED: 8,
  TRANSPARENT: 16
};

/**
 * This class is a special type of {@link module:boxes/AbstractBox.AbstractBox AbstractBox} that displays a grid of single
 * characters.
 *
 * It's used {@link module:activities/textGrid/CrossWord.CrossWord CrossWord} and {@link module:activities/textGrid/WordSearch.WordSearch WordSearch} activities.
 * @extends module:boxes/AbstractBox.AbstractBox
 */
class TextGrid extends boxes_AbstractBox {
  /**
   * TextGrid constructor
   * @param {module:boxes/AbstractBox.AbstractBox} parent - The AbstractBox to which this text grid belongs
   * @param {module:AWT.Container} container - The container where this text grid is placed.
   * @param {module:boxes/BoxBase.BoxBase} boxBase - The object where colors, fonts, border and other graphic properties
   * @param {number} x - `X` coordinate of the upper left corner of this grid
   * @param {number} y - `Y` coordinate of the upper left corner of this grid
   * @param {number} ncw - Number of columns of the grid
   * @param {number} nch - Nomber of rows of the grid
   * @param {number} cellW - Width of the cells
   * @param {number} cellH - Height of the cells
   * @param {boolean} border - When `true`, a border must be drawn between the cells
   */
  constructor(parent, container, boxBase, x, y, ncw, nch, cellW, cellH, border) {
    // *TextGrid* extends [AbstractBox](AbstractBox.html)
    super(parent, container, boxBase);
    this.pos.x = x;
    this.pos.y = y;
    this.nCols = Math.max(1, ncw);
    this.nRows = Math.max(1, nch);
    this.cellWidth = Math.max(cellW, defaults.MIN_CELL_SIZE);
    this.cellHeight = Math.max(cellH, defaults.MIN_CELL_SIZE);
    this.dim.width = cellW * this.nCols;
    this.dim.height = cellH * this.nRows;
    this.setChars(' ');
    this.preferredBounds = new Rectangle(this.pos, this.dim);
    this.setBorder(border);
    this.cursorTimer = new Timer(() => this.blink(0), 500, false);
    this.cursorEnabled = false;
    this.useCursor = false;
    this.wildTransparent = false;
    this.cursor = new Point();
  }

  /**
   * Factory constructor that creates an empty grid based on a {@link module:boxes/TextGridContent.TextGridContent TextGridContent}
   * @param {module:boxes/AbstractBox.AbstractBox} parent - The AbstractBox to which the text grid belongs
   * @param {module:AWT.Container} container - The container where the text grid will be placed.
   * @param {number} x - `X` coordinate of the upper left corner of the grid
   * @param {number} y - `Y` coordinate of the upper left corner of the grid
   * @param {module:boxes/TextGridContent.TextGridContent} tgc - Object with the content and other settings of the grid
   * @param {boolean} wildTransparent - When `true`, the wildcard character will be transparent
   * @returns {module:boxes/TextGrid.TextGrid}
   */
  static createEmptyGrid(parent, container, x, y, tgc, wildTransparent) {
    const result = new TextGrid(parent, container, tgc.style,
      x, y, tgc.ncw, tgc.nch, tgc.w, tgc.h, tgc.border);
    result.wild = tgc.wild;
    result.randomChars = tgc.randomChars;
    result.wildTransparent = wildTransparent;
    return result;
  }

  /**
   * Sets the characters to be placed in the cells of this TextGrid
   * @param {string} text
   */
  setChars(text) {
    this.chars = [];
    this.answers = [];
    this.attributes = [];
    for (let py = 0; py < this.nRows; py++) {
      const line = py < text.length ? text[py] : '';
      this.chars[py] = line.split('');
      this.answers[py] = [];
      this.attributes[py] = [];
      for (let px = 0; px < this.nCols; px++) {
        if (px >= line.length)
          this.chars[py][px] = ' ';
        this.answers[py][px] = this.chars[py][px];
        this.attributes[py][px] = flags.NORMAL;
      }
    }
  }

  /**
   * Substitutes the current content of all cells with wildcards with a randomly generated char.
   * @see TextGridContent#randomChars
   */
  randomize() {
    for (let py = 0; py < this.nRows; py++)
      for (let px = 0; px < this.nCols; px++)
        if (this.chars[py][px] === this.wild)
          this.chars[py][px] = this.randomChars.charAt(
            Math.floor(Math.random() * this.randomChars.length));
  }

  /**
   * Clears or sets global attributes to all cells
   * @param {boolean} lockWild - When `true`, the wildcard cells will be marked with special
   * attributes (used in CrossWords to mark black cells)
   * @param {boolean} clearChars - When `true`, the current content of cells will be erased.
   */
  setCellAttributes(lockWild, clearChars) {
    let atr = flags.LOCKED;
    if (this.wildTransparent)
      atr |= flags.TRANSPARENT;
    else
      atr |= flags.INVERTED | flags.HIDDEN;
    for (let py = 0; py < this.nRows; py++) {
      for (let px = 0; px < this.nCols; px++) {
        if (lockWild && this.chars[py][px] === this.wild)
          this.attributes[py][px] = atr;
        else {
          this.attributes[py][px] = flags.NORMAL;
          if (clearChars)
            this.chars[py][px] = ' ';
        }
      }
    }
  }

  /**
   * Sets or unsets the `locked` properties (black cell) to a specific cell.
   * @param {number} px - The logical 'X' coordinate of the cell
   * @param {number} py - The logical 'Y' coordinate of the cell
   * @param {boolean} locked - When true, the `locked` attribute will be on.
   */
  setCellLocked(px, py, locked) {
    if (px >= 0 && px < this.nCols && py >= 0 && py < this.nRows) {
      this.attributes[py][px] = locked ?
        flags.LOCKED |
        (this.wildTransparent ?
          flags.TRANSPARENT :
          flags.INVERTED |
          flags.HIDDEN) :
        flags.NORMAL;
    }
  }

  /**
   * For a specific cell located at column `rx` and row `ry`, finds the number of words delimited
   * by wildchars located behind its current position and in the same row and column. Used in
   * {@link module:activities/textGrid/CrossWord.CrossWord CrossWord} activities to find the definition for a specific cell.
   *
   * The result is returned as 'x' and 'y' properties of a logical point.
   * @param {number} rx - The 'X' position of the cell
   * @param {number} ry - The 'Y' position of the cell
   * @returns {module:AWT.Point} - The logical positions of the definition for this cell inside the list
   * of current definitions of its row and column. '0' means first definition of its row/column,
   * '1' the second one, etc.
   */
  getItemFor(rx, ry) {
    if (!this.isValidCell(rx, ry))
      return null;

    const point = new Point();
    let
      inBlack = false,
      startCount = false;

    for (let px = 0; px < rx; px++) {
      if ((this.attributes[ry][px] & flags.LOCKED) !== 0) {
        if (!inBlack) {
          if (startCount)
            point.x++;
          inBlack = true;
        }
      } else {
        startCount = true;
        inBlack = false;
      }
    }
    inBlack = false;
    startCount = false;
    for (let py = 0; py < ry; py++) {
      if ((this.attributes[py][rx] & flags.LOCKED) !== 0) {
        if (!inBlack) {
          if (startCount)
            point.y++;
          inBlack = true;
        }
      } else {
        startCount = true;
        inBlack = false;
      }
    }
    return point;
  }

  /**
   * Whether the blinking cursor must be enabled or disabled.
   * @param {boolean} status
   */
  setCursorEnabled(status) {
    this.cursorEnabled = status;
    if (status === true)
      this.startCursorBlink();
    else
      this.stopCursorBlink();
  }

  /**
   * Starts the {@link module:AWT.Timer} that makes the cursor blink.
   */
  startCursorBlink() {
    if (this.useCursor && this.cursorEnabled && this.cursorTimer && !this.cursorTimer.isRunning()) {
      this.blink(1);
      this.cursorTimer.start();
    }
  }

  /**
   * Stops the {@link module:AWT.Timer} that makes the cursor blink.
   */
  stopCursorBlink() {
    if (this.cursorTimer && this.cursorTimer.isRunning()) {
      this.cursorTimer.stop();
      this.blink(-1);
    }
  }

  /**
   * Moves the cursor in the specified x and y directions.
   * @param {number} dx - Amount to move in the 'X' axis
   * @param {number} dy - Amount to move in the 'Y' axis
   * @param {boolean} skipLocked - Skip locked cells (wildcards in {@link module:activities/textGrid/CrossWord.CrossWord CrossWord})
   */
  moveCursor(dx, dy, skipLocked) {
    if (this.useCursor) {
      const point = this.findNextCellWithAttr(this.cursor.x, this.cursor.y,
        skipLocked ? flags.LOCKED : flags.NORMAL,
        dx, dy, false);

      if (!this.cursor.equals(point))
        this.setCursorAt(point.x, point.y, skipLocked);
    }
  }

  /**
   * Finds the coordinates of the nearest non-locked cell (non-wildcard) moving on the indicated
   * 'X' and 'Y' directions.
   * @param {module:AWT.Point} - Logical coordinates of the starting point
   * @param {number} dx - 0 means no movement, 1 go right, -1 go left.
   * @param {number} dy - 0 means no movement, 1 go down, -1 go up.
   * @returns {module:AWT.Point}
   */
  findFreeCell(from, dx, dy) {
    let result = null;
    if (from && (dx !== 0 || dy !== 0)) {
      const scan = new Point(from);
      while (result === null) {
        scan.x += dx;
        scan.y += dy;
        if (scan.x < 0 || scan.x >= this.nCols || scan.y < 0 || scan.y >= this.nRows)
          break;
        if (!this.getCellAttribute(scan.x, scan.y, flags.LOCKED))
          result = scan;
      }
    }
    return result;
  }

  /**
   * Finds the first cell with the specified attributes at the specified state, starting
   * at specified point.
   * @param {number} startX - Starting X coordinate
   * @param {number} startY - Starting Y coordinate
   * @param {number} attr - Attribute to check. See {@link module:boxes/TextGrid.TextGrid.flags}.
   * @param {number} dx - 0 means no movement, 1 go right, -1 go left.
   * @param {number} dy - 0 means no movement, 1 go down, -1 go up.
   * @param {boolean} attrState - Desired state (enabled or disabled) of `attr`
   * @returns {module:AWT.Point}
   */
  findNextCellWithAttr(startX, startY, attr, dx, dy, attrState) {
    const point = new Point(startX + dx, startY + dy);
    while (true) {
      if (point.x < 0) {
        point.x = this.nCols - 1;
        if (point.y > 0)
          point.y--;
        else
          point.y = this.nRows - 1;
      } else if (point.x >= this.nCols) {
        point.x = 0;
        if (point.y < this.nRows - 1)
          point.y++;
        else
          point.y = 0;
      }
      if (point.y < 0) {
        point.y = this.nRows - 1;
        if (point.x > 0)
          point.x--;
        else
          point.x = this.nCols - 1;
      } else if (point.y >= this.nRows) {
        point.y = 0;
        if (point.x < this.nCols - 1)
          point.x++;
        else
          point.x = 0;
      }
      if (point.x === startX && point.y === startY ||
        this.getCellAttribute(point.x, point.y, attr) === attrState)
        break;
      point.x += dx;
      point.y += dy;
    }
    return point;
  }

  /**
   * Sets the blinking cursor at a specific point
   * @param {number} px - X coordinate
   * @param {number} py - Y coordinate
   * @param {boolean} skipLocked - Skip locked (wildcard) cells
   */
  setCursorAt(px, py, skipLocked) {
    this.stopCursorBlink();
    if (this.isValidCell(px, py)) {
      this.cursor.x = px;
      this.cursor.y = py;
      this.useCursor = true;
      if (skipLocked && this.getCellAttribute(px, py, flags.LOCKED)) {
        this.moveCursor(1, 0, skipLocked);
      } else {
        if (this.cursorEnabled)
          this.startCursorBlink();
      }
    }
  }

  /**
   * Sets the `useCursor` property of this text grid
   * @param {boolean} value
   */
  setUseCursor(value) {
    this.useCursor = value;
  }

  /**
   * Gets the current position of the blinking cursor
   * @returns {module:AWT.Point}
   */
  getCursor() {
    return this.cursor;
  }

  /**
   * Counts the number of cells of this grid with the specified character
   * @param {string} ch
   * @returns {number}
   */
  countCharsLike(ch) {
    let result = 0;
    for (let py = 0; py < this.nRows; py++)
      for (let px = 0; px < this.nCols; px++)
        if (this.chars[py][px] === ch)
          result++;
    return result;
  }

  /**
   * Gets the number of cells of this grid
   * @returns {number}
   */
  getNumCells() {
    return this.nRows * this.nCols;
  }

  /**
   * Counts the number of coincidences between the `answers` array and the current content of this grid
   * @param {boolean} checkCase - Make comparisions case-sensitive
   * @returns {number}
   */
  countCoincidences(checkCase) {
    let result = 0;
    if (this.answers)
      for (let py = 0; py < this.nRows; py++)
        for (let px = 0; px < this.nCols; px++)
          if (this.isCellOk(px, py, checkCase))
            result++;
    return result;
  }

  /**
   * Checks if a specific cell is equivalent to the content of `answers` at its position
   * @param {number} px - X coordinate
   * @param {number} py - Y coordinate
   * @param {boolean} checkCase - Make comparisions case-sensitive
   * @returns {boolean}
   */
  isCellOk(px, py, checkCase) {
    let result = false;
    if (this.isValidCell(px, py)) {
      const ch = this.chars[py][px];
      if (ch !== this.wild) {
        const ch2 = this.answers[py][px];
        if (ch === ch2 ||
          !checkCase && ch.toUpperCase() === ch2.toUpperCase())
          result = true;
      }
    }
    return result;
  }

  /**
   * Gets the logical coordinates (in 'cell' units) of a device point into the grid
   * @param {module:AWT.Point} devicePoint
   * @returns {module:AWT.Point}
   */
  getLogicalCoords(devicePoint) {
    if (!this.contains(devicePoint))
      return null;
    const
      px = Math.floor((devicePoint.x - this.pos.x) / this.cellWidth),
      py = Math.floor((devicePoint.y - this.pos.y) / this.cellHeight);

    return this.isValidCell(px, py) ? new Point(px, py) : null;
  }

  /**
   * Checks if the specified logical coordinates are inside the valid bounds of the grid.
   * @param {number} px - 'X' coordinate
   * @param {number} py - 'Y' coordinate
   * @returns {boolean}
   */
  isValidCell(px, py) {
    return px < this.nCols && py < this.nRows && px >= 0 && py >= 0;
  }

  /**
   * Sets the specified character as a content of the cell at specified coordinates
   * @param {number} px - 'X' coordinate
   * @param {number} py - 'Y' coordinate
   * @param {string} ch - The character to set.
   */
  setCharAt(px, py, ch) {
    if (this.isValidCell(px, py)) {
      this.chars[py][px] = ch;
      this.repaintCell(px, py);
    }
  }

  /**
   * Gets the character of the cell at the specified coordinates
   * @param {number} px - 'X' coordinate
   * @param {number} py - 'Y' coordinate
   * @returns {string}
   */
  getCharAt(px, py) {
    return this.isValidCell(px, py) ? this.chars[py][px] : ' ';
  }

  /**
   * Gets the text formed by the letters between two cells that share a straight line on the grid.
   * The text can be formed horizontally, vertically and diagonal, both in left-to-right or
   * right-to-left direction.
   * @param {number} x0 - 'X' coordinate of the first cell
   * @param {number} y0 - 'Y' coordinate of the first cell
   * @param {number} x1 - 'X' coordinate of the second cell
   * @param {number} y1 - 'Y' coordinate of the second cell
   * @returns {string}
   */
  getStringBetween(x0, y0, x1, y1) {
    let sb = '';
    if (this.isValidCell(x0, y0) && this.isValidCell(x1, y1)) {
      let
        dx = x1 - x0,
        dy = y1 - y0;
      if (dx === 0 || dy === 0 || Math.abs(dx) === Math.abs(dy)) {
        const steps = Math.max(Math.abs(dx), Math.abs(dy));
        if (steps > 0) {
          dx /= steps;
          dy /= steps;
        }
        for (let i = 0; i <= steps; i++)
          sb += this.getCharAt(x0 + dx * i, y0 + dy * i);
      }
    }
    return sb;
  }

  /**
   * Sets a specific attribute to all cells forming a straight line between two cells on the grid.
   * @param {number} x0 - 'X' coordinate of the first cell
   * @param {number} y0 - 'Y' coordinate of the first cell
   * @param {number} x1 - 'X' coordinate of the second cell
   * @param {number} y1 - 'Y' coordinate of the second cell
   * @param {number} attribute - The binary flag representing this attribute. See {@link module:boxes/TextGrid.TextGrid.flags}.
   * @param {boolean} value - Whether to set or unset the attribute.
   */
  setAttributeBetween(x0, y0, x1, y1, attribute, value) {
    if (this.isValidCell(x0, y0) && this.isValidCell(x1, y1)) {
      let
        dx = x1 - x0,
        dy = y1 - y0;

      if (dx === 0 || dy === 0 || Math.abs(dx) === Math.abs(dy)) {
        const steps = Math.max(Math.abs(dx), Math.abs(dy));
        if (steps > 0) {
          dx /= steps;
          dy /= steps;
        }
        for (let i = 0; i <= steps; i++)
          this.setAttribute(x0 + dx * i, y0 + dy * i, attribute, value);
      }
    }
  }

  /**
   * Sets or unsets a specifi attrobut to a cell.
   * @param {number} px - The 'X' coordinate of the cell
   * @param {number} py - The 'Y' coordinate of the cell
   * @param {number} attribute - The binary flag representing this attribute. See {@link module:boxes/TextGrid.TextGrid.flags}.
   * @param {boolean} state - Whether to set or unset the attribute.
   */
  setAttribute(px, py, attribute, state) {
    if (this.isValidCell(px, py)) {
      if (this.attribute === flags.MARKED && !state)
        this.repaintCell(px, py);
      this.attributes[py][px] &= ~attribute;
      this.attributes[py][px] |= state ? attribute : 0;
      if (attribute !== flags.MARKED || state)
        this.repaintCell(px, py);
    }
  }

  /**
   * Sets the specified attribute to all cells.
   * @param {number} attribute - The binary flag representing this attribute. See {@link module:boxes/TextGrid.TextGrid.flags}.
   * @param {boolean} state - Whether to set or unset the attribute.
   */
  setAllCellsAttribute(attribute, state) {
    for (let py = 0; py < this.nRows; py++)
      for (let px = 0; px < this.nCols; px++)
        this.setAttribute(px, py, attribute, state);
  }

  /**
   * Gets the specified attribute of a cell
   * @param {number} px - The 'X' coordinate of the cell
   * @param {number} py - The 'Y' coordinate of the cell
   * @param {number} attribute - The binary flag representing this attribute. See {@link module:boxes/TextGrid.TextGrid.flags}.
   * @returns {boolean} - `true` if the cell has this attribute, `false` otherwise.
   */
  getCellAttribute(px, py, attribute) {
    return this.isValidCell(px, py) ? (this.attributes[py][px] & attribute) !== 0 : false;
  }

  /**
   * Gets the rectangle enclosing a specific cell
   * @param {number} px - The 'X' coordinate of the cell
   * @param {number} py - The 'Y' coordinate of the cell
   * @returns {module:AWT.Rectangle}
   */
  getCellRect(px, py) {
    return new Rectangle(this.pos.x + px * this.cellWidth, this.pos.y + py * this.cellHeight, this.cellWidth, this.cellHeight);
  }

  /**
   * Gets the rectangle enclosing a specific cell, including the border thick.
   * @param {number} px - The 'X' coordinate of the cell
   * @param {number} py - The 'Y' coordinate of the cell
   * @returns {module:AWT.Rectangle}
   */
  getCellBorderBounds(px, py) {
    const isMarked = this.getCellAttribute(px, py, flags.MARKED);
    if (!this.border && !isMarked)
      return this.getCellRect(px, py);

    const
      style = this.getBoxBaseResolve(),
      strk = isMarked ? style.markerStroke : style.borderStroke;

    return this.getCellRect(px, py).grow(strk.lineWidth, strk.lineWidth);
  }

  /**
   * Repaints a cell
   * @param {number} px - The 'X' coordinate of the cell
   * @param {number} py - The 'Y' coordinate of the cell
   */
  repaintCell(px, py) {
    if (this.container)
      this.container.invalidate(this.getCellBorderBounds(px, py)).update();
  }

  /**
   * Gets the preferred size of this grid
   * @returns {module:AWT.Dimension}
   */
  getPreferredSize() {
    return this.preferredBounds.dim;
  }

  /**
   * Gets the minimum size of this grid
   * @returns {module:AWT.Dimension}
   */
  getMinimumSize() {
    return new Dimension(defaults.MIN_CELL_SIZE * this.nCols, defaults.MIN_CELL_SIZE * this.nRows);
  }

  /**
   * Scales the grid to a new size
   * @param {number} scale - The factor used to multiply all coordinates and sizes
   * @returns {module:AWT.Dimension}
   */
  getScaledSize(scale) {
    return new Dimension(
      roundTo(scale * this.preferredBounds.dim.width, this.nCols),
      roundTo(scale * this.preferredBounds.dim.height, this.nRows));
  }

  /**
   * Overrides {@link module:boxes/AbstractBox.AbstractBox#setBounds}
   * @override
   * @param {AWT.Rectangle|number} rect - An AWT.Rectangle object, or the `x` coordinate of the
   * upper-left corner of a new rectangle.
   * @param {number} [y] - `y` coordinate of the upper-left corner of the new rectangle.
   * @param {number} [w] - Width of the new rectangle.
   * @param {number} [h] - Height of the new rectangle.
   */
  setBounds(rect, y, w, h) {
    super.setBounds(rect, y, w, h);
    this.cellWidth = this.dim.width / this.nCols;
    this.cellHeight = this.dim.height / this.nRows;
  }

  /**
   * Overrides {@link module:boxes/AbstractBox.AbstractBox#updateContent}
   * @override
   * @param {external:CanvasRenderingContext2D} ctx - The canvas rendering context used to draw the
   * grid.
   * @param {module:AWT.Rectangle} [dirtyRegion] - The area that must be repainted. `null` refers to the whole box.
   */
  updateContent(ctx, dirtyRegion) {
    const style = this.getBoxBaseResolve();

    // test font size
    ctx.font = style.font.cssFont();
    ctx.textBaseline = 'alphabetic';
    style.prepareText(ctx, 'W',
      this.cellWidth - 2 * defaults.MIN_INTERNAL_MARGIN,
      this.cellHeight - 2 * defaults.MIN_INTERNAL_MARGIN);

    const ch = [];
    const ry = (this.cellHeight - style.font.getHeight()) / 2 + style.font.getMetrics().ascent;

    for (let py = 0; py < this.nRows; py++) {
      for (let px = 0; px < this.nCols; px++) {
        const bxr = this.getCellBorderBounds(px, py);
        if (bxr.intersects(dirtyRegion)) {
          const attr = this.attributes[py][px];
          if ((attr & flags.TRANSPARENT) === 0) {
            const isInverted = (attr & flags.INVERTED) !== 0;
            const isMarked = (attr & flags.MARKED) !== 0;
            const isCursor = this.useCursor && this.cursor.x === px && this.cursor.y === py;
            const boxBounds = this.getCellRect(px, py);
            ctx.fillStyle = isCursor && this.cursorBlink ?
              style.inactiveColor :
              isInverted ? style.textColor : style.backColor;
            boxBounds.fill(ctx);
            ctx.strokeStyle = 'black';
            if ((attr & flags.HIDDEN) === 0) {
              ch[0] = this.chars[py][px];
              if (ch[0]) {
                const dx = boxBounds.pos.x + (this.cellWidth - ctx.measureText(ch[0]).width) / 2;
                const dy = boxBounds.pos.y + ry;

                if (style.shadow) {
                  // Render text shadow
                  const d = Math.max(1, style.font.size / 10);
                  ctx.fillStyle = style.shadowColor;
                  ctx.fillText(ch[0], dx + d, dy + d);
                }
                // Render text
                ctx.fillStyle = isInverted ? style.backColor
                  : this.isAlternative() ? style.alternativeColor : style.textColor;
                ctx.fillText(ch[0], dx, dy);
              }
            }
            if (this.border || isMarked) {
              ctx.strokeStyle = style.borderColor;
              style[isMarked ? 'markerStroke' : 'borderStroke'].setStroke(ctx);
              if (isMarked)
                ctx.globalCompositeOperation = 'xor';

              // Draw border
              boxBounds.stroke(ctx);

              // Reset ctx default values
              if (isMarked)
                ctx.globalCompositeOperation = 'source-over';
            }
            ctx.strokeStyle = 'black';
            Stroke.prototype.setStroke(ctx);
          }
        }
      }
    }
    return true;
  }

  /**
   * Makes the cursor blink, alternating between two states. This method should be called only by
   * {@link module:boxes/TextGrid.TextGrid#cursorTimer}
   * @param {boolean} status
   */
  blink(status) {
    // TODO: Move blink and timer to ActivityPanel
    if (this.useCursor) {
      this.cursorBlink = status === 1 ? true : status === -1 ? false : !this.cursorBlink;
      this.repaintCell(this.cursor.x, this.cursor.y);
    }
  }

  /**
   * Stops the cursor timer if not `null` and active
   */
  end() {
    if (this.cursorTimer) {
      this.cursorTimer.stop();
      this.cursorTimer = null;
    }
  }
}

Object.assign(TextGrid.prototype, {
  /**
   * Number of rows
   * @name module:boxes/TextGrid.TextGrid#nRows
   * @type {number} */
  nRows: 1,
  /**
   * Number of columns
   * @name module:boxes/TextGrid.TextGrid#nCols
   * @type {number} */
  nCols: 1,
  /**
   * Two-dimension array of characters
   * @name module:boxes/TextGrid.TextGrid#chars
   * @type {string[][]} */
  chars: null,
  /**
   * Two-dimension array with the expected characters, used to check user's answers.
   * @name module:boxes/TextGrid.TextGrid#answers
   * @type {string[][]} */
  answers: null,
  /**
   * Two-dimension array of bytes used as containers of boolean attributes
   * @name module:boxes/TextGrid.TextGrid#attributes
   * @see TextGrid.flags
   * @type {number[][]} */
  attributes: null,
  /**
   * The cell width, in pixels
   * @name module:boxes/TextGrid.TextGrid#cellWidth
   * @type {number} */
  cellWidth: 20,
  /**
   * The cell height, in pixels
   * @name module:boxes/TextGrid.TextGrid#cellHeight
   * @type {number} */
  cellHeight: 20,
  /**
   * The preferred bounds of this grid
   * @name module:boxes/TextGrid.TextGrid#preferredBounds
   * @type {module:AWT.Rectangle} */
  preferredBounds: null,
  /**
   * The character to be used as wildcard
   * @name module:boxes/TextGrid.TextGrid#wild
   * @type {string} */
  wild: boxes_TextGridContent.prototype.wild,
  /**
   * Characters that can be used when randomizing the content of this grid
   * @name module:boxes/TextGrid.TextGrid#randomChars
   * @see TextGridContent#randomChars
   * @type {string} */
  randomChars: boxes_TextGridContent.prototype.randomChars,
  /**
   * Whether the blinking cursor is enabled or disabled
   * @name module:boxes/TextGrid.TextGrid#cursorEnabled
   * @type {boolean} */
  cursorEnabled: false,
  /**
   * Whether this grid uses a blinking cursor or not
   * @name module:boxes/TextGrid.TextGrid#useCursor
   * @type {boolean} */
  useCursor: false,
  /**
   * The current position of the cursor
   * @name module:boxes/TextGrid.TextGrid#cursor
   * @type {module:AWT.Point} */
  cursor: null,
  /**
   * `true` when the cursor is "blinking" (cell drawn with {@link module:boxes/BoxBase.BoxBase BoxBase} `inverse` attributes)
   * @name module:boxes/TextGrid.TextGrid#cursorBlink
   * @type {boolean} */
  cursorBlink: false,
  /**
   * Controls the blinking of the cursor
   * @name module:boxes/TextGrid.TextGrid#cursorTimer
   * @type {module:AWT.Timer} */
  cursorTimer: null,
  /**
   * Whether the wildcard character is transparent or opaque
   * @name module:boxes/TextGrid.TextGrid#wildTransparent
   * @type {boolean} */
  wildTransparent: false,
});

/**
 * TextGrid default values
 * @name module:boxes/TextGrid.TextGrid.defaults
 * @constant
 * @type {object} */
TextGrid.defaults = defaults;

/**
 * Binary flags used to mark status
 * @name module:boxes/TextGrid.TextGrid.flags
 * @constant
 * @type {object} */
TextGrid.flags = flags;

/* harmony default export */ const boxes_TextGrid = (TextGrid);

;// CONCATENATED MODULE: ./src/activities/textGrid/WordSearch.js
/**
 *  File    : activities/textGrid/WordSearch.js
 *  Created : 15/06/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */









/**
 * This class of {@link module:Activity.Activity Activity} shows a {@link module:boxes/TextGrid.TextGrid TextGrid} with some words placed in horizontal,
 * vertical or diagonal direction, written right or upside down. The remaining grid cells will be
 * filled with randomly selected characters.
 *
 * The aim of the activity is to find all the words hidden on the text grid.
 * The content of an optional {@link module:boxes/ActiveBagContent.ActiveBagContent ActiveBagContent} can be revealed on an auxiliary panel as
 * words are found.
 * @extends module:Activity.Activity
 */
class WordSearch extends Activity {
  /**
   * WordSearch constructor
   * @param {module:project/JClicProject.JClicProject} project - The JClic project to which this activity belongs
   */
  constructor(project) {
    super(project);
  }

  /**
   * Retrieves the minimum number of actions needed to solve this activity
   * @override
   * @returns {number}
   */
  getMinNumActions() {
    return this.clues.length;
  }

  /**
   * This type of activity permits the user to display the solution
   * @override
   * @returns {boolean}
   */
  helpSolutionAllowed() {
    return true;
  }

  /**
   * This kind of activity uses random numbers to generate the filling characters
   * @override
   * @returns {boolean}
   */
  hasRandom() {
    return true;
  }
}

Object.assign(WordSearch.prototype, {
  /**
   * String array containing all the valid clues.
   * @name module:activities/textGrid/WordSearch.WordSearch#clues
   * @type {string[]} */
  clues: null,
  /**
   * Array of integers containing __for each clue__ the index
   * of an associated {@link module:boxes/ActiveBoxContent.ActiveBoxContent ActiveBoxContent} located on the secondary {@link module:boxes/ActiveBoxbag.ActiveBoxBag ActiveBoxBag}.
   * This associated element is optional.
   * @name module:activities/textGrid/WordSearch.WordSearch#clueItems
   * @type {number[]} */
  clueItems: null,
  /**
   * Objects that indicate if box grids A and B must be shuffled.
   * (defaults to _false_ in WordSearch activities)
   * @name module:activities/textGrid/WordSearch.WordSearch#shuffleA
   * @type {boolean} */
  shuffleA: false,
  /**
   * Objects that indicate if box grids A and B must be shuffled.
   * (defaults to _false_ in WordSearch activities)
   * @name module:activities/textGrid/WordSearch.WordSearch#shuffleB
   * @type {boolean} */
  shuffleB: false,
});

/**
 * The {@link module:Activity.ActivityPanel ActivityPanel} where {@link module:activities/textGrid/WordSearch.WordSearch WordSearch} activities are played.
 * @extends module:Activity.ActivityPanel
 */
class WordSearchPanel extends ActivityPanel {
  /**
   * WordSearchPanel constructor
   * @param {module:Activity.Activity} act - The {@link module:Activity.Activity Activity} to which this Panel belongs
   * @param {module:JClicPlayer.JClicPlayer} ps - Any object implementing the methods defined in the
   * [PlayStation](http://projectestac.github.io/jclic/apidoc/edu/xtec/jclic/PlayStation.html) Java interface.
   * @param {external:jQuery} [$div] - The jQuery DOM element where this Panel will deploy
   */
  constructor(act, ps, $div) {
    super(act, ps, $div);
    this.resolvedClues = [];
  }

  /**
   * Performs miscellaneous cleaning operations
   * @override
   */
  clear() {
    if (this.grid) {
      this.grid.end();
      this.grid = null;
    }
    if (this.bgAlt) {
      this.bgAlt.end();
      this.bgAlt = null;
    }
  }

  /**
   * Prepares the visual components of the activity
   * @override
   */
  buildVisualComponents() {
    if (this.firstRun)
      super.buildVisualComponents();
    this.clear();

    const
      tgc = this.act.tgc,
      abcAlt = this.act.abc['secondary'];
    if (abcAlt) {
      if (abcAlt.image) {
        abcAlt.setImgContent(this.act.project.mediaBag, null, false);
        if (abcAlt.animatedGifFile && !abcAlt.shaper.rectangularShapes && !this.act.shuffleB)
          this.$animatedBg = external_jquery_default()('<span/>').css({
            'background-image': `url(${abcAlt.animatedGifFile})`,
            'background-position': 'center',
            'background-repeat': 'no-repeat',
            position: 'absolute'
          }).appendTo(this.$div);
      }

      if (this.act.acp !== null)
        this.act.acp.generateContent(0, 0, [abcAlt], false);
    }

    if (tgc) {
      this.grid = boxes_TextGrid.createEmptyGrid(null, this, this.act.margin, this.act.margin, tgc, false);
      if (abcAlt) {
        this.bgAlt = boxes_ActiveBoxGrid.createEmptyGrid(null, this, this.act.margin, this.act.margin, abcAlt);
        if (this.$animatedBg && this.bgAlt.backgroundBox)
          this.bgAlt.backgroundBox['tmpTrans'] = true;
      }
      this.grid.setVisible(true);
    }
  }

  /**
   * Basic initialization procedure
   * @override
   */
  initActivity() {
    super.initActivity();
    if (!this.firstRun)
      this.buildVisualComponents();
    else
      this.firstRun = false;

    if (this.grid) {
      this.grid.setChars(this.act.tgc.text);
      this.grid.randomize();
      this.grid.setAllCellsAttribute(boxes_TextGrid.flags.INVERTED, false);

      this.resolvedClues = Array(this.act.clueItems.length).fill(false);

      if (this.bgAlt) {
        this.bgAlt.setContent(this.act.abc['secondary']);
        if (this.$animatedBg)
          this.bgAlt.clearAllBoxes();
        if (this.act.shuffleB)
          this.shuffle([this.bgAlt], true, true);
        this.bgAlt.setVisible(this.$animatedBg !== null || this.act.invAss);
      }

      this.setAndPlayMsg('initial', 'start');
      this.invalidate().update();
      this.playing = true;
    }
  }

  /**
   * Updates the graphic content of this panel.
   * This method will be called from {@link module:AWT.Container#update} when needed.
   * @override
   * @param {module:AWT.Rectangle} dirtyRegion - Specifies the area to be updated. When `null`,
   * it's the whole panel.
   */
  updateContent(dirtyRegion) {
    super.updateContent(dirtyRegion);
    if (this.grid && this.$canvas) {
      const
        canvas = this.$canvas.get(-1),
        ctx = canvas.getContext('2d');
      if (!dirtyRegion)
        dirtyRegion = new Rectangle(0, 0, canvas.width, canvas.height);
      ctx.clearRect(dirtyRegion.pos.x, dirtyRegion.pos.y, dirtyRegion.dim.width, dirtyRegion.dim.height);
      this.grid.update(ctx, dirtyRegion);
      if (this.bgAlt)
        this.bgAlt.update(ctx, dirtyRegion);
    }
    return this;
  }

  /**
   * Sets the real dimension of this panel.
   * @override
   * @param {module:AWT.Dimension} preferredMaxSize - The maximum surface available for the activity panel
   * @returns {module:AWT.Dimension}
   */
  setDimension(preferredMaxSize) {
    if (!this.grid || this.getBounds().equals(preferredMaxSize))
      return preferredMaxSize;
    if (this.bgAlt)
      return boxes_BoxBag.layoutDouble(preferredMaxSize, this.grid, this.bgAlt, this.act.boxGridPos, this.act.margin);
    else
      return boxes_BoxBag.layoutSingle(preferredMaxSize, this.grid, this.act.margin);
  }

  /**
   * Sets the size and position of this activity panel
   * @override
   * @param {module:AWT.Rectangle} rect
   */
  setBounds(rect) {
    if (this.$canvas)
      this.$canvas.remove();
    super.setBounds(rect);
    if (this.grid) {
      // Create the main canvas
      this.$canvas = external_jquery_default()(`<canvas width="${rect.dim.width}" height="${rect.dim.height}"/>`).css({
        position: 'absolute',
        top: 0,
        left: 0
      });
      // Resize animated gif background
      if (this.$animatedBg && this.bgAlt) {
        const bgRect = this.bgAlt.getBounds();
        this.$animatedBg.css({
          left: bgRect.pos.x,
          top: bgRect.pos.y,
          width: `${bgRect.dim.width}px`,
          height: `${bgRect.dim.height}px`,
          'background-size': `${bgRect.dim.width}px ${bgRect.dim.height}px`
        });
      }
      this.$div.append(this.$canvas);

      // Create a [BoxConnector](BoxConnector.html) and attach it to the canvas context
      this.bc = new boxes_BoxConnector(this, this.$canvas.get(-1).getContext('2d'));

      // Repaint all
      this.invalidate().update();
    }
  }

  /**
   * Calculates the current score
   * @returns {number}
   */
  getCurrentScore() {
    return this.resolvedClues.reduce((n, resolved) => resolved ? ++n : n, 0);
  }

  /**
   * Main handler used to process mouse, touch, keyboard and edit events
   * @override
   * @param {external:Event} event - The HTML event to be processed
   * @returns {boolean} - When this event handler returns `false`, jQuery will stop its
   * propagation through the DOM tree. See: {@link http://api.jquery.com/on}
   */
  processEvent(event) {
    if (this.bc && this.playing) {
      //
      // The [AWT.Point](AWT.html#Point) where the mouse or touch event has been originated
      let p = null;
      //
      // _touchend_ event don't provide pageX nor pageY information
      if (event.type === 'touchend')
        p = this.bc.active ? this.bc.dest.clone() : new Point();
      else {
        // Touch events can have more than one touch, so `pageX` must be obtained from `touches[0]`
        const
          x = event.originalEvent.touches ? event.originalEvent.touches[0].pageX : event.pageX,
          y = event.originalEvent.touches ? event.originalEvent.touches[0].pageY : event.pageY;
        p = new Point(x - this.$div.offset().left, y - this.$div.offset().top);
      }

      // Flag for tracking `mouseup` events
      let up = false;
      // Flag for assuring that only one media plays per event (avoid event sounds overlapping
      // cell's media sounds)
      let m = false;
      // Array to be filled with actions to be executed at the end of event processing
      const delayedActions = [];

      switch (event.type) {
        case 'touchcancel':
          // Canvel movement
          if (this.bc.active)
            this.bc.end();
          break;

        case 'mouseup':
          // Don't consider drag moves below 3 pixels. Can be a "trembling click"
          if (this.bc.active && p.distanceTo(this.bc.origin) <= 3)
            break;

          up = true;
        /* falls through */
        case 'touchend':
        case 'touchstart':
        case 'mousedown':
          if (!this.bc.active) {
            // A new word selection starts
            //
            // Selection of words can never start with a `mouseup` event
            if (up)
              break;

            this.ps.stopMedia(1);
            if (this.grid.contains(p)) {
              this.playEvent('click');
              this.bc.begin(p);
            }
          } else {
            this.ps.stopMedia(1);
            // Word selection completed
            //
            // Find the active boxes behind `bc.origin` and `p`
            const
              pt1 = this.grid.getLogicalCoords(this.bc.origin),
              pt2 = this.grid.getLogicalCoords(this.bc.dest);
            this.bc.end();
            const s = this.grid.getStringBetween(pt1.x, pt1.y, pt2.x, pt2.y);
            if (s !== null && s.length > 0) {
              let ok = false, c = 0;
              for (; c < this.act.clues.length; c++) {
                if (s === this.act.clues[c]) {
                  ok = true;
                  break;
                }
              }
              const repeated = this.resolvedClues[c];
              if (ok && !repeated) {
                this.resolvedClues[c] = true;
                this.grid.setAttributeBetween(pt1.x, pt1.y, pt2.x, pt2.y, boxes_TextGrid.flags.INVERTED, true);
                if (this.bgAlt !== null) {
                  const k = this.act.clueItems[c];
                  if (k >= 0 && k < this.bgAlt.getNumCells()) {
                    const bx = this.bgAlt.getActiveBox(this.act.clueItems[c]);
                    if (bx) {
                      bx.setVisible(this.$animatedBg === null && !this.act.invAss);
                      m = bx.playMedia(this.ps, delayedActions);
                    }
                  }
                }
              }
              if (!repeated) {
                const r = this.getCurrentScore();
                this.ps.reportNewAction(this.act, 'ACTION_SELECT', s, null, ok, r);
                if (r === this.act.clues.length)
                  this.finishActivity(true);
                else if (!m)
                  this.playEvent(ok ? 'actionOK' : 'actionError');
                this.invalidate();
              } else if (!ok && !m)
                this.playEvent('actionError');
            } else
              this.playEvent('actionError');

            this.update();
          }
          break;

        case 'mousemove':
        case 'touchmove':
          this.bc.moveTo(p);
          break;
      }
      delayedActions.forEach(action => action());
      event.preventDefault();
    }
  }
}

Object.assign(WordSearchPanel.prototype, {
  /**
   * The {@link module:boxes/TextGrid.TextGrid TextGrid} object of this ActivityPanel
   * @name module:activities/textGrid/WordSearch.WordSearchPanel#grid
   * @type {module:boxes/TextGrid.TextGrid} */
  grid: null,
  /**
   * An optional {@link module:boxes/ActiveBoxbag.ActiveBoxBag ActiveBoxBag} used to display information associated with the hidden words.
   * @name module:activities/textGrid/WordSearch.WordSearchPanel#bgAlt
   * @type {module:boxes/ActiveBoxBag.ActiveBoxBag} */
  bgAlt: null,
  /**
   * An array of boolean values indicating which clues have been found
   * @name module:activities/textGrid/WordSearch.WordSearchPanel#resolvedClues
   * @type {boolean[]} */
  resolvedClues: null,
  /**
   * The box connector object
   * @name module:activities/textGrid/WordSearch.WordSearchPanel#bc
   * @type {module:boxes/BoxConnector.BoxConnector} */
  bc: null,
  /**
   * Mouse and touch events intercepted by this panel
   * @override
   * @name module:activities/textGrid/WordSearch.WordSearchPanel#events
   * @type {string[]} */
  events: ['mousedown', 'mouseup', 'mousemove', 'touchstart', 'touchend', 'touchmove', 'touchcancel'],
});

/**
 * Panel class associated to this type of activity: {@link module:activities/textGrid/WordSearch.WordSearchPanel WordSearchPanel}
 * @type {class} */
WordSearch.Panel = WordSearchPanel;

// Register activity class
/* harmony default export */ const textGrid_WordSearch = (Activity.registerClass('@textGrid.WordSearch', WordSearch));

;// CONCATENATED MODULE: ./src/activities/textGrid/icons/hIcon.svg
const hIcon_namespaceObject = "<svg fill=\"#FFFFFF\" height=\"36\" viewBox=\"0 0 24 24\" width=\"36\" xmlns=\"http://www.w3.org/2000/svg\">\n  <path d=\"M6 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm12 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm-6 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z\" />\n</svg>\n";
;// CONCATENATED MODULE: ./src/activities/textGrid/icons/vIcon.svg
const vIcon_namespaceObject = "<svg fill=\"#FFFFFF\" height=\"36\" viewBox=\"0 0 24 24\" width=\"36\" xmlns=\"http://www.w3.org/2000/svg\">\n  <path d=\"M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z\" />\n</svg>\n";
;// CONCATENATED MODULE: ./src/activities/textGrid/CrossWord.js
/**
 *  File    : activities/textGrid/CrossWord.js
 *  Created : 17/06/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */

/* global window */











// Use Webpack to import SVG files



/**
 * This class of {@link module:Activity.Activity Activity} shows a {@link module:boxes/TextGrid.TextGrid TextGrid} initially empty, with some cells
 * marked in negative color that act as word stoppers. A blinking "cursor" indicates the cell that
 * will receive the next character entered by the user on the keyboard.
 *
 * The letter in each cell of the grid is always shared by two words: one in horizontal direction
 * and the other one in vertical direction. Two {@link module:boxes/ActiveBox.ActiveBox ActiveBox} objects are placed next to the
 * {@link module:boxes/TextGrid.TextGrid TextGrid}, hosting the definitions of the horizontal and vertical words crossing at the
 * cell currently marked by the cursor.
 *
 * Two special buttons placed near this boxes allow to write on the grid horizontally or vertically.
 * The aim of the activity is to fill all the text grid with the correct words.
 * @extends module:Activity.Activity
 */
class CrossWord extends Activity {
  /**
   * CrossWord constructor
   * @param {module:project/JClicProject.JClicProject} project - The JClic project to which this activity belongs
   */
  constructor(project) {
    super(project);
  }

  /**
   * Retrieves the minimum number of actions needed to solve this activity
   * @override
   * @returns {number}
   */
  getMinNumActions() {
    return this.tgc.getNumChars() - this.tgc.countWildChars();
  }

  /**
   * Crossword activities always make use of the keyboard
   * @override
   * @returns {boolean}
   */
  needsKeyboard() {
    return true;
  }
}

Object.assign(CrossWord.prototype, {
  /**
   * Whether all letters of the {@link module:boxes/TextGrid.TextGrid TextGrid} should be displayed in upper case
   * @name module:activities/textGrid/CrossWord.CrossWord#upperCase
   * @type {boolean} */
  upperCase: true,
  /**
   * Whether the case is significant to evaluate answers
   * @name module:activities/textGrid/CrossWord.CrossWord#checkCase
   * @type {boolean} */
  checkCase: true,
  /**
   * When `true`, the wildcard character of the {@link module:boxes/TextGrid.TextGrid TextGrid} will be transparent.
   * @name module:activities/textGrid/CrossWord.CrossWord#wildTransparent
   * @type {boolean} */
  wildTransparent: false,
});

/**
 * The {@link module:Activity.ActivityPanel ActivityPanel} where {@link module:activities/textGrid/CrossWord.CrossWord CrossWord} activities are played.
 * @extends module:Activity.ActivityPanel
 */
class CrossWordPanel extends ActivityPanel {
  /**
   * CrossWordPanel constructor
   * @param {module:Activity.Activity} act - The {@link module:Activity.Activity Activity} to which this Panel belongs
   * @param {module:JClicPlayer.JClicPlayer} ps - Any object implementing the methods defined in the
   * [PlayStation](http://projectestac.github.io/jclic/apidoc/edu/xtec/jclic/PlayStation.html) Java interface.
   * @param {external:jQuery} [$div] - The jQuery DOM element where this Panel will deploy
   */
  constructor(act, ps, $div) {
    super(act, ps, $div);
  }

  /**
   * Performs miscellaneous cleaning operations
   * @override
   */
  clear() {
    if (this.grid) {
      this.grid.end();
      this.grid = null;
    }
    if (this.style) {
      this.style.end();
      this.style = null;
    }
  }

  /**
   * Creates a {@link module:boxes/BoxBag.BoxBag BoxBag} with a label ("Horizontal" or "Vertical") and an {@link module:boxes/ActiveBox.ActiveBox ActiveBox}
   * that will be used to display clues.
   * @param {string} type - `acrossClues` for horizontal clues, 'downClues' for vertical.
   * @returns {module:boxes/BoxBag.BoxBag}
   */
  createBoxBag(type) {
    const
      bxb = new boxes_BoxBag(null, this, null),
      sb = new boxes_AbstractBox(bxb, this, this.icoBB);

    sb.setBounds(0, 0, this.LABEL_WIDTH, this.act.abc[type].h);
    const $btn = external_jquery_default()('<button/>', { class: 'StockBtn' }).css({
      'width': this.LABEL_WIDTH,
      'height': this.act.abc[type].h,
      'background-image': `url(${type === 'acrossClues' ? this.hIcon : this.vIcon})`,
      'background-repeat': 'no-repeat',
      'background-position': 'center',
      'border-radius': 6,
      'z-index': 10
    }).on('click', () => {
      this.advance = type === 'acrossClues' ?
        this.advance === 'ADVANCE_RIGHT' ?
          'NO_ADVANCE' : 'ADVANCE_RIGHT' :
        this.advance === 'ADVANCE_DOWN' ?
          'NO_ADVANCE' : 'ADVANCE_DOWN';
      this.setBtnStatus();
    }).on('keypress', event => {
      if (String.fromCharCode(event.charCode || event.keyCode) === ' ')
        event.stopPropagation();
    }).appendTo(this.$div);

    sb.setHostedComponent($btn);
    bxb.addBox(sb);

    const ab = new boxes_ActiveBox(bxb, null, null, type, new Rectangle(this.LABEL_WIDTH + this.act.margin, 0, this.act.abc[type].w, this.act.abc[type].h));
    bxb.addBox(ab);
    bxb.setBoxBase(this.act.abc[type].style);

    if (type === 'acrossClues') { // Horizontal
      this.hClue = ab;
      this.hClueBtn = sb;
    } else {
      this.vClue = ab;
      this.vClueBtn = sb;
    }
    return bxb;
  }

  /**
   * Prepares the visual components of the activity
   * @override
   */
  buildVisualComponents() {
    if (this.firstRun)
      super.buildVisualComponents();
    this.clear();

    const
      tgc = this.act.tgc,
      abcH = this.act.abc['acrossClues'],
      abcV = this.act.abc['downClues'];

    if (abcH.image)
      abcH.setImgContent(this.act.project.mediaBag, null, false);
    if (abcV.image)
      abcV.setImgContent(this.act.project.mediaBag, null, false);

    if (this.act.acp !== null) {
      this.act.acp.generateContent(0, 0, this.act.abc, false);
    }

    if (tgc) {
      this.grid = boxes_TextGrid.createEmptyGrid(null, this, this.act.margin, this.act.margin, tgc, this.act.wildTransparent);
      this.style = new boxes_BoxBag(null, this, null);
      const
        bxbh = this.createBoxBag('acrossClues'),
        bxbv = this.createBoxBag('downClues');
      if (this.act.boxGridPos === 'AUB' || this.act.boxGridPos === 'BUA')
        bxbv.moveTo(new Point(bxbh.dim.width + this.act.margin, 0));
      else
        bxbv.moveTo(new Point(0, bxbh.dim.height + this.act.margin));
      this.style.addBox(bxbh);
      this.style.addBox(bxbv);
      this.grid.setVisible(true);
      this.style.setVisible(true);
    }
  }

  /**
   * Basic initialization procedure
   * @override
   */
  initActivity() {
    super.initActivity();
    if (!this.firstRun)
      this.buildVisualComponents();
    else
      this.firstRun = false;

    if (this.grid) {
      this.grid.setChars(this.act.tgc.text);
      this.numLetters = this.act.getMinNumActions();
      this.grid.setCellAttributes(true, true);
      this.grid.setCursorEnabled(true);
      this.setCursorAt(0, 0);
      this.advance = 'ADVANCE_RIGHT';
      this.setBtnStatus();
      this.setAndPlayMsg('initial', 'start');
      this.invalidate().update();
      this.$div.attr("tabindex", 0);
      this.$div.focus();
      this.playing = true;
    }
  }

  /**
   * Calculates the current score
   * @returns {number}
   */
  getCurrentScore() {
    return this.grid ? this.grid.countCoincidences(this.act.checkCase) : 0;
  }

  /**
   * Updates the graphic content of this panel.
   * This method will be called from {@link module:AWT.Container#update} when needed.
   * @override
   * @param {module:AWT.Rectangle} dirtyRegion - Specifies the area to be updated. When `null`,
   * it's the whole panel.
   */
  updateContent(dirtyRegion) {
    super.updateContent(dirtyRegion);
    if (this.grid && this.$canvas) {
      const
        canvas = this.$canvas.get(-1),
        ctx = canvas.getContext('2d');
      if (!dirtyRegion)
        dirtyRegion = new Rectangle(0, 0, canvas.width, canvas.height);
      ctx.clearRect(dirtyRegion.pos.x, dirtyRegion.pos.y, dirtyRegion.dim.width, dirtyRegion.dim.height);
      this.grid.update(ctx, dirtyRegion);
      this.style.update(ctx, dirtyRegion);
    }
    return this;
  }

  /**
   * Sets the real dimension of this panel.
   * @override
   * @param {module:AWT.Dimension} preferredMaxSize - The maximum surface available for the activity panel
   * @returns {module:AWT.Dimension}
   */
  setDimension(preferredMaxSize) {
    return !this.grid || !this.style || this.getBounds().equals(preferredMaxSize) ?
      preferredMaxSize :
      boxes_BoxBag.layoutDouble(preferredMaxSize, this.grid, this.style, this.act.boxGridPos, this.act.margin);
  }

  /**
   * Sets the size and position of this activity panel
   * @override
   * @param {module:AWT.Rectangle} rect
   */
  setBounds(rect) {
    if (this.$canvas) {
      this.$canvas.remove();
      this.$canvas = null;
    }
    super.setBounds(rect);

    if (this.grid) {
      // Create the main canvas
      this.$canvas = external_jquery_default()(`<canvas width="${rect.dim.width}" height="${rect.dim.height}"/>`).css({
        position: 'absolute',
        top: 0,
        left: 0
      });
      this.$div.append(this.$canvas);
      // Repaint all
      this.invalidate().update();
    }
  }

  /**
   * Main handler used to process mouse, touch, keyboard and edit events
   * @override
   * @param {external:Event} event - The HTML event to be processed
   * @returns {boolean} - When this event handler returns `false`, jQuery will stop its
   * propagation through the DOM tree. See: {@link http://api.jquery.com/on}
   */
  processEvent(event) {
    if (this.playing) {
      switch (event.type) {
        case 'click':
          //
          // The [AWT.Point](AWT.html#Point) where the mouse or touch event has been originated
          // Touch events can have more than one touch, so `pageX` must be obtained from `touches[0]`
          const
            x = event.originalEvent && event.originalEvent.touches ? event.originalEvent.touches[0].pageX : event.pageX,
            y = event.originalEvent && event.originalEvent.touches ? event.originalEvent.touches[0].pageY : event.pageY,
            p = new Point(x - this.$div.offset().left, y - this.$div.offset().top),
            // Array to be filled with actions to be executed at the end of event processing
            delayedActions = [];

          this.ps.stopMedia(1);
          if (this.grid.contains(p)) {
            const pt = this.grid.getLogicalCoords(p);
            if (pt !== null) {
              this.setCursorAt(pt.x, pt.y);
              if (settings.TOUCH_DEVICE) {
                // We are in a touch device, so prompt user to write text:
                const d = this.advance === 'ADVANCE_DOWN';
                const txt = window.prompt(`${d ? 'Vertical' : 'Horizontal'} word:`, '');
                this.writeChars(txt);
              }
            }
          } else if (this.hClue.contains(p))
            this.hClue.playMedia(this.ps, delayedActions);
          else if (this.vClue.contains(p))
            this.vClue.playMedia(this.ps, delayedActions);
          else
            break;

          this.update();
          delayedActions.forEach(action => action());
          break;

        case 'keypress':
          const code = event.charCode || event.keyCode;
          if (code && this.grid.getCursor()) {
            event.preventDefault();
            this.writeChars(String.fromCharCode(code));
          }
          break;

        case 'keydown':
          let dx = 0, dy = 0;
          switch (event.keyCode) {
            case settings.VK.RIGHT:
              dx = 1;
              break;
            case settings.VK.LEFT:
              dx = -1;
              break;
            case settings.VK.DOWN:
              dy = 1;
              break;
            case settings.VK.UP:
              dy = -1;
              break;
          }
          if (dx || dy) {
            event.preventDefault();
            this.moveCursor(dx, dy);
            this.update();
          }
          break;
      }
    }
  }

  /**
   * Moves the cursor the specified `dx` and `dy` amount (in logical coordinates)
   * @param {number} dx - Amount of cells to horizontally move on
   * @param {number} dy - Amount of cells to vertically move on
   */
  moveCursor(dx, dy) {
    if (this.grid) {
      this.grid.moveCursor(dx, dy, true);
      this.cursorPosChanged();
    }
  }

  /**
   * Places the cursor at the specified location (in logical coordinates)
   * @param {number} x
   * @param {number} y
   */
  setCursorAt(x, y) {
    this.grid.setCursorAt(x, y, true);
    this.cursorPosChanged();
  }

  /**
   * Method called when the cursor moves to a different location
   */
  cursorPosChanged() {
    const pt = this.grid.getCursor();
    if (pt !== null && this.style !== null) {
      const items = this.grid.getItemFor(pt.x, pt.y);
      if (items !== null) {
        this.hClue.setContent(this.act.abc['acrossClues'].getActiveBoxContentWith(pt.y, items.x));
        this.vClue.setContent(this.act.abc['downClues'].getActiveBoxContentWith(pt.x, items.y));
      }
    }
  }

  /**
   * Writes a string on the grid starting at the current cursor position and
   * following the direction marked by the `advance` field
   * @param {string} txt - Text to write
   */
  writeChars(txt) {
    if (txt && txt.length > 0) {
      for (let i = 0; i < txt.length; i++) {
        const cur = this.grid.getCursor();
        let ch = txt.charAt(i);
        if (this.act.upperCase)
          ch = ch.toLocaleUpperCase();
        this.grid.setCharAt(cur.x, cur.y, ch);
        const
          ok = this.grid.isCellOk(cur.x, cur.y, this.act.checkCase),
          r = this.getCurrentScore();
        this.ps.reportNewAction(this.act, 'WRITE', ch, `X:${cur.x} Y:${cur.y}`, ok, r);
        // End activity or play event sound
        if (r === this.numLetters) {
          this.grid.setCursorEnabled(false);
          this.grid.stopCursorBlink();
          this.finishActivity(true);
        } else {
          this.playEvent('click');
          if (this.advance === 'ADVANCE_DOWN')
            this.moveCursor(0, 1);
          else if (this.advance === 'ADVANCE_RIGHT')
            this.moveCursor(1, 0);
        }
      }
    }
    this.update();
  }

  /**
   * Sets the status of horizontal and vertical buttons based on the value of `advance`
   */
  setBtnStatus() {
    if (this.hClueBtn)
      this.hClueBtn.setInactive(this.advance !== 'ADVANCE_RIGHT');
    if (this.vClueBtn)
      this.vClueBtn.setInactive(this.advance !== 'ADVANCE_DOWN');
  }
}

Object.assign(CrossWordPanel.prototype, {
  /**
   * The default width of the 'Horizontal' and 'Vertical' buttons (currently 40 pixels)
   * @name module:activities/textGrid/CrossWord.CrossWordPanel#LABEL_WIDTH
   * @type {number} */
  LABEL_WIDTH: 40,
  /**
   * The text grid of this ActivityPanel
   * @name module:activities/textGrid/CrossWord.CrossWordPanel#grid
   * @type {module:boxes/TextGrid.TextGrid} */
  grid: null,
  /**
   * A BoxBag used to place the across and down clues, and the `toggle direction` button.
   * @name module:activities/textGrid/CrossWord.CrossWordPanel#style
   * @type {module:boxes/BoxBag.BoxBag} */
  style: null,
  /**
   * The total number of letters of this cross word
   * @name module:activities/textGrid/CrossWord.CrossWordPanel#numLetters
   * @type {number} */
  numLetters: 0,
  /**
   * Flag indicating the type of automatic advance of the cursor.
   * Possible values are: `NO_ADVANCE` (default), 'ADVANCE_RIGHT' and 'ADVANCE_DOWN'.
   * TODO: Implement 'ADVANCE_LEFT' for LTR languages
   * @name module:activities/textGrid/CrossWord.CrossWordPanel#advance
   * @type {string} */
  advance: 'NO_ADVANCE',
  /**
   * The ActiveBox object used to display the 'across' clues
   * @name module:activities/textGrid/CrossWord.CrossWordPanel#hClue
   * @type {module:boxes/ActiveBox.ActiveBox} */
  hClue: null,
  /**
   * The ActiveBox object used to display the 'down' clues
   * @name module:activities/textGrid/CrossWord.CrossWordPanel#vClue
   * @type {module:boxes/ActiveBox.ActiveBox} */
  vClue: null,
  /**
   * Button used to set the advance mode to 'ADVANCE_RIGHT'
   * @name module:activities/textGrid/CrossWord.CrossWordPanel#hClueBtn
   * @type {module:boxes/ActiveBox.ActiveBox} */
  hClueBtn: null,
  /**
   * Button used to set the advance mode to 'ADVANCE_BOTTOM'
   * @name module:activities/textGrid/CrossWord.CrossWordPanel#vClueBtn
   * @type {module:boxes/ActiveBox.ActiveBox} */
  vClueBtn: null,
  /**
   * Mouse and touch events intercepted by this panel
   * @override
   * @name module:activities/textGrid/CrossWord.CrossWordPanel#events
   * @type {string[]} */
  events: ['click', 'keydown', 'keypress'],
  /**
   * Graphic icon for the horizontal direction button, represented as a string containing
   * an SVG file codified in base64.
   * @name module:activities/textGrid/CrossWord.CrossWordPanel#hIcon
   * @type {string} */
  hIcon: svgToURI(hIcon_namespaceObject),
  /**
   * Graphic icon for the vertical direction button, represented as a string containing
   * an SVG file codified in base64.
   * @name module:activities/textGrid/CrossWord.CrossWordPanel#vIcon
   * @type {string} */
  vIcon: svgToURI(vIcon_namespaceObject),
  /**
   * Sizes of the icons (currently 36 x 36 pixel)
   * @name module:activities/textGrid/CrossWord.CrossWordPanel#icoSize
   * @type {object} */
  icoSize: { w: 36, h: 36 },
  /**
   * BoxBase with the style to be used by the direction buttons.
   * @name module:activities/textGrid/CrossWord.CrossWordPanel#icoBB
   * @type {module:boxes/BoxBase.BoxBase} */
  icoBB: new boxes_BoxBase().set('backColor', '#4285F4').set('inactiveColor', '#70A2F6').set('dontFill', true)
});

/**
 * Panel class associated to this type of activity: {@link module:activities/textGrid/CrossWord.CrossWordPanel CrossWordPanel}
 * @type {class} */
CrossWord.Panel = CrossWordPanel;

// Register activity class
/* harmony default export */ const textGrid_CrossWord = (Activity.registerClass('@textGrid.CrossWord', CrossWord));

;// CONCATENATED MODULE: ./src/report/TCPReporter.js
/**
 *  File    : report/TCPReporter.js
 *  Created : 08/06/2016
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Catalan Educational Telematic Network (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */

/* global Promise, document, window, XMLSerializer */





/**
 * This special case of {@link module:Reporter.Reporter Reporter} connects with an external service reporter providing
 * the {@link https://github.com/projectestac/jclic/wiki/JClic-Reports-developers-guide JClic Reports API}.
 * Connection parameters to the reports server (`path`, `service`, `userId`, `key`, `context`...)
 * are passed through the `options` element of {@link module:JClicPlayer.JClicPlayer JClicPlayer} (acting as {@link module:JClicPlayer.JClicPlayer JClicPlayer}).
 * @extends module:reports/Reporter.Reporter
 */
class TCPReporter extends report_Reporter {
  /**
   * TCPReporter constructor
   * @param {module:JClicPlayer.JClicPlayer} ps - The {@link module:JClicPlayer.JClicPlayer JClicPlayer} used to retrieve settings and localized messages
   */
  constructor(ps) {
    super(ps);
    this.tasks = [];
  }

  /**
   * Gets a specific property from this reporting system
   * @override
   * @param {string} key - Requested property
   * @param {string}+ defaultValue - Default return value when requested property does not exist
   * @returns {string}
   */
  getProperty(key, defaultValue) {
    return this.dbProperties !== null && this.dbProperties.hasOwnProperty(key) ?
      this.dbProperties[key] :
      defaultValue;
  }

  /**
   * Adds a new element to the list of report beans pending to be transmitted.
   * @param {module:report/TCPReporter.ReportBean} bean
   */
  addTask(bean) {
    if (this.processingTasks) {
      if (this.waitingTasks === null)
        this.waitingTasks = [bean];
      else
        this.waitingTasks.push(bean);
    } else
      this.tasks.push(bean);
  }

  /**
   * Transmits all report beans currently stored in `tasks` to the reports server
   * @returns {external:Promise}
   */
  flushTasksPromise() {
    if (this.processingTasks || this.currentSessionId === null ||
      this.tasks.length === 0 || this.serviceUrl === null) {
      // The task list cannot be processed now. Pass and wait until the next timer cycle:
      if (this.processingTasks)
        this.forceFlush = true;
      return Promise.resolve(true);
    }
    else {
      // Set up the `processingTasks` flag to avoid re-entrant processing
      this.processingTasks = true;

      const reportBean = new ReportBean('multiple');
      for (let i = 0; i < this.tasks.length; i++)
        reportBean.appendData(this.tasks[i].$bean);

      log('debug', 'Reporting:', reportBean.$bean[0]);

      return new Promise((resolve, reject) => {
        this.transaction(reportBean.$bean)
          .done((_data, _textStatus, _jqXHR) => {
            // TODO: Check returned message for possible errors on the server side
            this.failCount = 0;

            // Clear waiting tasks
            if (this.waitingTasks) {
              this.tasks = this.waitingTasks;
              this.waitingTasks = null;
            }
            else {
              this.forceFlush = false;
              this.tasks = [];
            }

            if (this.forceFlush && this.tasks.length > 0) {
              this.forceFlush = false;
              this.processingTasks = false;
              this.flushTasksPromise().then(() => {
                resolve(true);
              });
            }
            else {
              this.forceFlush = false;
              resolve(true);
              this.processingTasks = false;
            }
          })
          .fail((jqXHR, textStatus, errorThrown) => {
            if (++this.failCount > this.maxFails)
              this.stopReporting().then();
            reject(`Error reporting results to ${this.serviceUrl} [${textStatus} ${errorThrown}]`);
            this.processingTasks = false;
          });
      });
    }
  }

  /**
   * Initializes this report system with an optional set of parameters.
   * Returns a Promise, fulfilled when the reporter is fully initialized.
   * @override
   * @param {object} [options] - Initial settings passed to the reporting system
   * @returns {external:Promise}
   */
  init(options) {
    if (typeof options === 'undefined' || options === null)
      options = this.ps.options;
    super.init(options);
    this.initiated = false;
    this.stopReporting();

    this.serverPath = options.path || this.DEFAULT_SERVER_PATH;
    this.descriptionDetail = this.serverPath;
    let serverService = options.service || this.DEFAULT_SERVER_SERVICE;
    if (!startsWith(serverService, '/'))
      serverService = `/${serverService}`;
    const serverProtocol = options.protocol || this.DEFAULT_SERVER_PROTOCOL;
    this.serviceUrl = `${serverProtocol}://${this.serverPath}${serverService}`;

    const bean = new ReportBean('get_properties');
    return new Promise((resolve, reject) => {
      this.transaction(bean.$bean)
        .done((data, _textStatus, _jqXHR) => {
          this.dbProperties = {};
          external_jquery_default()(data).find('param').each((_n, param) => {
            const $param = external_jquery_default()(param);
            this.dbProperties[$param.attr('name')] = $param.attr('value');
          });
          this.promptUserId(false).then(userId => {
            this.userId = userId;
            const tl = options.lap || this.getProperty('TIME_LAP', this.DEFAULT_TIMER_LAP);
            this.timerLap = Math.min(30, Math.max(1, parseInt(tl)));
            this.timer = window.setInterval(() => this.flushTasksPromise().then(), this.timerLap * 1000);
            // Warn before leaving the current page with unsaved data:
            this.beforeUnloadFunction = event => {
              if (this.serviceUrl !== null &&
                (this.tasks.length > 0 || this.processingTasks)) {
                this.flushTasksPromise().then();
                const result = getMsg('Please wait until the results of your activities are sent to the reports system');
                if (event)
                  event.returnValue = result;
                return result;
              }
            };
            window.addEventListener('beforeunload', this.beforeUnloadFunction);
            this.initiated = true;
            resolve(true);
          }).catch(msg => {
            this.stopReporting();
            reject(`Error getting the user ID: ${msg}`);
          });
        })
        .fail((jqXHR, textStatus, errorThrown) => {
          this.stopReporting();
          reject(`Error initializing reports service ${this.serviceUrl} [${textStatus} ${errorThrown}]`);
        });
    });
  }

  /**
   * This method should be invoked when a new session starts.
   * @override
   * @param {module:project/JClicProject.JClicProject} jcp - The {@link module:project/JClicProject.JClicProject JClicProject} this session refers to.
   */
  newSession(jcp) {
    super.newSession(jcp);
    if (this.serviceUrl && this.userId !== null) {
      // Session ID will be obtained when reporting first activity
      this.currentSessionId = null;
    }
  }

  /**
   * Creates a new session in the remote database and records its ID for future use
   * @param {boolean} forceNewSession - When `true`, a new session will always be created.
   * @returns {external:Promise} - A Promise reporter will be successfully resolved
   * only when `currentSessionId` have a valid value.
   */
  createDBSession(forceNewSession) {
    if (this.currentSessionId !== null && !forceNewSession)
      // A valid session is available, so just return it
      return Promise.resolve(this.currentSessionId);
    else
      // A new session must be created:
      return new Promise((resolve, reject) => {
        if (this.initiated && this.userId !== null && this.currentSession !== null) {
          this.flushTasksPromise().then(() => {
            this.currentSessionId = null;
            const bean = new ReportBean('add session');

            bean.setParam('project', this.currentSession.projectName);
            bean.setParam('activities', Number(this.currentSession.reportableActs));
            bean.setParam('time', Number(this.currentSession.started));
            bean.setParam('code', this.currentSession.code);
            bean.setParam('user', this.userId);
            bean.setParam('key', this.sessionKey);
            bean.setParam('context', this.sessionContext);

            this.transaction(bean.$bean)
              .done((data, _textStatus, _jqXHR) => {
                this.currentSessionId = external_jquery_default()(data).find('param[name="session"]').attr('value');
                resolve(this.currentSessionId);
              })
              .fail((jqXHR, textStatus, errorThrown) => {
                this.stopReporting();
                reject(`Error creating new reports session in ${this.serviceUrl} [${textStatus} ${errorThrown}]`);
              });
          });
        } else
          reject('Unable to start session in remote server!');
      });
  }

  /**
   * Closes this reporting system
   * @override
   * @returns {external:Promise} - A promise to be fullfilled when all pending tasks are finished, or _null_ if not active.
   */
  end() {
    this.reportActivity(true);
    return this.stopReporting().then(super.end());
  }

  /**
   * Performs a transaction on the remote server
   * @param {external:jQuery} $xml - The XML element to be transmited, wrapped into a jQuery object
   * @returns {external:jqXHR} - The {@link external:jqXHR} obtained as a result of a call to `$.ajax`.
   * This object should be treated as a Promise or
   * as a JQuery {@link https://api.jquery.com/category/deferred-object|Deferred} object.
   */
  transaction($xml) {
    return this.serviceUrl === null ?
      null :
      external_jquery_default().ajax({
        method: 'POST',
        url: this.serviceUrl,
        data: '<?xml version="1.0" encoding="UTF-8"?>' +
          (new XMLSerializer()).serializeToString($xml.get(0)).replace('minactions', 'minActions').replace('reportactions', 'reportActions'),
        contentType: 'text/xml',
        dataType: 'xml'
      });
  }

  /**
   * Gets the list of current groups or organizations registered on this reporting system.
   * @override
   * @returns {external:Promise} - When fulfilled, an array of group data is returned as a result
   */
  getGroups() {
    return new Promise((resolve, reject) => {
      if (!this.userBased())
        reject('This system does not manage users!');
      else {
        const bean = new ReportBean('get groups');
        this.transaction(bean.$bean)
          .done((data, _textStatus, _jqXHR) => {
            const currentGroups = [];
            external_jquery_default()(data).find('group').each((_n, gr) => {
              const $group = external_jquery_default()(gr);
              currentGroups.push({ id: $group.attr('id'), name: $group.attr('name') });
            });
            resolve(currentGroups);
          })
          .fail((jqXHR, textStatus, errorThrown) => {
            reject(`Error retrieving groups list from ${this.serviceUrl} [${textStatus} ${errorThrown}]`);
          });
      }
    });
  }

  /**
   * Gets the list of users currently registered in the system, optionally filtered by
   * a specific group ID.
   * @override
   * @param {string}+ groupId - Optional group ID to be used as a filter criteria
   * @returns {external:Promise} - When fulfilled, an object with a collection of user data records
   * is returned
   */
  getUsers(groupId) {
    return new Promise((resolve, reject) => {
      if (!this.userBased())
        reject('This system does not manage users!');
      else {
        const bean = new ReportBean('get users');
        if (typeof groupId !== 'undefined' && groupId !== null)
          bean.setParam('group', groupId);
        this.transaction(bean.$bean)
          .done((data, _textStatus, _jqXHR) => {
            const currentUsers = [];
            external_jquery_default()(data).find('user').each((_n, usr) => {
              const $user = external_jquery_default()(usr);
              const user = { id: $user.attr('id'), name: $user.attr('name') };
              if ($user.attr('pwd'))
                user.pwd = $user.attr('pwd');
              currentUsers.push(user);
            });
            resolve(currentUsers);
          })
          .fail((jqXHR, textStatus, errorThrown) => {
            reject(`Error retrieving users list from ${this.serviceUrl} [${textStatus} ${errorThrown}]`);
          });
      }
    });
  }

  /**
   * Gets extended data associated with a specific user.
   * @param {string} userId - The requested user ID
   * @returns {external:Promise} - When fulfilled, an object with user data is returned.
   */
  getUserData(userId) {
    return new Promise((resolve, reject) => {
      if (!this.userBased())
        reject('This system does not manage users!');
      else {
        const bean = new ReportBean('get user data');

        if (typeof userId !== 'undefined' && userId !== null)
          bean.setParam('user', userId);
        else
          reject('Invalid user ID');

        this.transaction(bean.$bean)
          .done((data, _textStatus, _jqXHR) => {
            const $user = external_jquery_default()(data).find('user');
            if ($user.length !== 1) {
              window.alert(getMsg('Invalid user'));
              resolve('Invalid user ID');
            } else {
              const user = { id: $user.attr('id'), name: $user.attr('name') };
              if ($user.attr('pwd'))
                user.pwd = $user.attr('pwd');
              resolve(user);
            }
          })
          .fail((jqXHR, textStatus, errorThrown) => {
            reject(`Error retrieving user data from ${this.serviceUrl} [${textStatus} ${errorThrown}]`);
          });
      }
    });
  }

  /**
   * Stops the reporting system, usually as a result of repeated errors or because the player
   * shuts down.
   * @returns {external:Promise} - A promise to be fullfilled when all pending tasks are finished.
   */
  stopReporting() {
    let result = null;
    if (this.timer >= 0) {
      window.clearInterval(this.timer);
      this.timer = -1;
    }
    if (this.beforeUnloadFunction) {
      window.removeEventListener('beforeunload', this.beforeUnloadFunction);
      this.beforeUnloadFunction = null;
    }
    if (this.initiated) {
      result = this.flushTasksPromise().then(() => {
        this.serviceUrl = null;
        this.descriptionDetail = `${this.serverPath} (${getMsg('not connected')})`;
        this.initiated = false;
      });
    }
    return result || Promise.resolve(true);
  }

  /**
   * Prepares a {@link module:report/TCPReporter.ReportBean ReportBean} object with information related to the current
   * activity, and pushes it into the list of pending `tasks`, to be processed by the main `timer`.
   * @param {boolean} flushNow - When `true`, the activity data will be sent to server as soon as possible
   */
  reportActivity(flushNow) {
    if (this.lastActivity) {
      if (!this.lastActivity.closed)
        this.lastActivity.closeActivity();
      const
        actCount = this.actCount++,
        act = this.lastActivity;
      this.createDBSession(false).then(() => {
        const bean = new ReportBean('add activity');
        bean.setParam('session', this.currentSessionId);
        bean.setParam('num', actCount);
        bean.appendData(act.$getXML());
        this.addTask(bean);
        if (flushNow)
          this.flushTasksPromise().then();
      });
    }
    if (this.currentSession !== null &&
      this.currentSession.currentSequence !== null &&
      this.currentSession.currentSequence.currentActivity !== this.lastActivity) {
      this.lastActivity = this.currentSession.currentSequence.currentActivity;
    } else
      this.lastActivity = null;
  }

  /**
   * This method should be invoked when the user starts a new activity
   * @override
   * @param {module:Activity.Activity} act - The {@link module:Activity.Activity Activity} reporter has just started
   */
  newActivity(act) {
    super.newActivity(act);
    this.reportActivity(false);
  }

  /**
   * This method should be called when the current activity finishes. Data about user's final results
   * on the activity will then be saved.
   * @override
   * @param {number} score - The final score, usually in a 0-100 scale.
   * @param {number} numActions - The total number of actions done by the user to solve the activity
   * @param {boolean} solved - `true` if the activity was finally solved, `false` otherwise.
   */
  endActivity(score, numActions, solved) {
    super.endActivity(score, numActions, solved);
    this.reportActivity(true);
  }
}

Object.assign(TCPReporter.prototype, {
  /**
   * Description of this reporting system
   * @name module:report/TCPReporter.TCPReporter#descriptionKey
   * @override
   * @type {string} */
  descriptionKey: 'Reporting to remote server',
  /**
   * Additional info to display after the reporter's `description`
   * @name module:report/TCPReporter.TCPReporter#descriptionDetail
   * @override
   * @type {string} */
  descriptionDetail: '(not connected)',
  /**
   * Main path of the reports server (without protocol nor service)
   * @name module:report/TCPReporter.TCPReporter#serverPath
   * @type {string} */
  serverPath: '',
  /**
   * Function to be called by the browser before leaving the current page
   * @name module:report/TCPReporter.TCPReporter#beforeUnloadFunction
   * @type {function} */
  beforeUnloadFunction: null,
  /**
   * Identifier of the current session, provided by the server
   * @name module:report/TCPReporter.TCPReporter#currentSessionId
   * @type {string} */
  currentSessionId: '',
  /**
   * Last activity reported
   * @name module:report/TCPReporter.TCPReporter#lastActivity
   * @type {module:report/ActivityReg.ActivityReg} */
  lastActivity: null,
  /**
   * Number of activities processed
   * @name module:report/TCPReporter.TCPReporter#actCount
   * @type {number} */
  actCount: 0,
  /**
   * Service URL of the JClic Reports server
   * @name module:report/TCPReporter.TCPReporter#serviceUrl
   * @type {string} */
  serviceUrl: null,
  /**
   * Object used to store specific properties of the connected reports system
   * @name module:report/TCPReporter.TCPReporter#dbProperties
   * @type {object} */
  dbProperties: null,
  /**
   * List of {@link module:report/TCPReporter.ReportBean ReportBean} objects pending to be processed
   * @name module:report/TCPReporter.TCPReporter#tasks
   * @type {module:report/TCPReporter.ReportBean[]} */
  tasks: null,
  /**
   * Waiting list of tasks, to be used while `tasks` is being processed
   * @name module:report/TCPReporter.TCPReporter#waitingTasks
   * @type {module:report/TCPReporter.ReportBean[]} */
  waitingTasks: null,
  /**
   * Flag used to indicate if `transaction` is currently running
   * @name module:report/TCPReporter.TCPReporter#processingTasks
   * @type {boolean} */
  processingTasks: false,
  /**
   * Force processing of pending tasks as soon as possible
   * @name module:report/TCPReporter.TCPReporter#forceFlush
   * @type {boolean} */
  forceFlush: false,
  /**
   * Identifier of the background function obtained with a call to `window.setInterval`
   * @name module:report/TCPReporter.TCPReporter#timer
   * @type {number} */
  timer: -1,
  /**
   * Time between calls to the background function, in seconds
   * @name module:report/TCPReporter.TCPReporter#timerLap
   * @type {number} */
  timerLap: 5,
  /**
   * Counter of unsuccessful connection attempts with the report server
   * @name module:report/TCPReporter.TCPReporter#failCount
   * @type {number} */
  failCount: 0,
  /**
   * Maximum number of failed attempts allowed before disconnecting
   * @name module:report/TCPReporter.TCPReporter#maxFails
   * @type {number} */
  maxFails: 5,
  /**
   * Default path of JClic Reports Server
   * @name module:report/TCPReporter.TCPReporter#DEFAULT_SERVER_PATH
   * @type {string} */
  DEFAULT_SERVER_PATH: 'localhost:9000',
  /**
   * Default name for the reports service
   * @name module:report/TCPReporter.TCPReporter#DEFAULT_SERVER_SERVICE
   * @type {string} */
  DEFAULT_SERVER_SERVICE: '/JClicReportService',
  /**
   * Default server protocol
   * Use always 'https' except when in 'http' and protocol not set in options
   * @name module:report/TCPReporter.TCPReporter#DEFAULT_SERVER_PROTOCOL
   * @type {string} */
  DEFAULT_SERVER_PROTOCOL: (document && document.location && document.location.protocol === 'http:') ? 'http' : 'https',
  /**
   * Default lap between calls to `flushTasks`, in seconds
   * @name module:report/TCPReporter.TCPReporter#DEFAULT_TIMER_LAP
   * @type {number} */
  DEFAULT_TIMER_LAP: 20,
});

/**
 * This inner class encapsulates a chunk of information in XML format, ready to be
 * transmitted to the remote reports server.
 */
class ReportBean {
  /**
   * ReportBean constructor
   * @param id {string} - The main identifier of this ReportBean. Current valid values are:
   * `get property`, `get_properties`, `add session`, `add activity`, `get groups`, `get users`,
   * `get user data`, `get group data`, `new group`, `new user` and `multiple`.
   * @param $data {external:jQuery}+ - Optional XML data to be added to this bean
   */
  constructor(id, $data) {
    this.$bean = external_jquery_default()('<bean/>').attr({ id: id });
    if ($data)
      this.appendData($data);
  }

  /**
   * Adds  an XML element to the bean
   * @param {external:jQuery} $data - The XML element to be added to this bean
   */
  appendData($data) {
    if ($data) {
      this.$bean.append($data);
    }
  }

  /**
   * Adds an XML element of type `param` to this ReportBean
   * @param {string} name - The key name of the parameter
   * @param {string|number|boolean} value - The value of the parameter
   */
  setParam(name, value) {
    if (typeof value !== 'undefined' && value !== null)
      this.appendData(external_jquery_default()('<param/>').attr({ name: name, value: value }));
  }
}

Object.assign(ReportBean.prototype, {
  /**
   * The main jQuery XML object managed by this ReportBean
   * @name module:report/TCPReporter.ReportBean#$bean
   * @type {external:jQuery} */
  $bean: null,
});

TCPReporter.ReportBean = ReportBean;

// Register class in Reporter.CLASSES
/* harmony default export */ const report_TCPReporter = (report_Reporter.registerClass('TCPReporter', TCPReporter));

;// CONCATENATED MODULE: ./src/report/SessionStorageReporter.js
/**
 *  File    : report/SessionStorageReporter.js
 *  Created : 06/09/2017
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2020 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */

/* global window */



/**
 * This JClic {@link module:Reporter.Reporter Reporter} writes persistent data to the browser local session storage. It uses some of
 * the {@link https://github.com/projectestac/jclic/wiki/JClic-Reports-developers-guide JClic Reports API}.
 * Connection parameters (`key`, `context`...) are passed through the `options` element of {@link module:JClicPlayer.JClicPlayer JClicPlayer} (acting as {@link module:JClicPlayer.JClicPlayer JClicPlayer}).
 * Set `storage=local` in `options` to store reports in [`window.localStorage`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage}
 * instead of [`window.sessionStorage`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage} (default).
 * @extends module:reports/Reporter.Reporter
 */
class SessionStorageReporter extends report_Reporter {
  /**
   * SessionStorageReporter constructor
   * @param {module:JClicPlayer.JClicPlayer} ps - The {@link module:JClicPlayer.JClicPlayer JClicPlayer} used to retrieve settings and localized messages
   */
  constructor(ps) {
    super(ps);
    this.key = `jclic_${(new Date()).toISOString()}#${Math.ceil(Math.random() * 1000)}`;
  }

  /**
   * Initializes this report system with an optional set of parameters.
   * Returns a Promise, fulfilled when the reporter is fully initialized.
   * @override
   * @param {object} [options] - Initial settings passed to the reporting system
   * @returns {external:Promise}
   */
  init(options) {
    if (typeof options === 'undefined' || options === null)
      options = this.ps.options;
    if (options.storage === 'local') {
      this.storage = window.localStorage;
      this.descriptionKey = 'Reporting to local storage';
    }
    return report_Reporter.prototype.init.call(this, options);
  }

  /**
   * 
   * Saves the current report data to sessionStorage
   */
  saveCurrentReport() {
    // Update results out of current thread
    window.setTimeout(() => {
      this.storage.setItem(this.key, JSON.stringify(this.getData()));
    }, 0);
  }

  /**
   * Finalizes the current sequence
   * @override
   */
  endSequence() {
    super.endSequence();
    this.saveCurrentReport();
  }

  /**
   * This method should be called when the current activity finishes. Data about user's final results
   * on the activity will then be saved.
   * @override
   * @param {number} score - The final score, usually in a 0-100 scale.
   * @param {number} numActions - The total number of actions done by the user to solve the activity
   * @param {boolean} solved - `true` if the activity was finally solved, `false` otherwise.
   */
  endActivity(score, numActions, solved) {
    super.endActivity(score, numActions, solved);
    this.saveCurrentReport();
  }
}

Object.assign(SessionStorageReporter.prototype, {
  /**
   * Type of storage to be used. Defaults to `window.sessionStorage`
   * @name module:report/SessionStorageReporter.SessionStorageReporter#storage
   * @type {external:Storage} */
  storage: window.sessionStorage,
  /**
   * Description of this reporting system
   * @name module:report/SessionStorageReporter.SessionStorageReporter#descriptionKey
   * @override
   * @type {string} */
  descriptionKey: 'Reporting to session storage',
  /**
   * Additional info to display after the reporter's `description`
   * @name module:report/SessionStorageReporter.SessionStorageReporter#descriptionDetail
   * @override
   * @type {string} */
  descriptionDetail: '(browser session)',
  /**
   * Key used to save the report into sessionStorage
   * @name module:report/SessionStorageReporter.SessionStorageReporter#key 
   * @type {string} */
  key: null,
});

// Register class in Reporter.CLASSES
/* harmony default export */ const report_SessionStorageReporter = (report_Reporter.registerClass('SessionStorageReporter', SessionStorageReporter));

;// CONCATENATED MODULE: ./src/Deps.js
/**
 *  File    : Deps.js
 *  Created : 19/05/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2021 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 */

// Declaration of JSDoc external objects:

/**
 * The Event interface represents an event which takes place in the DOM.
 * @external Event
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Event}
 */

/**
 * The HTMLElement interface represents any HTML element. Some elements directly implement this
 * interface, others implement it via an interface that inherits it.
 * @external HTMLElement
 * @see {@link https://developer.mozilla.org/ca/docs/Web/API/HTMLElement}
 */

/**
 * A jQuery object
 * @external jQuery
 * @see {@link http://api.jquery.com/jQuery/}
 */

/**
 * The jQuery XMLHttpRequest (jqXHR) object returned by `$.ajax()` as of jQuery 1.5 is a superset
 * of the browser's native [XMLHttpRequest](https://developer.mozilla.org/docs/XMLHttpRequest) object.
 * As of jQuery 1.5, jqXHR objects implement the Promise interface, giving them
 * all the properties, methods, and behavior of a Promise.
 * @external jqXHR
 * @see {@link https://api.jquery.com/jQuery.ajax/#jqXHR}
 */

/**
 * The CanvasRenderingContext2D interface provides the 2D rendering context for the drawing surface
 * of a &lt;canvas&gt; element.
 * @external CanvasRenderingContext2D
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D}
 */

/**
 * The HTMLImageElement interface provides special properties and methods (beyond the regular
 * {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement HTMLElement} interface it
 * also has available to it by inheritance) for manipulating the layout and presentation of
 * &lt;img&gt; elements.
 * @external HTMLImageElement
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement}
 */

/**
 * The HTMLAudioElement interface provides access to the properties of &lt;audio&gt; elements, as
 * well as methods to manipulate them. It derives from the
 * {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement HTMLMediaElement} interface.
 * @external HTMLAudioElement
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLAudioElement}
 */

/**
 * The AudioContext interface represents an audio-processing graph built from audio modules linked together.
 * @external AudioContext
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AudioContext}
 */

/**
 * The Intl.Collator object is a constructor for collators, objects that enable language sensitive
 * string comparison.
 * @external Collator
 * @see {@link https://developer.mozilla.org/ca/docs/Web/JavaScript/Reference/Global_Objects/Collator}
 */

/**
 * A JSZip object
 * @external JSZip
 * @see {@link https://stuk.github.io/jszip}
 */

/**
 * The MediaRecorder interface of the {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaRecorder_API MediaRecorder API}
 * provides functionality to easily capture media.
 * @external MediaRecorder
 * @see {@link https://developer.mozilla.org/ca/docs/Web/API/MediaRecorder}
 */

/**
 * The Promise object is used for asynchronous computations. A Promise represents an operation
 * that hasn't completed yet, but is expected in the future.
 * @external Promise
 * @see {@link https://developer.mozilla.org/ca/docs/Web/JavaScript/Reference/Global_Objects/Promise}
 */

/**
* The Storage interface of the Web Storage API provides access to the session storage or local storage for a particular domain,
* allowing you to for example add, modify or delete stored data items.
* @external Storage
* @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Storage}
*/

/**
 * The NamedNodeMap interface represents a collection of Attr objects. Objects inside a NamedNodeMap are not in any particular
 * order, unlike NodeList, although they may be accessed by an index as in an array.
 * @external NamedNodeMap
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap}
 */

/**
 * MidiPlayerJS is a JavaScript library which reads standard MIDI files and emits JSON events in real time.
 * @external MidiPlayerJS
 * @see {@link https://github.com/grimmdude/MidiPlayerJS}
 */

/**
 * JavaScript Date objects represent a single moment in time in a platform-independent format.
 * @external Date
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date}
 */

/**
* The HTMLStyleElement interface represents a [style](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style) element.
* It inherits properties and methods from its parent, HTMLElement, and from LinkStyle.
* @external HTMLStyleElement
* @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLStyleElement}
*/

/**
 * Type of MIDI instrument used by Soundfont Player
 * @external Instrument
 * @see {@link https://github.com/danigb/soundfont-player}
 */

//
// The purpose of this file is to ensure that certain classes derived from the main objects of
// JClic ([Activity](Activity.html), [Shaper](Shaper.html), [Skin](Skin.html) and
// [AutoContentProvider](AutoContentProvider.html)) are loaded at the beginning.




































/* harmony default export */ const Deps = ({
  DefaultSkin: skins_DefaultSkin,
  OrangeSkin: skins_OrangeSkin,
  GreenSkin: skins_GreenSkin,
  BlueSkin: skins_BlueSkin,
  SimpleSkin: skins_SimpleSkin,
  MiniSkin: skins_MiniSkin,
  EmptySkin: skins_EmptySkin,
  CustomSkin: skins_CustomSkin,
  Rectangular: shapers_Rectangular,
  Holes: shapers_Holes,
  JigSaw: shapers_JigSaw,
  TriangularJigSaw: shapers_TriangularJigSaw,
  ClassicJigSaw: shapers_ClassicJigSaw,
  Arith: arith_Arith,
  TextActivityBase: text_TextActivityBase,
  FillInBlanks: text_FillInBlanks,
  OrderText: text_OrderText,
  Complete: text_Complete,
  IdentifyText: text_IdentifyText,
  WrittenAnswer: text_WrittenAnswer,
  InformationScreen: panels_InformationScreen,
  Identify: panels_Identify,
  Explore: panels_Explore,
  Menu: panels_Menu,
  DoublePuzzle: puzzles_DoublePuzzle,
  ExchangePuzzle: puzzles_ExchangePuzzle,
  HolePuzzle: puzzles_HolePuzzle,
  MemoryGame: memory_MemoryGame,
  SimpleAssociation: associations_SimpleAssociation,
  ComplexAssociation: associations_ComplexAssociation,
  WordSearch: textGrid_WordSearch,
  CrossWord: textGrid_CrossWord,
  TCPReporter: report_TCPReporter,
  SessionStorageReporter: report_SessionStorageReporter,
});

;// CONCATENATED MODULE: ./src/JClic.js
/*!
 *  File    : JClic.js
 *  Created : 01/04/2015
 *  By      : Francesc Busquets <francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.2
 *  @licstart
 *  (c) 2000-2021 Educational Telematic Network of Catalonia (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 *  @module
 */

/* global JClicDataProject, JClicDataOptions, window, document */








/**
 * This is the main method of JClic
 *
 * Executes on `document.ready()`.
 *
 * The method iterates over all `div` objects with `JClic` class and creates a {@link module:JClicPlayer.JClicPlayer JClicPlayer}
 * within them. Each player loads the JClic project file specified in the `data-project` attribute of
 * the `div` tag.
 *
 * The `div` elements must preferabily be empty. Inner content may become overlapped by objects
 * created by the JClic player.
 *
 * This method exports the global variable `window.JClicObject`, useful when other scripts
 * need to make direct calls to the main components of JClic.
 *
 * The main members of the global variable `JClicObject` are:
 * - `JClicObject.JClicPlayer` (the {@link module:JClicPlayer} object)
 * - `JClicObject.JClicProject` (the {@link module:JClicProject} object)
 * - `JClicObject.AWT` (the {@link module:AWT} object)
 * - `JClicObject.Utils` (the {@link module:Utils} object)
 * - `JClicObject.$` (the JQuery object)
 * - `JClicObject.options` (the main options loaded at startup, usually the content of the global variable `JClicDataOptions`)
 * - `JClicObject.projectFiles` (used by JSONP to store the content of some files when inaccessible to the browser because CORS or other restrictions)
 * - `JClicObject.currentPlayers` (array with references to the players currently running)
 * - `JClicObject.loadProject` (a function that starts a JClicPlayer on a specific `div`)
 *
 *  @module JClic
 * @example <caption>
 * Creates a JClic div and loads "myproject.jclic" on it:
 * </caption><div class ="JClic" data-project="myproject.jclic"></div>
 * @example <caption>
 * Creates a JClic div that loads "myproject.jclic" with additional parameters, passed as a JSON string.
 * Note that `data-options` should be delimited by apostrophes `'` because quotation marks `"` are used
 * for JSON keys and values:
 * </caption><div class ="JClic" data-project="myproject.jclic" data-options='{"fade":"400","lang":"es","reporter":"TCPReporter","user":"test01","path":"localhost:9090"}'></div>
 */
const JClicObject = {
  Deps: Deps,
  JClicPlayer: src_JClicPlayer,
  JClicProject: project_JClicProject,
  AWT: AWT,
  Utils: src_Utils,
  $: (external_jquery_default()),
  options: typeof JClicDataOptions === 'undefined' ? {} : JClicDataOptions,
  projectFiles: {},
  currentPlayers: [],
  loadProject,
};

/**
 *
 * Creates a new JClicPlayer hosted on the specified `div`, and loads an specific project on it.
 * @param {external:HTMLElement} div - The HTML element (usually a `<div/>`) that will be used as a main container of the player.
 * @param {string} projectName - The file name or URL of the JClic project to be loaded
 * @param {object} [options] - An optional set of preferences
 * @returns {module:JClicPlayer.JClicPlayer}
 */
function loadProject(div, projectName, options = {}) {

  options = init({ ...JClicObject.options, ...options }, true, false);
  let player = null;

  // Find if there is another player already running on 'div'
  for (const pl of JClicObject.currentPlayers) {
    if (pl && pl.$topDiv && pl.$topDiv.get(-1) === div) {
      // Player found! Check if it has the same options
      log('debug', 'Existing JClicPlayer found in div. I will try to reuse it.');
      player = pl;
      for (const prop of Object.getOwnPropertyNames(options)) {
        if (!player.options.hasOwnProperty(prop) || player.options[prop] !== options[prop]) {
          log('debug', 'Existing JClicPlayer has diferent options! Creating a new one from scratch.');
          player = null;
          break;
        }
      }
      break;
    }
  }

  if (player)
    player.reset();
  else {
    log('debug', 'Creating a new instance of JClicPlayer');
    player = new src_JClicPlayer(external_jquery_default()(div).empty(), options);
  }

  if (projectName)
    player.initReporter()
      .then(() => player.load(projectName))
      .catch(err => {
        log('error', `Unable to start reporting: ${err.toString()}.\n JClicPlayer will be removed.'`);
        external_jquery_default()(div).empty().removeAttr('style').append(external_jquery_default()('<h2/>').html(player.getMsg('ERROR'))).append(external_jquery_default()('<p/>').html(err));
        const i = JClicObject.currentPlayers.indexOf(player);
        if (i >= 0)
          JClicObject.currentPlayers.splice(i, 1);
        player = null;
      });

  if (player && options.savePlayersRef !== false && JClicObject.currentPlayers.indexOf(player) === -1)
    JClicObject.currentPlayers.push(player);

  return player;
}

// Make JClicObject global and attach resize handler
if (typeof window !== 'undefined') {
  window.JClicObject = JClicObject;
  const fnFit = () => JClicObject.currentPlayers.forEach(player => {
    if (player && player.skin)
      player.skin.fit();
  });
  external_jquery_default()(document).on('webkitfullscreenchange mozfullscreenchange fullscreenchange MSFullscreenChange', fnFit);
  external_jquery_default()(window).on('resize', fnFit);
}

// Execute on document ready
external_jquery_default()(function () {
  // If defined, load the global variable `JClicDataOptions`
  let options = typeof JClicDataOptions === 'undefined' ? {} : JClicDataOptions;
  JClicObject.options = options;

  if (!options.noInit) {
    // If defined, load the global variable `JClicDataProject` or `JClicObject.projectFile`
    let projectName =
      typeof JClicDataProject === 'string' ?
        JClicDataProject :
        typeof JClicObject.projectFile === 'string' ?
          JClicObject.projectFile :
          null;

    // Enable sync with browser history only when there is a single element of class 'JClic'.
    // This is done automatically when this element is a direct child of body, or when 'browserHistory' is
    // explicitly set
    options.browserHistory = external_jquery_default()('body>div.JClic').length === 1 || options.browserHistory && external_jquery_default()('.JClic').length === 1;

    // Search DOM elements with class "JClic" (usually of type 'div') and iterate over them
    // initializing players
    external_jquery_default()('.JClic').each((_n, element) => {
      const $div = external_jquery_default()(element);
      const prj = $div.data('project');
      if (prj)
        projectName = prj;

      const opt = $div.data('options');
      if (opt)
        options = external_jquery_default().extend(Object.create(options), opt);

      JClicObject.loadProject(element, projectName, options);
    });
  }
});

/* harmony default export */ const JClic = (JClicObject);

module.exports = __webpack_exports__["default"];
/******/ })()
;
//# sourceMappingURL=jclic-node.js.map